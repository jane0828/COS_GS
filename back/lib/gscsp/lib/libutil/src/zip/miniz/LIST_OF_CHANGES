------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
diff --git a/src/zip/miniz/miniz.h b/src/zip/miniz/miniz.h
index 86fac4c..f92f14e 100644
--- a/src/zip/miniz/miniz.h
+++ b/src/zip/miniz/miniz.h
@@ -447,7 +447,7 @@ typedef void *const voidpc;
 #define inflate mz_inflate
 #define inflateEnd mz_inflateEnd
 #define uncompress mz_uncompress
-#define crc32 mz_crc32
+// #define crc32 mz_crc32
 #define adler32 mz_adler32
 #define MAX_WBITS 15
 #define MAX_MEM_LEVEL 9

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

diff --git a/src/zip/miniz/miniz.c b/src/zip/miniz/miniz.c
index 67318cc..960f07c 100644
--- a/src/zip/miniz/miniz.c
+++ b/src/zip/miniz/miniz.c
@@ -1936,6 +1936,7 @@ tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_fun
     d->m_pSrc = NULL;
     d->m_src_buf_left = 0;
     d->m_out_buf_ofs = 0;
+    memset(d->m_dict, 0, sizeof(d->m_dict)); // Initialize array to 0's
     memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
     memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
     return TDEFL_STATUS_OKAY;
@@ -2464,7 +2465,7 @@ tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_nex
                 }
                 r->m_table_sizes[2] = 19;
             }
-            for (; (int)r->m_type >= 0; r->m_type--)
+            for (; ((int)r->m_type) >= 0; r->m_type--)
             {
                 int tree_next, tree_cur;
                 tinfl_huff_table *pTable;
@@ -3025,7 +3026,7 @@ static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
 #define MZ_DELETE_FILE remove
 
 #else
-#pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
+// #pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
 #ifndef MINIZ_NO_TIME
 #include <utime.h>
 #endif
@@ -3267,12 +3268,12 @@ static MZ_TIME_T mz_zip_dos_to_time_t(int dos_time, int dos_date)
 }
 
 #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-static void mz_zip_time_t_to_dos_time(MZ_TIME_T time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
+static void mz_zip_time_t_to_dos_time(MZ_TIME_T time_, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
 {
 #ifdef _MSC_VER
     struct tm tm_struct;
     struct tm *tm = &tm_struct;
-    errno_t err = localtime_s(tm, &time);
+    errno_t err = localtime_s(tm, &time_);
     if (err)
     {
         *pDOS_date = 0;
@@ -3280,7 +3281,7 @@ static void mz_zip_time_t_to_dos_time(MZ_TIME_T time, mz_uint16 *pDOS_time, mz_u
         return;
     }
 #else
-    struct tm *tm = localtime(&time);
+    struct tm *tm = localtime(&time_);
 #endif /* #ifdef _MSC_VER */
 
     *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
@@ -3874,7 +3875,10 @@ mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename,
     /* TODO: Better sanity check archive_size and the # of actual remaining bytes */
 
     if (file_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
+    {
+        MZ_FCLOSE(pFile);
         return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
+    }
 
     if (!mz_zip_reader_init_internal(pZip, flags))
     {
@@ -4134,7 +4138,7 @@ static mz_bool mz_zip_file_stat_internal(mz_zip_archive *pZip, mz_uint file_inde
 
                         pStat->m_local_header_ofs = MZ_READ_LE64(pField_data);
                         pField_data += sizeof(mz_uint64);
-                        field_data_remaining -= sizeof(mz_uint64);
+                        // field_data_remaining -= sizeof(mz_uint64);
                     }
 
                     break;
@@ -4219,11 +4223,11 @@ static mz_bool mz_zip_locate_file_binary_search(mz_zip_archive *pZip, const char
 
 int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
 {
-    mz_uint32 index;
-    if (!mz_zip_reader_locate_file_v2(pZip, pName, pComment, flags, &index))
+    mz_uint32 index_;
+    if (!mz_zip_reader_locate_file_v2(pZip, pName, pComment, flags, &index_))
         return -1;
     else
-        return (int)index;
+        return (int)index_;
 }
 
 mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *pIndex)
@@ -5332,12 +5336,12 @@ mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags)
         if (MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG & flags)
         {
             mz_uint32 found_index;
-            mz_zip_archive_file_stat stat;
+            mz_zip_archive_file_stat stat_;
 
-            if (!mz_zip_reader_file_stat(pZip, i, &stat))
+            if (!mz_zip_reader_file_stat(pZip, i, &stat_))
                 return MZ_FALSE;
 
-            if (!mz_zip_reader_locate_file_v2(pZip, stat.m_filename, NULL, 0, &found_index))
+            if (!mz_zip_reader_locate_file_v2(pZip, stat_.m_filename, NULL, 0, &found_index))
                 return MZ_FALSE;
 
             /* This check can fail if there are duplicate filenames in the archive (which we don't check for when writing - that's up to the user) */
@@ -6011,6 +6015,11 @@ mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_n
                                     mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified,
                                     const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
 {
+    if(!pZip)
+    {
+        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+    }
+
     mz_uint16 method = 0, dos_time = 0, dos_date = 0;
     mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
     mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
@@ -6035,7 +6044,7 @@ mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_n
     level = level_and_flags & 0xF;
     store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));
 
-    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
+    if ((!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
     pState = pZip->m_pState;
@@ -6296,6 +6305,11 @@ mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_n
 mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 size_to_add, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                 const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
 {
+    if(!pZip)
+    {
+        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+    }
+
     mz_uint16 gen_flags = MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;
     mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
     mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
@@ -6315,7 +6329,7 @@ mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name,
     level = level_and_flags & 0xF;
 
     /* Sanity checks */
-    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
+    if ((!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
     pState = pZip->m_pState;
@@ -6828,7 +6842,7 @@ mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *
 
             if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
             {
-                const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);
+                // const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);
 
                 if (field_data_size < sizeof(mz_uint64) * 2)
                 {
@@ -6836,8 +6850,8 @@ mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *
                     return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                 }
 
-                local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
-                local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64)); /* may be 0 if there's a descriptor */
+                // local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
+                // local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64)); /* may be 0 if there's a descriptor */
 
                 found_zip64_ext_data_in_ldir = MZ_TRUE;
                 break;
@@ -6966,7 +6980,7 @@ mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *
             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
         }
 
-        cur_src_file_ofs += n;
+        // cur_src_file_ofs += n;
         cur_dst_file_ofs += n;
     }
     pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

diff --git a/src/zip/miniz/miniz.h b/src/zip/miniz/miniz.h
index 68f903c..e517263 100644
--- a/src/zip/miniz/miniz.h
+++ b/src/zip/miniz/miniz.h
@@ -203,7 +203,7 @@ mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);
 
 #define MZ_CRC32_INIT (0)
 /* mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL. */
-mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);
+// mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);
 
 /* Compression strategies. */
 enum
@@ -301,7 +301,7 @@ typedef struct mz_stream_s
 typedef mz_stream *mz_streamp;
 
 /* Returns the version string of miniz.c. */
-const char *mz_version(void);
+// const char *mz_version(void);
 
 /* mz_deflateInit() initializes a compressor with default options: */
 /* Parameters: */
@@ -324,7 +324,7 @@ int mz_deflateInit(mz_streamp pStream, int level);
 int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);
 
 /* Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2(). */
-int mz_deflateReset(mz_streamp pStream);
+// int mz_deflateReset(mz_streamp pStream);
 
 /* mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible. */
 /* Parameters: */
@@ -345,7 +345,7 @@ int mz_deflate(mz_streamp pStream, int flush);
 int mz_deflateEnd(mz_streamp pStream);
 
 /* mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH. */
-mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);
+// mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);
 
 /* Single-call compression functions mz_compress() and mz_compress2(): */
 /* Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure. */
@@ -353,7 +353,7 @@ int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *
 int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level);
 
 /* mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress(). */
-mz_ulong mz_compressBound(mz_ulong source_len);
+// mz_ulong mz_compressBound(mz_ulong source_len);
 
 /* Initializes a decompressor. */
 int mz_inflateInit(mz_streamp pStream);
@@ -386,7 +386,7 @@ int mz_inflateEnd(mz_streamp pStream);
 int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
 
 /* Returns a string description of the specified error code, or NULL if the error code is invalid. */
-const char *mz_error(int err);
+// const char *mz_error(int err);
 
 /* Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports. */
 /* Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project. */
@@ -436,13 +436,13 @@ typedef void *const voidpc;
 #define z_stream mz_stream
 #define deflateInit mz_deflateInit
 #define deflateInit2 mz_deflateInit2
-#define deflateReset mz_deflateReset
+// #define deflateReset mz_deflateReset
 #define deflate mz_deflate
 #define deflateEnd mz_deflateEnd
-#define deflateBound mz_deflateBound
+// #define deflateBound mz_deflateBound
 #define compress mz_compress
 #define compress2 mz_compress2
-#define compressBound mz_compressBound
+// #define compressBound mz_compressBound
 #define inflateInit mz_inflateInit
 #define inflateInit2 mz_inflateInit2
 #define inflate mz_inflate
@@ -452,15 +452,15 @@ typedef void *const voidpc;
 #define adler32 mz_adler32
 #define MAX_WBITS 15
 #define MAX_MEM_LEVEL 9
-#define zError mz_error
+// #define zError mz_error
 #define ZLIB_VERSION MZ_VERSION
 #define ZLIB_VERNUM MZ_VERNUM
 #define ZLIB_VER_MAJOR MZ_VER_MAJOR
 #define ZLIB_VER_MINOR MZ_VER_MINOR
 #define ZLIB_VER_REVISION MZ_VER_REVISION
 #define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION
-#define zlibVersion mz_version
-#define zlib_version mz_version()
+// #define zlibVersion mz_version
+// #define zlib_version mz_version()
 #endif /* #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES */
 
 #endif /* MINIZ_NO_ZLIB_APIS */
@@ -501,15 +501,15 @@ typedef int mz_bool;
 #define MZ_FILE FILE
 #endif /* #ifdef MINIZ_NO_STDIO */
 
-#ifdef MINIZ_NO_TIME
-typedef struct mz_dummy_time_t_tag
-{
-    int m_dummy;
-} mz_dummy_time_t;
-#define MZ_TIME_T mz_dummy_time_t
-#else
-#define MZ_TIME_T time_t
-#endif
+// #ifdef MINIZ_NO_TIME
+// typedef struct mz_dummy_time_t_tag
+// {
+//     int m_dummy;
+// } mz_dummy_time_t;
+// #define MZ_TIME_T mz_dummy_time_t
+// #else
+// #define MZ_TIME_T time_t
+// #endif
 
 #define MZ_ASSERT(x) assert(x)
 
@@ -551,7 +551,7 @@ extern "C" {
 
 extern void *miniz_def_alloc_func(void *opaque, size_t items, size_t size);
 extern void miniz_def_free_func(void *opaque, void *address);
-extern void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size);
+// extern void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size);
 
 #define MZ_UINT16_MAX (0xFFFFU)
 #define MZ_UINT32_MAX (0xFFFFFFFFU)
@@ -609,11 +609,11 @@ enum
 /*  Function returns a pointer to the compressed data, or NULL on failure. */
 /*  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data. */
 /*  The caller must free() the returned block when it's no longer needed. */
-void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);
+// void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);
 
 /* tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory. */
 /* Returns 0 on failure. */
-size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);
+// size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);
 
 /* Compresses an image to a compressed PNG file in memory. */
 /* On entry: */
@@ -625,14 +625,14 @@ size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void
 /*  Function returns a pointer to the compressed data, or NULL on failure. */
 /*  *pLen_out will be set to the size of the PNG image file. */
 /*  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed. */
-void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
-void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);
+// void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
+// void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);
 
 /* Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time. */
 typedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);
 
 /* tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally. */
-mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);
+// mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);
 
 enum
 {
@@ -727,9 +727,9 @@ tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pI
 
 /* tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr. */
 /* tdefl_compress_buffer() always consumes the entire input buffer. */
-tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);
+// tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);
 
-tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
+// tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
 mz_uint32 tdefl_get_adler32(tdefl_compressor *d);
 
 /* Create tdefl_compress() flags given zlib-style compression parameters. */
@@ -741,8 +741,8 @@ mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int
 /* Allocate the tdefl_compressor structure in C so that */
 /* non-C language bindings to tdefl_ API don't need to worry about */
 /* structure size and allocation mechanism. */
-tdefl_compressor *tdefl_compressor_alloc();
-void tdefl_compressor_free(tdefl_compressor *pComp);
+// tdefl_compressor *tdefl_compressor_alloc();
+// void tdefl_compressor_free(tdefl_compressor *pComp);
 
 #ifdef __cplusplus
 }
@@ -775,17 +775,17 @@ enum
 /*  Function returns a pointer to the decompressed data, or NULL on failure. */
 /*  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data. */
 /*  The caller must call mz_free() on the returned block when it's no longer needed. */
-void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);
+// void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);
 
 /* tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory. */
 /* Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success. */
 #define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
-size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);
+// size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);
 
 /* tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer. */
 /* Returns 1 on success or 0 on failure. */
 typedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);
-int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);
+// int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);
 
 struct tinfl_decompressor_tag;
 typedef struct tinfl_decompressor_tag tinfl_decompressor;
@@ -794,8 +794,8 @@ typedef struct tinfl_decompressor_tag tinfl_decompressor;
 /* non-C language bindings to tinfl_ API don't need to worry about */
 /* structure size and allocation mechanism. */
 
-tinfl_decompressor *tinfl_decompressor_alloc();
-void tinfl_decompressor_free(tinfl_decompressor *pDecomp);
+// tinfl_decompressor *tinfl_decompressor_alloc();
+// void tinfl_decompressor_free(tinfl_decompressor *pDecomp);
 
 /* Max size of LZ dictionary. */
 #define TINFL_LZ_DICT_SIZE 32768
@@ -896,319 +896,319 @@ struct tinfl_decompressor_tag
 
 /* ------------------- ZIP archive reading/writing */
 
-#ifndef MINIZ_NO_ARCHIVE_APIS
+// #ifndef MINIZ_NO_ARCHIVE_APIS
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+// #ifdef __cplusplus
+// extern "C" {
+// #endif
 
-enum
-{
+// enum
+// {
     /* Note: These enums can be reduced as needed to save memory or stack space - they are pretty conservative. */
-    MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
-    MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 512,
-    MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 512
-};
-
-typedef struct
-{
-    /* Central directory file index. */
-    mz_uint32 m_file_index;
+//     MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
+//     MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 512,
+//     MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 512
+// };
+
+// typedef struct
+// {
+//     /* Central directory file index. */
+//     mz_uint32 m_file_index;
+
+//     /* Byte offset of this entry in the archive's central directory. Note we currently only support up to UINT_MAX or less bytes in the central dir. */
+//     mz_uint64 m_central_dir_ofs;
+
+//     /* These fields are copied directly from the zip's central dir. */
+//     mz_uint16 m_version_made_by;
+//     mz_uint16 m_version_needed;
+//     mz_uint16 m_bit_flag;
+//     mz_uint16 m_method;
+
+// #ifndef MINIZ_NO_TIME
+//     MZ_TIME_T m_time;
+// #endif
 
-    /* Byte offset of this entry in the archive's central directory. Note we currently only support up to UINT_MAX or less bytes in the central dir. */
-    mz_uint64 m_central_dir_ofs;
+//     /* CRC-32 of uncompressed data. */
+//     mz_uint32 m_crc32;
 
-    /* These fields are copied directly from the zip's central dir. */
-    mz_uint16 m_version_made_by;
-    mz_uint16 m_version_needed;
-    mz_uint16 m_bit_flag;
-    mz_uint16 m_method;
+//     /* File's compressed size. */
+//     mz_uint64 m_comp_size;
 
-#ifndef MINIZ_NO_TIME
-    MZ_TIME_T m_time;
-#endif
+//     /* File's uncompressed size. Note, I've seen some old archives where directory entries had 512 bytes for their uncompressed sizes, but when you try to unpack them you actually get 0 bytes. */
+//     mz_uint64 m_uncomp_size;
 
-    /* CRC-32 of uncompressed data. */
-    mz_uint32 m_crc32;
+//     /* Zip internal and external file attributes. */
+//     mz_uint16 m_internal_attr;
+//     mz_uint32 m_external_attr;
 
-    /* File's compressed size. */
-    mz_uint64 m_comp_size;
+//     /* Entry's local header file offset in bytes. */
+//     mz_uint64 m_local_header_ofs;
 
-    /* File's uncompressed size. Note, I've seen some old archives where directory entries had 512 bytes for their uncompressed sizes, but when you try to unpack them you actually get 0 bytes. */
-    mz_uint64 m_uncomp_size;
+//     /* Size of comment in bytes. */
+//     mz_uint32 m_comment_size;
 
-    /* Zip internal and external file attributes. */
-    mz_uint16 m_internal_attr;
-    mz_uint32 m_external_attr;
+//     /* MZ_TRUE if the entry appears to be a directory. */
+//     mz_bool m_is_directory;
 
-    /* Entry's local header file offset in bytes. */
-    mz_uint64 m_local_header_ofs;
+//     /* MZ_TRUE if the entry uses encryption/strong encryption (which miniz_zip doesn't support) */
+//     mz_bool m_is_encrypted;
 
-    /* Size of comment in bytes. */
-    mz_uint32 m_comment_size;
+//     /* MZ_TRUE if the file is not encrypted, a patch file, and if it uses a compression method we support. */
+//     mz_bool m_is_supported;
 
-    /* MZ_TRUE if the entry appears to be a directory. */
-    mz_bool m_is_directory;
+//     /* Filename. If string ends in '/' it's a subdirectory entry. */
+//     /* Guaranteed to be zero terminated, may be truncated to fit. */
+//     char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];
 
-    /* MZ_TRUE if the entry uses encryption/strong encryption (which miniz_zip doesn't support) */
-    mz_bool m_is_encrypted;
+//     /* Comment field. */
+//     /* Guaranteed to be zero terminated, may be truncated to fit. */
+//     char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];
 
-    /* MZ_TRUE if the file is not encrypted, a patch file, and if it uses a compression method we support. */
-    mz_bool m_is_supported;
+// } mz_zip_archive_file_stat;
 
-    /* Filename. If string ends in '/' it's a subdirectory entry. */
-    /* Guaranteed to be zero terminated, may be truncated to fit. */
-    char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];
+// typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
+// typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);
+// typedef mz_bool (*mz_file_needs_keepalive)(void *pOpaque);
 
-    /* Comment field. */
-    /* Guaranteed to be zero terminated, may be truncated to fit. */
-    char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];
+// struct mz_zip_internal_state_tag;
+// typedef struct mz_zip_internal_state_tag mz_zip_internal_state;
 
-} mz_zip_archive_file_stat;
+// typedef enum {
+//     MZ_ZIP_MODE_INVALID = 0,
+//     MZ_ZIP_MODE_READING = 1,
+//     MZ_ZIP_MODE_WRITING = 2,
+//     MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
+// } mz_zip_mode;
 
-typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
-typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);
-typedef mz_bool (*mz_file_needs_keepalive)(void *pOpaque);
+// typedef enum {
+//     MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
+//     MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
+//     MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
+//     MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800,
+    // MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG = 0x1000, /* if enabled, mz_zip_reader_locate_file() will be called on each file as its validated to ensure the func finds the file in the central dir (intended for testing) */
+    // MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY = 0x2000,     /* validate the local headers, but don't decompress the entire file and check the crc32 */
+    // MZ_ZIP_FLAG_WRITE_ZIP64 = 0x4000,               /* always use the zip64 file format, instead of the original zip file format with automatic switch to zip64. Use as flags parameter with mz_zip_writer_init*_v2 */
+//     MZ_ZIP_FLAG_WRITE_ALLOW_READING = 0x8000,
+//     MZ_ZIP_FLAG_ASCII_FILENAME = 0x10000
+// } mz_zip_flags;
 
-struct mz_zip_internal_state_tag;
-typedef struct mz_zip_internal_state_tag mz_zip_internal_state;
-
-typedef enum {
-    MZ_ZIP_MODE_INVALID = 0,
-    MZ_ZIP_MODE_READING = 1,
-    MZ_ZIP_MODE_WRITING = 2,
-    MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
-} mz_zip_mode;
-
-typedef enum {
-    MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
-    MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
-    MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
-    MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800,
-    MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG = 0x1000, /* if enabled, mz_zip_reader_locate_file() will be called on each file as its validated to ensure the func finds the file in the central dir (intended for testing) */
-    MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY = 0x2000,     /* validate the local headers, but don't decompress the entire file and check the crc32 */
-    MZ_ZIP_FLAG_WRITE_ZIP64 = 0x4000,               /* always use the zip64 file format, instead of the original zip file format with automatic switch to zip64. Use as flags parameter with mz_zip_writer_init*_v2 */
-    MZ_ZIP_FLAG_WRITE_ALLOW_READING = 0x8000,
-    MZ_ZIP_FLAG_ASCII_FILENAME = 0x10000
-} mz_zip_flags;
-
-typedef enum {
-    MZ_ZIP_TYPE_INVALID = 0,
-    MZ_ZIP_TYPE_USER,
-    MZ_ZIP_TYPE_MEMORY,
-    MZ_ZIP_TYPE_HEAP,
-    MZ_ZIP_TYPE_FILE,
-    MZ_ZIP_TYPE_CFILE,
-    MZ_ZIP_TOTAL_TYPES
-} mz_zip_type;
+// typedef enum {
+//     MZ_ZIP_TYPE_INVALID = 0,
+//     MZ_ZIP_TYPE_USER,
+//     MZ_ZIP_TYPE_MEMORY,
+//     MZ_ZIP_TYPE_HEAP,
+//     MZ_ZIP_TYPE_FILE,
+//     MZ_ZIP_TYPE_CFILE,
+//     MZ_ZIP_TOTAL_TYPES
+// } mz_zip_type;
 
 /* miniz error codes. Be sure to update mz_zip_get_error_string() if you add or modify this enum. */
-typedef enum {
-    MZ_ZIP_NO_ERROR = 0,
-    MZ_ZIP_UNDEFINED_ERROR,
-    MZ_ZIP_TOO_MANY_FILES,
-    MZ_ZIP_FILE_TOO_LARGE,
-    MZ_ZIP_UNSUPPORTED_METHOD,
-    MZ_ZIP_UNSUPPORTED_ENCRYPTION,
-    MZ_ZIP_UNSUPPORTED_FEATURE,
-    MZ_ZIP_FAILED_FINDING_CENTRAL_DIR,
-    MZ_ZIP_NOT_AN_ARCHIVE,
-    MZ_ZIP_INVALID_HEADER_OR_CORRUPTED,
-    MZ_ZIP_UNSUPPORTED_MULTIDISK,
-    MZ_ZIP_DECOMPRESSION_FAILED,
-    MZ_ZIP_COMPRESSION_FAILED,
-    MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE,
-    MZ_ZIP_CRC_CHECK_FAILED,
-    MZ_ZIP_UNSUPPORTED_CDIR_SIZE,
-    MZ_ZIP_ALLOC_FAILED,
-    MZ_ZIP_FILE_OPEN_FAILED,
-    MZ_ZIP_FILE_CREATE_FAILED,
-    MZ_ZIP_FILE_WRITE_FAILED,
-    MZ_ZIP_FILE_READ_FAILED,
-    MZ_ZIP_FILE_CLOSE_FAILED,
-    MZ_ZIP_FILE_SEEK_FAILED,
-    MZ_ZIP_FILE_STAT_FAILED,
-    MZ_ZIP_INVALID_PARAMETER,
-    MZ_ZIP_INVALID_FILENAME,
-    MZ_ZIP_BUF_TOO_SMALL,
-    MZ_ZIP_INTERNAL_ERROR,
-    MZ_ZIP_FILE_NOT_FOUND,
-    MZ_ZIP_ARCHIVE_TOO_LARGE,
-    MZ_ZIP_VALIDATION_FAILED,
-    MZ_ZIP_WRITE_CALLBACK_FAILED,
-    MZ_ZIP_TOTAL_ERRORS
-} mz_zip_error;
-
-typedef struct
-{
-    mz_uint64 m_archive_size;
-    mz_uint64 m_central_directory_file_ofs;
-
-    /* We only support up to UINT32_MAX files in zip64 mode. */
-    mz_uint32 m_total_files;
-    mz_zip_mode m_zip_mode;
-    mz_zip_type m_zip_type;
-    mz_zip_error m_last_error;
-
-    mz_uint64 m_file_offset_alignment;
-
-    mz_alloc_func m_pAlloc;
-    mz_free_func m_pFree;
-    mz_realloc_func m_pRealloc;
-    void *m_pAlloc_opaque;
-
-    mz_file_read_func m_pRead;
-    mz_file_write_func m_pWrite;
-    mz_file_needs_keepalive m_pNeeds_keepalive;
-    void *m_pIO_opaque;
-
-    mz_zip_internal_state *m_pState;
-
-} mz_zip_archive;
-
-typedef struct
-{
-    mz_zip_archive *pZip;
-    mz_uint flags;
-
-    int status;
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-    mz_uint file_crc32;
-#endif
-    mz_uint64 read_buf_size, read_buf_ofs, read_buf_avail, comp_remaining, out_buf_ofs, cur_file_ofs;
-    mz_zip_archive_file_stat file_stat;
-    void *pRead_buf;
-    void *pWrite_buf;
+// typedef enum {
+//     MZ_ZIP_NO_ERROR = 0,
+//     MZ_ZIP_UNDEFINED_ERROR,
+//     MZ_ZIP_TOO_MANY_FILES,
+//     MZ_ZIP_FILE_TOO_LARGE,
+//     MZ_ZIP_UNSUPPORTED_METHOD,
+//     MZ_ZIP_UNSUPPORTED_ENCRYPTION,
+//     MZ_ZIP_UNSUPPORTED_FEATURE,
+//     MZ_ZIP_FAILED_FINDING_CENTRAL_DIR,
+//     MZ_ZIP_NOT_AN_ARCHIVE,
+//     MZ_ZIP_INVALID_HEADER_OR_CORRUPTED,
+//     MZ_ZIP_UNSUPPORTED_MULTIDISK,
+//     MZ_ZIP_DECOMPRESSION_FAILED,
+//     MZ_ZIP_COMPRESSION_FAILED,
+//     MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE,
+//     MZ_ZIP_CRC_CHECK_FAILED,
+//     MZ_ZIP_UNSUPPORTED_CDIR_SIZE,
+//     MZ_ZIP_ALLOC_FAILED,
+//     MZ_ZIP_FILE_OPEN_FAILED,
+//     MZ_ZIP_FILE_CREATE_FAILED,
+//     MZ_ZIP_FILE_WRITE_FAILED,
+//     MZ_ZIP_FILE_READ_FAILED,
+//     MZ_ZIP_FILE_CLOSE_FAILED,
+//     MZ_ZIP_FILE_SEEK_FAILED,
+//     MZ_ZIP_FILE_STAT_FAILED,
+//     MZ_ZIP_INVALID_PARAMETER,
+//     MZ_ZIP_INVALID_FILENAME,
+//     MZ_ZIP_BUF_TOO_SMALL,
+//     MZ_ZIP_INTERNAL_ERROR,
+//     MZ_ZIP_FILE_NOT_FOUND,
+//     MZ_ZIP_ARCHIVE_TOO_LARGE,
+//     MZ_ZIP_VALIDATION_FAILED,
+//     MZ_ZIP_WRITE_CALLBACK_FAILED,
+//     MZ_ZIP_TOTAL_ERRORS
+// } mz_zip_error;
+
+// typedef struct
+// {
+//     mz_uint64 m_archive_size;
+//     mz_uint64 m_central_directory_file_ofs;
+
+//     /* We only support up to UINT32_MAX files in zip64 mode. */
+//     mz_uint32 m_total_files;
+//     mz_zip_mode m_zip_mode;
+//     mz_zip_type m_zip_type;
+//     mz_zip_error m_last_error;
+
+//     mz_uint64 m_file_offset_alignment;
+
+//     mz_alloc_func m_pAlloc;
+//     mz_free_func m_pFree;
+//     mz_realloc_func m_pRealloc;
+//     void *m_pAlloc_opaque;
+
+//     mz_file_read_func m_pRead;
+//     mz_file_write_func m_pWrite;
+//     mz_file_needs_keepalive m_pNeeds_keepalive;
+//     void *m_pIO_opaque;
+
+//     mz_zip_internal_state *m_pState;
+
+// } mz_zip_archive;
+
+// typedef struct
+// {
+//     mz_zip_archive *pZip;
+//     mz_uint flags;
+
+//     int status;
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//     mz_uint file_crc32;
+// #endif
+//     mz_uint64 read_buf_size, read_buf_ofs, read_buf_avail, comp_remaining, out_buf_ofs, cur_file_ofs;
+//     mz_zip_archive_file_stat file_stat;
+//     void *pRead_buf;
+//     void *pWrite_buf;
 
-    size_t out_blk_remain;
+//     size_t out_blk_remain;
 
-    tinfl_decompressor inflator;
+//     tinfl_decompressor inflator;
 
-} mz_zip_reader_extract_iter_state;
+// } mz_zip_reader_extract_iter_state;
 
 /* -------- ZIP reading */
 
 /* Inits a ZIP archive reader. */
 /* These functions read and validate the archive's central directory. */
-mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags);
+// mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags);
 
-mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags);
+// mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags);
 
-#ifndef MINIZ_NO_STDIO
+// #ifndef MINIZ_NO_STDIO
 /* Read a archive from a disk file. */
 /* file_start_ofs is the file offset where the archive actually begins, or 0. */
 /* actual_archive_size is the true total size of the archive, which may be smaller than the file's actual size on disk. If zero the entire file is treated as the archive. */
-mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
-mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size);
+// mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
+// mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size);
 
 /* Read an archive from an already opened FILE, beginning at the current file position. */
 /* The archive is assumed to be archive_size bytes long. If archive_size is < 0, then the entire rest of the file is assumed to contain the archive. */
 /* The FILE will NOT be closed when mz_zip_reader_end() is called. */
-mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags);
-#endif
+// mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags);
+// #endif
 
 /* Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used. */
-mz_bool mz_zip_reader_end(mz_zip_archive *pZip);
+// mz_bool mz_zip_reader_end(mz_zip_archive *pZip);
 
 /* -------- ZIP reading or writing */
 
 /* Clears a mz_zip_archive struct to all zeros. */
 /* Important: This must be done before passing the struct to any mz_zip functions. */
-void mz_zip_zero_struct(mz_zip_archive *pZip);
+// void mz_zip_zero_struct(mz_zip_archive *pZip);
 
-mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip);
-mz_zip_type mz_zip_get_type(mz_zip_archive *pZip);
+// mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip);
+// mz_zip_type mz_zip_get_type(mz_zip_archive *pZip);
 
 /* Returns the total number of files in the archive. */
-mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);
+// mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);
 
-mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip);
-mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip);
-MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip);
+// mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip);
+// mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip);
+// MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip);
 
 /* Reads n bytes of raw archive data, starting at file offset file_ofs, to pBuf. */
-size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n);
+// size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n);
 
 /* Attempts to locates a file in the archive's central directory. */
 /* Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH */
 /* Returns -1 if the file cannot be found. */
-int mz_zip_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
+// int mz_zip_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
 /* Returns MZ_FALSE if the file cannot be found. */
-mz_bool mz_zip_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *pIndex);
+// mz_bool mz_zip_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *pIndex);
 
 /* All mz_zip funcs set the m_last_error field in the mz_zip_archive struct. These functions retrieve/manipulate this field. */
 /* Note that the m_last_error functionality is not thread safe. */
-mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num);
-mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip);
-mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip);
-mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip);
-const char *mz_zip_get_error_string(mz_zip_error mz_err);
+// mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num);
+// mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip);
+// mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip);
+// mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip);
+// const char *mz_zip_get_error_string(mz_zip_error mz_err);
 
 /* MZ_TRUE if the archive file entry is a directory entry. */
-mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);
+// mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);
 
 /* MZ_TRUE if the file is encrypted/strong encrypted. */
-mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);
+// mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);
 
 /* MZ_TRUE if the compression method is supported, and the file is not encrypted, and the file is not a compressed patch file. */
-mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index);
+// mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index);
 
 /* Retrieves the filename of an archive file entry. */
 /* Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename. */
-mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);
+// mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);
 
 /* Attempts to locates a file in the archive's central directory. */
 /* Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH */
 /* Returns -1 if the file cannot be found. */
-int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
-int mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *file_index);
+// int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
+// int mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *file_index);
 
 /* Returns detailed information about an archive file entry. */
-mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);
+// mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);
 
 /* MZ_TRUE if the file is in zip64 format. */
 /* A file is considered zip64 if it contained a zip64 end of central directory marker, or if it contained any zip64 extended file information fields in the central directory. */
-mz_bool mz_zip_is_zip64(mz_zip_archive *pZip);
+// mz_bool mz_zip_is_zip64(mz_zip_archive *pZip);
 
 /* Returns the total central directory size in bytes. */
 /* The current max supported size is <= MZ_UINT32_MAX. */
-size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip);
+// size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip);
 
 /* Extracts a archive file to a memory buffer using no memory allocation. */
 /* There must be at least enough room on the stack to store the inflator's state (~34KB or so). */
-mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
-mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
+// mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
+// mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
 
 /* Extracts a archive file to a memory buffer. */
-mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
-mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);
+// mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
+// mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);
 
 /* Extracts a archive file to a dynamically allocated heap buffer. */
 /* The memory will be allocated via the mz_zip_archive's alloc/realloc functions. */
 /* Returns NULL and sets the last error on failure. */
-void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
-void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);
+// void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
+// void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);
 
 /* Extracts a archive file using a callback function to output the file's data. */
-mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
-mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
+// mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
+// mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
 
 /* Extract a file iteratively */
-mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
-mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);
-size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size);
-mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState);
+// mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
+// mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);
+// size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size);
+// mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState);
 
-#ifndef MINIZ_NO_STDIO
+// #ifndef MINIZ_NO_STDIO
 /* Extracts a archive file to a disk file and sets its last accessed and modified times. */
 /* This function only extracts files, not archive directory records. */
-mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
-mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);
+// mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
+// mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);
 
 /* Extracts a archive file starting at the current position in the destination FILE stream. */
-mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *File, mz_uint flags);
-mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags);
-#endif
+// mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *File, mz_uint flags);
+// mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags);
+// #endif
 
 #if 0
 /* TODO */
@@ -1233,26 +1233,26 @@ mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pA
 // mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr);
 
 /* Universal end function - calls either mz_zip_reader_end() or mz_zip_writer_end(). */
-mz_bool mz_zip_end(mz_zip_archive *pZip);
+// mz_bool mz_zip_end(mz_zip_archive *pZip);
 
 /* -------- ZIP writing */
 
-#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
+// #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
 
 /* Inits a ZIP archive writer. */
 /*Set pZip->m_pWrite (and pZip->m_pIO_opaque) before calling mz_zip_writer_init or mz_zip_writer_init_v2*/
 /*The output is streamable, i.e. file_ofs in mz_file_write_func always increases only by n*/
-mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
-mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags);
+// mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
+// mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags);
 
-mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
-mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags);
+// mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
+// mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags);
 
-#ifndef MINIZ_NO_STDIO
-mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
-mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags);
-mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags);
-#endif
+// #ifndef MINIZ_NO_STDIO
+// mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
+// mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags);
+// mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags);
+// #endif
 
 /* Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive. */
 /* For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called. */
@@ -1260,33 +1260,33 @@ mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint f
 /* Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL. */
 /* Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before */
 /* the archive is finalized the file's central directory will be hosed. */
-mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);
-mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);
+// mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);
+// mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);
 
 /* Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive. */
 /* To add a directory entry, call this method with an archive name ending in a forwardslash with an empty buffer. */
 /* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
-mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);
+// mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);
 
 /* Like mz_zip_writer_add_mem(), except you can specify a file comment field, and optionally supply the function with already compressed data. */
 /* uncomp_size/uncomp_crc32 are only used if the MZ_ZIP_FLAG_COMPRESSED_DATA flag is specified. */
-mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
-                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);
+// mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
+//                                  mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);
 
-mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
-                                    mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
-                                    const char *user_extra_data_central, mz_uint user_extra_data_central_len);
+// mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
+//                                     mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
+//                                     const char *user_extra_data_central, mz_uint user_extra_data_central_len);
 
-#ifndef MINIZ_NO_STDIO
+// #ifndef MINIZ_NO_STDIO
 /* Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive. */
 /* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
-mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
+// mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
 
 /* Like mz_zip_writer_add_file(), except the file data is read from the specified FILE stream. */
-mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 size_to_add,
-                                const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
-                                const char *user_extra_data_central, mz_uint user_extra_data_central_len);
-#endif
+// mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 size_to_add,
+//                                 const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
+//                                 const char *user_extra_data_central, mz_uint user_extra_data_central_len);
+// #endif
 
 /* Adds a file to an archive by fully cloning the data from another archive. */
 /* This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data (it may add or modify the zip64 local header extra data field), and the optional descriptor following the compressed data. */
@@ -1295,15 +1295,15 @@ mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name,
 /* Finalizes the archive by writing the central directory records followed by the end of central directory record. */
 /* After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end(). */
 /* An archive must be manually finalized by calling this function for it to be valid. */
-mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);
+// mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);
 
 /* Finalizes a heap archive, returning a poiner to the heap block and its size. */
 /* The heap block will be allocated using the mz_zip_archive's alloc/realloc callbacks. */
-mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize);
+// mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize);
 
 /* Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used. */
 /* Note for the archive to be valid, it *must* have been finalized before ending (this function will not do it for you). */
-mz_bool mz_zip_writer_end(mz_zip_archive *pZip);
+// mz_bool mz_zip_writer_end(mz_zip_archive *pZip);
 
 /* -------- Misc. high-level helper functions: */
 
@@ -1311,19 +1311,19 @@ mz_bool mz_zip_writer_end(mz_zip_archive *pZip);
 /* Note this is NOT a fully safe operation. If it crashes or dies in some way your archive can be left in a screwed up state (without a central directory). */
 /* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
 /* TODO: Perhaps add an option to leave the existing central dir in place in case the add dies? We could then truncate the file (so the old central dir would be at the end) if something goes wrong. */
-mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
-mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr);
+// mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
+// mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr);
 
 /* Reads a single file from an archive into a heap block. */
 /* If pComment is not NULL, only the file with the specified comment will be extracted. */
 /* Returns NULL on failure. */
-void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags);
-void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr);
+// void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags);
+// void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr);
 
-#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */
+// #endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */
 
-#ifdef __cplusplus
-}
-#endif
+// #ifdef __cplusplus
+// }
+// #endif
 
-#endif /* MINIZ_NO_ARCHIVE_APIS */
+// #endif /* MINIZ_NO_ARCHIVE_APIS */

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

diff --git a/src/zip/miniz/miniz.c b/src/zip/miniz/miniz.c
index 9ee7635..910d4b1 100644
--- a/src/zip/miniz/miniz.c
+++ b/src/zip/miniz/miniz.c
@@ -65,92 +65,92 @@ mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)
 }
 
 /* Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/ */
-#if 0
-    mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
-    {
-        static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
-                                               0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };
-        mz_uint32 crcu32 = (mz_uint32)crc;
-        if (!ptr)
-            return MZ_CRC32_INIT;
-        crcu32 = ~crcu32;
-        while (buf_len--)
-        {
-            mz_uint8 b = *ptr++;
-            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
-            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
-        }
-        return ~crcu32;
-    }
-#else
+// #if 0
+//     mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
+//     {
+//         static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
+//                                                0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };
+//         mz_uint32 crcu32 = (mz_uint32)crc;
+//         if (!ptr)
+//             return MZ_CRC32_INIT;
+//         crcu32 = ~crcu32;
+//         while (buf_len--)
+//         {
+//             mz_uint8 b = *ptr++;
+//             crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
+//             crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
+//         }
+//         return ~crcu32;
+//     }
+// #else
 /* Faster, but larger CPU cache footprint.
  */
-mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
-{
-    static const mz_uint32 s_crc_table[256] =
-        {
-          0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535,
-          0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD,
-          0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D,
-          0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
-          0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
-          0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
-          0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC,
-          0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
-          0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB,
-          0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
-          0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB,
-          0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
-          0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA,
-          0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE,
-          0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
-          0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
-          0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409,
-          0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
-          0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739,
-          0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
-          0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268,
-          0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0,
-          0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8,
-          0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
-          0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
-          0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703,
-          0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7,
-          0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
-          0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE,
-          0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
-          0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6,
-          0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
-          0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D,
-          0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5,
-          0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
-          0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
-          0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
-        };
-
-    mz_uint32 crc32 = (mz_uint32)crc ^ 0xFFFFFFFF;
-    const mz_uint8 *pByte_buf = (const mz_uint8 *)ptr;
-
-    while (buf_len >= 4)
-    {
-        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
-        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[1]) & 0xFF];
-        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[2]) & 0xFF];
-        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[3]) & 0xFF];
-        pByte_buf += 4;
-        buf_len -= 4;
-    }
+// mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
+// {
+//     static const mz_uint32 s_crc_table[256] =
+//         {
+//           0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535,
+//           0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD,
+//           0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D,
+//           0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
+//           0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
+//           0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
+//           0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC,
+//           0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
+//           0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB,
+//           0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
+//           0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB,
+//           0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
+//           0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA,
+//           0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE,
+//           0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
+//           0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
+//           0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409,
+//           0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
+//           0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739,
+//           0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
+//           0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268,
+//           0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0,
+//           0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8,
+//           0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
+//           0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
+//           0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703,
+//           0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7,
+//           0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
+//           0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE,
+//           0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
+//           0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6,
+//           0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
+//           0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D,
+//           0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5,
+//           0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
+//           0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
+//           0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
+//         };
+
+//     mz_uint32 crc32 = (mz_uint32)crc ^ 0xFFFFFFFF;
+//     const mz_uint8 *pByte_buf = (const mz_uint8 *)ptr;
+
+//     while (buf_len >= 4)
+//     {
+//         crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
+//         crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[1]) & 0xFF];
+//         crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[2]) & 0xFF];
+//         crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[3]) & 0xFF];
+//         pByte_buf += 4;
+//         buf_len -= 4;
+//     }
 
-    while (buf_len)
-    {
-        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
-        ++pByte_buf;
-        --buf_len;
-    }
+//     while (buf_len)
+//     {
+//         crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
+//         ++pByte_buf;
+//         --buf_len;
+//     }
 
-    return ~crc32;
-}
-#endif
+//     return ~crc32;
+// }
+// #endif
 
 void mz_free(void *p)
 {
@@ -167,16 +167,16 @@ void miniz_def_free_func(void *opaque, void *address)
     (void)opaque, (void)address;
     MZ_FREE(address);
 }
-void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size)
-{
-    (void)opaque, (void)address, (void)items, (void)size;
-    return MZ_REALLOC(address, items * size);
-}
+// void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size)
+// {
+//     (void)opaque, (void)address, (void)items, (void)size;
+//     return MZ_REALLOC(address, items * size);
+// }
 
-const char *mz_version(void)
-{
-    return MZ_VERSION;
-}
+// const char *mz_version(void)
+// {
+//     return MZ_VERSION;
+// }
 
 #ifndef MINIZ_NO_ZLIB_APIS
 
@@ -221,14 +221,14 @@ int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits,
     return MZ_OK;
 }
 
-int mz_deflateReset(mz_streamp pStream)
-{
-    if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree))
-        return MZ_STREAM_ERROR;
-    pStream->total_in = pStream->total_out = 0;
-    tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL, ((tdefl_compressor *)pStream->state)->m_flags);
-    return MZ_OK;
-}
+// int mz_deflateReset(mz_streamp pStream)
+// {
+//     if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree))
+//         return MZ_STREAM_ERROR;
+//     pStream->total_in = pStream->total_out = 0;
+//     tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL, ((tdefl_compressor *)pStream->state)->m_flags);
+//     return MZ_OK;
+// }
 
 int mz_deflate(mz_streamp pStream, int flush)
 {
@@ -300,12 +300,12 @@ int mz_deflateEnd(mz_streamp pStream)
     return MZ_OK;
 }
 
-mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)
-{
-    (void)pStream;
-    /* This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.) */
-    return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
-}
+// mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)
+// {
+//     (void)pStream;
+//      This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.) 
+//     return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
+// }
 
 int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)
 {
@@ -342,10 +342,10 @@ int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *
     return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
 }
 
-mz_ulong mz_compressBound(mz_ulong source_len)
-{
-    return mz_deflateBound(NULL, source_len);
-}
+// mz_ulong mz_compressBound(mz_ulong source_len)
+// {
+//     return mz_deflateBound(NULL, source_len);
+// }
 
 typedef struct
 {
@@ -551,22 +551,22 @@ int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char
     return mz_inflateEnd(&stream);
 }
 
-const char *mz_error(int err)
-{
-    static struct
-    {
-        int m_err;
-        const char *m_pDesc;
-    } s_error_descs[] =
-        {
-          { MZ_OK, "" }, { MZ_STREAM_END, "stream end" }, { MZ_NEED_DICT, "need dictionary" }, { MZ_ERRNO, "file error" }, { MZ_STREAM_ERROR, "stream error" }, { MZ_DATA_ERROR, "data error" }, { MZ_MEM_ERROR, "out of memory" }, { MZ_BUF_ERROR, "buf error" }, { MZ_VERSION_ERROR, "version error" }, { MZ_PARAM_ERROR, "parameter error" }
-        };
-    mz_uint i;
-    for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
-        if (s_error_descs[i].m_err == err)
-            return s_error_descs[i].m_pDesc;
-    return NULL;
-}
+// const char *mz_error(int err)
+// {
+//     static struct
+//     {
+//         int m_err;
+//         const char *m_pDesc;
+//     } s_error_descs[] =
+//         {
+//           { MZ_OK, "" }, { MZ_STREAM_END, "stream end" }, { MZ_NEED_DICT, "need dictionary" }, { MZ_ERRNO, "file error" }, { MZ_STREAM_ERROR, "stream error" }, { MZ_DATA_ERROR, "data error" }, { MZ_MEM_ERROR, "out of memory" }, { MZ_BUF_ERROR, "buf error" }, { MZ_VERSION_ERROR, "version error" }, { MZ_PARAM_ERROR, "parameter error" }
+//         };
+//     mz_uint i;
+//     for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
+//         if (s_error_descs[i].m_err == err)
+//             return s_error_descs[i].m_pDesc;
+//     return NULL;
+// }
 
 #endif /*MINIZ_NO_ZLIB_APIS */
 
@@ -1049,7 +1049,7 @@ static void tdefl_start_static_block(tdefl_compressor *d)
     TDEFL_PUT_BITS(1, 2);
 }
 
-static const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };
+static const mz_uint16 mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };
 
 #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
 static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
@@ -1358,7 +1358,6 @@ static inline mz_uint16 TDEFL_READ_UNALIGNED_WORD2(const mz_uint16* p)
 #endif
 static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
 {
-    printf("\n--------------------------------------------------- DEBUG ---------------------------------------\n");
     mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
     mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
     const mz_uint16 *s = (const mz_uint16 *)(d->m_dict + pos), *p, *q;
@@ -1456,176 +1455,176 @@ static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahe
 }
 #endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES */
 
-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-static mz_bool tdefl_compress_fast(tdefl_compressor *d)
-{
-    /* Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio. */
-    mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
-    mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
-    mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
+// #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
+// static mz_bool tdefl_compress_fast(tdefl_compressor *d)
+// {
+//     /* Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio. */
+//     mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
+//     mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
+//     mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
 
-    while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))
-    {
-        const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
-        mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
-        mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
-        d->m_src_buf_left -= num_bytes_to_process;
-        lookahead_size += num_bytes_to_process;
+//     while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))
+//     {
+//         const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
+//         mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
+//         mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
+//         d->m_src_buf_left -= num_bytes_to_process;
+//         lookahead_size += num_bytes_to_process;
 
-        while (num_bytes_to_process)
-        {
-            mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
-            memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
-            if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
-                memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
-            d->m_pSrc += n;
-            dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
-            num_bytes_to_process -= n;
-        }
+//         while (num_bytes_to_process)
+//         {
+//             mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
+//             memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
+//             if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
+//                 memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
+//             d->m_pSrc += n;
+//             dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
+//             num_bytes_to_process -= n;
+//         }
 
-        dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
-        if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))
-            break;
+//         dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
+//         if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))
+//             break;
 
-        while (lookahead_size >= 4)
-        {
-            mz_uint cur_match_dist, cur_match_len = 1;
-            mz_uint8 *pCur_dict = d->m_dict + cur_pos;
-            mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;
-            mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
-            mz_uint probe_pos = d->m_hash[hash];
-            d->m_hash[hash] = (mz_uint16)lookahead_pos;
-
-            if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((*(const mz_uint32 *)(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))
-            {
-                const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
-                const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
-                mz_uint32 probe_len = 32;
-                do
-                {
-                } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
-                         (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
-                cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
-                if (!probe_len)
-                    cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;
+//         while (lookahead_size >= 4)
+//         {
+//             mz_uint cur_match_dist, cur_match_len = 1;
+//             mz_uint8 *pCur_dict = d->m_dict + cur_pos;
+//             mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;
+//             mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
+//             mz_uint probe_pos = d->m_hash[hash];
+//             d->m_hash[hash] = (mz_uint16)lookahead_pos;
+
+//             if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((*(const mz_uint32 *)(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))
+//             {
+//                 const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
+//                 const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
+//                 mz_uint32 probe_len = 32;
+//                 do
+//                 {
+//                 } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
+//                          (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
+//                 cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
+//                 if (!probe_len)
+//                     cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;
 
-                if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)))
-                {
-                    cur_match_len = 1;
-                    *pLZ_code_buf++ = (mz_uint8)first_trigram;
-                    *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
-                    d->m_huff_count[0][(mz_uint8)first_trigram]++;
-                }
-                else
-                {
-                    mz_uint32 s0, s1;
-                    cur_match_len = MZ_MIN(cur_match_len, lookahead_size);
+//                 if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)))
+//                 {
+//                     cur_match_len = 1;
+//                     *pLZ_code_buf++ = (mz_uint8)first_trigram;
+//                     *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
+//                     d->m_huff_count[0][(mz_uint8)first_trigram]++;
+//                 }
+//                 else
+//                 {
+//                     mz_uint32 s0, s1;
+//                     cur_match_len = MZ_MIN(cur_match_len, lookahead_size);
 
-                    MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));
+//                     MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));
 
-                    cur_match_dist--;
+//                     cur_match_dist--;
 
-                    pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
-                    *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
-                    pLZ_code_buf += 3;
-                    *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);
+//                     pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
+//                     *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
+//                     pLZ_code_buf += 3;
+//                     *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);
 
-                    s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
-                    s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
-                    d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;
+//                     s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
+//                     s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
+//                     d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;
 
-                    d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
-                }
-            }
-            else
-            {
-                *pLZ_code_buf++ = (mz_uint8)first_trigram;
-                *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
-                d->m_huff_count[0][(mz_uint8)first_trigram]++;
-            }
+//                     d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
+//                 }
+//             }
+//             else
+//             {
+//                 *pLZ_code_buf++ = (mz_uint8)first_trigram;
+//                 *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
+//                 d->m_huff_count[0][(mz_uint8)first_trigram]++;
+//             }
 
-            if (--num_flags_left == 0)
-            {
-                num_flags_left = 8;
-                pLZ_flags = pLZ_code_buf++;
-            }
+//             if (--num_flags_left == 0)
+//             {
+//                 num_flags_left = 8;
+//                 pLZ_flags = pLZ_code_buf++;
+//             }
 
-            total_lz_bytes += cur_match_len;
-            lookahead_pos += cur_match_len;
-            dict_size = MZ_MIN(dict_size + cur_match_len, (mz_uint)TDEFL_LZ_DICT_SIZE);
-            cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
-            MZ_ASSERT(lookahead_size >= cur_match_len);
-            lookahead_size -= cur_match_len;
+//             total_lz_bytes += cur_match_len;
+//             lookahead_pos += cur_match_len;
+//             dict_size = MZ_MIN(dict_size + cur_match_len, (mz_uint)TDEFL_LZ_DICT_SIZE);
+//             cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
+//             MZ_ASSERT(lookahead_size >= cur_match_len);
+//             lookahead_size -= cur_match_len;
 
-            if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
-            {
-                int n;
-                d->m_lookahead_pos = lookahead_pos;
-                d->m_lookahead_size = lookahead_size;
-                d->m_dict_size = dict_size;
-                d->m_total_lz_bytes = total_lz_bytes;
-                d->m_pLZ_code_buf = pLZ_code_buf;
-                d->m_pLZ_flags = pLZ_flags;
-                d->m_num_flags_left = num_flags_left;
-                if ((n = tdefl_flush_block(d, 0)) != 0)
-                    return (n < 0) ? MZ_FALSE : MZ_TRUE;
-                total_lz_bytes = d->m_total_lz_bytes;
-                pLZ_code_buf = d->m_pLZ_code_buf;
-                pLZ_flags = d->m_pLZ_flags;
-                num_flags_left = d->m_num_flags_left;
-            }
-        }
+//             if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
+//             {
+//                 int n;
+//                 d->m_lookahead_pos = lookahead_pos;
+//                 d->m_lookahead_size = lookahead_size;
+//                 d->m_dict_size = dict_size;
+//                 d->m_total_lz_bytes = total_lz_bytes;
+//                 d->m_pLZ_code_buf = pLZ_code_buf;
+//                 d->m_pLZ_flags = pLZ_flags;
+//                 d->m_num_flags_left = num_flags_left;
+//                 if ((n = tdefl_flush_block(d, 0)) != 0)
+//                     return (n < 0) ? MZ_FALSE : MZ_TRUE;
+//                 total_lz_bytes = d->m_total_lz_bytes;
+//                 pLZ_code_buf = d->m_pLZ_code_buf;
+//                 pLZ_flags = d->m_pLZ_flags;
+//                 num_flags_left = d->m_num_flags_left;
+//             }
+//         }
 
-        while (lookahead_size)
-        {
-            mz_uint8 lit = d->m_dict[cur_pos];
+//         while (lookahead_size)
+//         {
+//             mz_uint8 lit = d->m_dict[cur_pos];
 
-            total_lz_bytes++;
-            *pLZ_code_buf++ = lit;
-            *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
-            if (--num_flags_left == 0)
-            {
-                num_flags_left = 8;
-                pLZ_flags = pLZ_code_buf++;
-            }
+//             total_lz_bytes++;
+//             *pLZ_code_buf++ = lit;
+//             *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
+//             if (--num_flags_left == 0)
+//             {
+//                 num_flags_left = 8;
+//                 pLZ_flags = pLZ_code_buf++;
+//             }
 
-            d->m_huff_count[0][lit]++;
+//             d->m_huff_count[0][lit]++;
 
-            lookahead_pos++;
-            dict_size = MZ_MIN(dict_size + 1, (mz_uint)TDEFL_LZ_DICT_SIZE);
-            cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
-            lookahead_size--;
+//             lookahead_pos++;
+//             dict_size = MZ_MIN(dict_size + 1, (mz_uint)TDEFL_LZ_DICT_SIZE);
+//             cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
+//             lookahead_size--;
 
-            if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
-            {
-                int n;
-                d->m_lookahead_pos = lookahead_pos;
-                d->m_lookahead_size = lookahead_size;
-                d->m_dict_size = dict_size;
-                d->m_total_lz_bytes = total_lz_bytes;
-                d->m_pLZ_code_buf = pLZ_code_buf;
-                d->m_pLZ_flags = pLZ_flags;
-                d->m_num_flags_left = num_flags_left;
-                if ((n = tdefl_flush_block(d, 0)) != 0)
-                    return (n < 0) ? MZ_FALSE : MZ_TRUE;
-                total_lz_bytes = d->m_total_lz_bytes;
-                pLZ_code_buf = d->m_pLZ_code_buf;
-                pLZ_flags = d->m_pLZ_flags;
-                num_flags_left = d->m_num_flags_left;
-            }
-        }
-    }
+//             if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
+//             {
+//                 int n;
+//                 d->m_lookahead_pos = lookahead_pos;
+//                 d->m_lookahead_size = lookahead_size;
+//                 d->m_dict_size = dict_size;
+//                 d->m_total_lz_bytes = total_lz_bytes;
+//                 d->m_pLZ_code_buf = pLZ_code_buf;
+//                 d->m_pLZ_flags = pLZ_flags;
+//                 d->m_num_flags_left = num_flags_left;
+//                 if ((n = tdefl_flush_block(d, 0)) != 0)
+//                     return (n < 0) ? MZ_FALSE : MZ_TRUE;
+//                 total_lz_bytes = d->m_total_lz_bytes;
+//                 pLZ_code_buf = d->m_pLZ_code_buf;
+//                 pLZ_flags = d->m_pLZ_flags;
+//                 num_flags_left = d->m_num_flags_left;
+//             }
+//         }
+//     }
 
-    d->m_lookahead_pos = lookahead_pos;
-    d->m_lookahead_size = lookahead_size;
-    d->m_dict_size = dict_size;
-    d->m_total_lz_bytes = total_lz_bytes;
-    d->m_pLZ_code_buf = pLZ_code_buf;
-    d->m_pLZ_flags = pLZ_flags;
-    d->m_num_flags_left = num_flags_left;
-    return MZ_TRUE;
-}
-#endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */
+//     d->m_lookahead_pos = lookahead_pos;
+//     d->m_lookahead_size = lookahead_size;
+//     d->m_dict_size = dict_size;
+//     d->m_total_lz_bytes = total_lz_bytes;
+//     d->m_pLZ_code_buf = pLZ_code_buf;
+//     d->m_pLZ_flags = pLZ_flags;
+//     d->m_num_flags_left = num_flags_left;
+//     return MZ_TRUE;
+// }
+// #endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */
 
 static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)
 {
@@ -1870,16 +1869,16 @@ tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pI
     if ((d->m_output_flush_remaining) || (d->m_finished))
         return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
 
-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-    if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
-        ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
-        ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))
-    {
-        if (!tdefl_compress_fast(d))
-            return d->m_prev_return_status;
-    }
-    else
-#endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */
+// #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
+//     if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
+//         ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
+//         ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))
+//     {
+//         if (!tdefl_compress_fast(d))
+//             return d->m_prev_return_status;
+//     }
+//     else
+// #endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */
     {
         if (!tdefl_compress_normal(d))
             return d->m_prev_return_status;
@@ -1904,11 +1903,11 @@ tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pI
     return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
 }
 
-tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)
-{
-    MZ_ASSERT(d->m_pPut_buf_func);
-    return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
-}
+// tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)
+// {
+//     MZ_ASSERT(d->m_pPut_buf_func);
+//     return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
+// }
 
 tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
 {
@@ -1944,92 +1943,92 @@ tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_fun
     return TDEFL_STATUS_OKAY;
 }
 
-tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)
-{
-    return d->m_prev_return_status;
-}
+// tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)
+// {
+//     return d->m_prev_return_status;
+// }
 
 mz_uint32 tdefl_get_adler32(tdefl_compressor *d)
 {
     return d->m_adler32;
 }
 
-mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
-{
-    tdefl_compressor *pComp;
-    mz_bool succeeded;
-    if (((buf_len) && (!pBuf)) || (!pPut_buf_func))
-        return MZ_FALSE;
-    pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
-    if (!pComp)
-        return MZ_FALSE;
-    succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
-    succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
-    MZ_FREE(pComp);
-    return succeeded;
-}
+// mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
+// {
+//     tdefl_compressor *pComp;
+//     mz_bool succeeded;
+//     if (((buf_len) && (!pBuf)) || (!pPut_buf_func))
+//         return MZ_FALSE;
+//     pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
+//     if (!pComp)
+//         return MZ_FALSE;
+//     succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
+//     succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
+//     MZ_FREE(pComp);
+//     return succeeded;
+// }
 
-typedef struct
-{
-    size_t m_size, m_capacity;
-    mz_uint8 *m_pBuf;
-    mz_bool m_expandable;
-} tdefl_output_buffer;
+// typedef struct
+// {
+//     size_t m_size, m_capacity;
+//     mz_uint8 *m_pBuf;
+//     mz_bool m_expandable;
+// } tdefl_output_buffer;
 
-static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)
-{
-    tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
-    size_t new_size = p->m_size + len;
-    if (new_size > p->m_capacity)
-    {
-        size_t new_capacity = p->m_capacity;
-        mz_uint8 *pNew_buf;
-        if (!p->m_expandable)
-            return MZ_FALSE;
-        do
-        {
-            new_capacity = MZ_MAX(128U, new_capacity << 1U);
-        } while (new_size > new_capacity);
-        pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);
-        if (!pNew_buf)
-            return MZ_FALSE;
-        p->m_pBuf = pNew_buf;
-        p->m_capacity = new_capacity;
-    }
-    memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);
-    p->m_size = new_size;
-    return MZ_TRUE;
-}
+// static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)
+// {
+//     tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
+//     size_t new_size = p->m_size + len;
+//     if (new_size > p->m_capacity)
+//     {
+//         size_t new_capacity = p->m_capacity;
+//         mz_uint8 *pNew_buf;
+//         if (!p->m_expandable)
+//             return MZ_FALSE;
+//         do
+//         {
+//             new_capacity = MZ_MAX(128U, new_capacity << 1U);
+//         } while (new_size > new_capacity);
+//         pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);
+//         if (!pNew_buf)
+//             return MZ_FALSE;
+//         p->m_pBuf = pNew_buf;
+//         p->m_capacity = new_capacity;
+//     }
+//     memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);
+//     p->m_size = new_size;
+//     return MZ_TRUE;
+// }
 
-void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
-{
-    tdefl_output_buffer out_buf;
-    MZ_CLEAR_OBJ(out_buf);
-    if (!pOut_len)
-        return MZ_FALSE;
-    else
-        *pOut_len = 0;
-    out_buf.m_expandable = MZ_TRUE;
-    if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
-        return NULL;
-    *pOut_len = out_buf.m_size;
-    return out_buf.m_pBuf;
-}
+// void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
+// {
+//     tdefl_output_buffer out_buf;
+//     MZ_CLEAR_OBJ(out_buf);
+//     if (!pOut_len)
+//         return MZ_FALSE;
+//     else
+//         *pOut_len = 0;
+//     out_buf.m_expandable = MZ_TRUE;
+//     if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
+//         return NULL;
+//     *pOut_len = out_buf.m_size;
+//     return out_buf.m_pBuf;
+// }
 
-size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
-{
-    tdefl_output_buffer out_buf;
-    MZ_CLEAR_OBJ(out_buf);
-    if (!pOut_buf)
-        return 0;
-    out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
-    out_buf.m_capacity = out_buf_len;
-    if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
-        return 0;
-    return out_buf.m_size;
-}
+// size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
+// {
+//     tdefl_output_buffer out_buf;
+//     MZ_CLEAR_OBJ(out_buf);
+//     if (!pOut_buf)
+//         return 0;
+//     out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
+//     out_buf.m_capacity = out_buf_len;
+//     if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
+//         return 0;
+//     return out_buf.m_size;
+// }
 
-static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
+static const mz_uint16 s_tdefl_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
 
 /* level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files). */
 mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)
@@ -2060,102 +2059,102 @@ mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int
 /* Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
  http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
  This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck. */
-void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
-{
-    /* Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined. */
-    static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
-    tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
-    tdefl_output_buffer out_buf;
-    int i, bpl = w * num_chans, y, z;
-    mz_uint32 c;
-    *pLen_out = 0;
-    if (!pComp)
-        return NULL;
-    MZ_CLEAR_OBJ(out_buf);
-    out_buf.m_expandable = MZ_TRUE;
-    out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
-    if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity)))
-    {
-        MZ_FREE(pComp);
-        return NULL;
-    }
-    /* write dummy header */
-    for (z = 41; z; --z)
-        tdefl_output_buffer_putter(&z, 1, &out_buf);
-    /* compress image data */
-    tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
-    for (y = 0; y < h; ++y)
-    {
-        tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
-        tdefl_compress_buffer(pComp, (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);
-    }
-    if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE)
-    {
-        MZ_FREE(pComp);
-        MZ_FREE(out_buf.m_pBuf);
-        return NULL;
-    }
-    /* write real header */
-    *pLen_out = out_buf.m_size - 41;
-    {
-        static const mz_uint8 chans[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };
-        mz_uint8 pnghdr[41] = { 0x89, 0x50, 0x4e, 0x47, 0x0d,
-                                0x0a, 0x1a, 0x0a, 0x00, 0x00,
-                                0x00, 0x0d, 0x49, 0x48, 0x44,
-                                0x52, 0x00, 0x00, 0x00, 0x00,
-                                0x00, 0x00, 0x00, 0x00, 0x08,
-                                0x00, 0x00, 0x00, 0x00, 0x00,
-                                0x00, 0x00, 0x00, 0x00, 0x00,
-                                0x00, 0x00, 0x49, 0x44, 0x41,
-                                0x54 };
-        pnghdr[18] = (mz_uint8)(w >> 8);
-        pnghdr[19] = (mz_uint8)w;
-        pnghdr[22] = (mz_uint8)(h >> 8);
-        pnghdr[23] = (mz_uint8)h;
-        pnghdr[25] = chans[num_chans];
-        pnghdr[33] = (mz_uint8)(*pLen_out >> 24);
-        pnghdr[34] = (mz_uint8)(*pLen_out >> 16);
-        pnghdr[35] = (mz_uint8)(*pLen_out >> 8);
-        pnghdr[36] = (mz_uint8)*pLen_out;
-        c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
-        for (i = 0; i < 4; ++i, c <<= 8)
-            ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
-        memcpy(out_buf.m_pBuf, pnghdr, 41);
-    }
-    /* write footer (IDAT CRC-32, followed by IEND chunk) */
-    if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf))
-    {
-        *pLen_out = 0;
-        MZ_FREE(pComp);
-        MZ_FREE(out_buf.m_pBuf);
-        return NULL;
-    }
-    c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);
-    for (i = 0; i < 4; ++i, c <<= 8)
-        (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
-    /* compute final size of file, grab compressed data buffer and return */
-    *pLen_out += 57;
-    MZ_FREE(pComp);
-    return out_buf.m_pBuf;
-}
-void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)
-{
+// void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
+// {
+//     /* Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined. */
+//     static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
+//     tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
+//     tdefl_output_buffer out_buf;
+//     int i, bpl = w * num_chans, y, z;
+//     mz_uint32 c;
+//     *pLen_out = 0;
+//     if (!pComp)
+//         return NULL;
+//     MZ_CLEAR_OBJ(out_buf);
+//     out_buf.m_expandable = MZ_TRUE;
+//     out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
+//     if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity)))
+//     {
+//         MZ_FREE(pComp);
+//         return NULL;
+//     }
+//     /* write dummy header */
+//     for (z = 41; z; --z)
+//         tdefl_output_buffer_putter(&z, 1, &out_buf);
+//     /* compress image data */
+//     tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
+//     for (y = 0; y < h; ++y)
+//     {
+//         tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
+//         tdefl_compress_buffer(pComp, (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);
+//     }
+//     if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE)
+//     {
+//         MZ_FREE(pComp);
+//         MZ_FREE(out_buf.m_pBuf);
+//         return NULL;
+//     }
+//     /* write real header */
+//     *pLen_out = out_buf.m_size - 41;
+//     {
+//         static const mz_uint8 chans[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };
+//         mz_uint8 pnghdr[41] = { 0x89, 0x50, 0x4e, 0x47, 0x0d,
+//                                 0x0a, 0x1a, 0x0a, 0x00, 0x00,
+//                                 0x00, 0x0d, 0x49, 0x48, 0x44,
+//                                 0x52, 0x00, 0x00, 0x00, 0x00,
+//                                 0x00, 0x00, 0x00, 0x00, 0x08,
+//                                 0x00, 0x00, 0x00, 0x00, 0x00,
+//                                 0x00, 0x00, 0x00, 0x00, 0x00,
+//                                 0x00, 0x00, 0x49, 0x44, 0x41,
+//                                 0x54 };
+//         pnghdr[18] = (mz_uint8)(w >> 8);
+//         pnghdr[19] = (mz_uint8)w;
+//         pnghdr[22] = (mz_uint8)(h >> 8);
+//         pnghdr[23] = (mz_uint8)h;
+//         pnghdr[25] = chans[num_chans];
+//         pnghdr[33] = (mz_uint8)(*pLen_out >> 24);
+//         pnghdr[34] = (mz_uint8)(*pLen_out >> 16);
+//         pnghdr[35] = (mz_uint8)(*pLen_out >> 8);
+//         pnghdr[36] = (mz_uint8)*pLen_out;
+//         c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
+//         for (i = 0; i < 4; ++i, c <<= 8)
+//             ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
+//         memcpy(out_buf.m_pBuf, pnghdr, 41);
+//     }
+//     /* write footer (IDAT CRC-32, followed by IEND chunk) */
+//     if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf))
+//     {
+//         *pLen_out = 0;
+//         MZ_FREE(pComp);
+//         MZ_FREE(out_buf.m_pBuf);
+//         return NULL;
+//     }
+//     c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);
+//     for (i = 0; i < 4; ++i, c <<= 8)
+//         (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
+//     /* compute final size of file, grab compressed data buffer and return */
+//     *pLen_out += 57;
+//     MZ_FREE(pComp);
+//     return out_buf.m_pBuf;
+// }
+// void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)
+// {
     /* Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out) */
-    return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
-}
+//     return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
+// }
 
 /* Allocate the tdefl_compressor and tinfl_decompressor structures in C so that */
 /* non-C language bindings to tdefL_ and tinfl_ API don't need to worry about */
 /* structure size and allocation mechanism. */
-tdefl_compressor *tdefl_compressor_alloc()
-{
-    return (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
-}
+// tdefl_compressor *tdefl_compressor_alloc()
+// {
+//     return (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
+// }
 
-void tdefl_compressor_free(tdefl_compressor *pComp)
-{
-    MZ_FREE(pComp);
-}
+// void tdefl_compressor_free(tdefl_compressor *pComp)
+// {
+//     MZ_FREE(pComp);
+// }
 
 #ifdef _MSC_VER
 #pragma warning(pop)
@@ -2339,12 +2338,12 @@ extern "C" {
 
 tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)
 {
-    static const int s_length_base[31] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 };
-    static const int s_length_extra[31] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 };
-    static const int s_dist_base[32] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 };
-    static const int s_dist_extra[32] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 };
+    static const mz_uint16 s_length_base[31] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 };
+    static const mz_uint8 s_length_extra[31] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 };
+    static const mz_uint16 s_dist_base[32] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 };
+    static const mz_uint8 s_dist_extra[32] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 };
     static const mz_uint8 s_length_dezigzag[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
-    static const int s_min_table_sizes[3] = { 257, 1, 4 };
+    static const mz_uint16 s_min_table_sizes[3] = { 257, 1, 4 };
 
     tinfl_status status = TINFL_STATUS_FAILED;
     mz_uint32 num_bits, dist, counter, num_extra;
@@ -2805,94 +2804,94 @@ common_exit:
 }
 
 /* Higher level helper functions. */
-void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
-{
-    tinfl_decompressor decomp;
-    void *pBuf = NULL, *pNew_buf;
-    size_t src_buf_ofs = 0, out_buf_capacity = 0;
-    *pOut_len = 0;
-    tinfl_init(&decomp);
-    for (;;)
-    {
-        size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
-        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size,
-                                               (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
-        if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))
-        {
-            MZ_FREE(pBuf);
-            *pOut_len = 0;
-            return NULL;
-        }
-        src_buf_ofs += src_buf_size;
-        *pOut_len += dst_buf_size;
-        if (status == TINFL_STATUS_DONE)
-            break;
-        new_out_buf_capacity = out_buf_capacity * 2;
-        if (new_out_buf_capacity < 128)
-            new_out_buf_capacity = 128;
-        pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
-        if (!pNew_buf)
-        {
-            MZ_FREE(pBuf);
-            *pOut_len = 0;
-            return NULL;
-        }
-        pBuf = pNew_buf;
-        out_buf_capacity = new_out_buf_capacity;
-    }
-    return pBuf;
-}
+// void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
+// {
+//     tinfl_decompressor decomp;
+//     void *pBuf = NULL, *pNew_buf;
+//     size_t src_buf_ofs = 0, out_buf_capacity = 0;
+//     *pOut_len = 0;
+//     tinfl_init(&decomp);
+//     for (;;)
+//     {
+//         size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
+//         tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size,
+//                                                (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
+//         if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))
+//         {
+//             MZ_FREE(pBuf);
+//             *pOut_len = 0;
+//             return NULL;
+//         }
+//         src_buf_ofs += src_buf_size;
+//         *pOut_len += dst_buf_size;
+//         if (status == TINFL_STATUS_DONE)
+//             break;
+//         new_out_buf_capacity = out_buf_capacity * 2;
+//         if (new_out_buf_capacity < 128)
+//             new_out_buf_capacity = 128;
+//         pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
+//         if (!pNew_buf)
+//         {
+//             MZ_FREE(pBuf);
+//             *pOut_len = 0;
+//             return NULL;
+//         }
+//         pBuf = pNew_buf;
+//         out_buf_capacity = new_out_buf_capacity;
+//     }
+//     return pBuf;
+// }
 
-size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
-{
-    tinfl_decompressor decomp;
-    tinfl_status status;
-    tinfl_init(&decomp);
-    status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len, (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
-    return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
-}
+// size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
+// {
+//     tinfl_decompressor decomp;
+//     tinfl_status status;
+//     tinfl_init(&decomp);
+//     status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len, (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
+//     return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
+// }
 
-int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
-{
-    int result = 0;
-    tinfl_decompressor decomp;
-    mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
-    size_t in_buf_ofs = 0, dict_ofs = 0;
-    if (!pDict)
-        return TINFL_STATUS_FAILED;
-    tinfl_init(&decomp);
-    for (;;)
-    {
-        size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
-        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
-                                               (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
-        in_buf_ofs += in_buf_size;
-        if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
-            break;
-        if (status != TINFL_STATUS_HAS_MORE_OUTPUT)
-        {
-            result = (status == TINFL_STATUS_DONE);
-            break;
-        }
-        dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
-    }
-    MZ_FREE(pDict);
-    *pIn_buf_size = in_buf_ofs;
-    return result;
-}
+// int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
+// {
+//     int result = 0;
+//     tinfl_decompressor decomp;
+//     mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
+//     size_t in_buf_ofs = 0, dict_ofs = 0;
+//     if (!pDict)
+//         return TINFL_STATUS_FAILED;
+//     tinfl_init(&decomp);
+//     for (;;)
+//     {
+//         size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
+//         tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
+//                                                (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
+//         in_buf_ofs += in_buf_size;
+//         if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
+//             break;
+//         if (status != TINFL_STATUS_HAS_MORE_OUTPUT)
+//         {
+//             result = (status == TINFL_STATUS_DONE);
+//             break;
+//         }
+//         dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
+//     }
+//     MZ_FREE(pDict);
+//     *pIn_buf_size = in_buf_ofs;
+//     return result;
+// }
 
-tinfl_decompressor *tinfl_decompressor_alloc()
-{
-    tinfl_decompressor *pDecomp = (tinfl_decompressor *)MZ_MALLOC(sizeof(tinfl_decompressor));
-    if (pDecomp)
-        tinfl_init(pDecomp);
-    return pDecomp;
-}
+// tinfl_decompressor *tinfl_decompressor_alloc()
+// {
+//     tinfl_decompressor *pDecomp = (tinfl_decompressor *)MZ_MALLOC(sizeof(tinfl_decompressor));
+//     if (pDecomp)
+//         tinfl_init(pDecomp);
+//     return pDecomp;
+// }
 
-void tinfl_decompressor_free(tinfl_decompressor *pDecomp)
-{
-    MZ_FREE(pDecomp);
-}
+// void tinfl_decompressor_free(tinfl_decompressor *pDecomp)
+// {
+//     MZ_FREE(pDecomp);
+// }
 
 #ifdef __cplusplus
 }
@@ -2925,461 +2924,461 @@ void tinfl_decompressor_free(tinfl_decompressor *pDecomp)
  **************************************************************************/
 
 
-#ifndef MINIZ_NO_ARCHIVE_APIS
+// #ifndef MINIZ_NO_ARCHIVE_APIS
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+// #ifdef __cplusplus
+// extern "C" {
+// #endif
 
 /* ------------------- .ZIP archive reading */
 
-#ifdef MINIZ_NO_STDIO
-#define MZ_FILE void *
-#else
-#include <sys/stat.h>
+// #ifdef MINIZ_NO_STDIO
+// #define MZ_FILE void *
+// #else
+// #include <sys/stat.h>
 
-#if defined(_MSC_VER) || defined(__MINGW64__)
-static FILE *mz_fopen(const char *pFilename, const char *pMode)
-{
-    FILE *pFile = NULL;
-    fopen_s(&pFile, pFilename, pMode);
-    return pFile;
-}
-static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
-{
-    FILE *pFile = NULL;
-    if (freopen_s(&pFile, pPath, pMode, pStream))
-        return NULL;
-    return pFile;
-}
-#ifndef MINIZ_NO_TIME
-#include <sys/utime.h>
-#endif
-#define MZ_FOPEN mz_fopen
-#define MZ_FCLOSE fclose
-#define MZ_FREAD fread
-#define MZ_FWRITE fwrite
-#define MZ_FTELL64 _ftelli64
-#define MZ_FSEEK64 _fseeki64
-#define MZ_FILE_STAT_STRUCT _stat
-#define MZ_FILE_STAT _stat
-#define MZ_FFLUSH fflush
-#define MZ_FREOPEN mz_freopen
-#define MZ_DELETE_FILE remove
-#elif defined(__MINGW32__)
-#ifndef MINIZ_NO_TIME
-#include <sys/utime.h>
-#endif
-#define MZ_FOPEN(f, m) fopen(f, m)
-#define MZ_FCLOSE fclose
-#define MZ_FREAD fread
-#define MZ_FWRITE fwrite
-#define MZ_FTELL64 ftello64
-#define MZ_FSEEK64 fseeko64
-#define MZ_FILE_STAT_STRUCT _stat
-#define MZ_FILE_STAT _stat
-#define MZ_FFLUSH fflush
-#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
-#define MZ_DELETE_FILE remove
-#elif defined(__TINYC__)
-#ifndef MINIZ_NO_TIME
-#include <sys/utime.h>
-#endif
-#define MZ_FOPEN(f, m) fopen(f, m)
-#define MZ_FCLOSE fclose
-#define MZ_FREAD fread
-#define MZ_FWRITE fwrite
-#define MZ_FTELL64 ftell
-#define MZ_FSEEK64 fseek
-#define MZ_FILE_STAT_STRUCT stat
-#define MZ_FILE_STAT stat
-#define MZ_FFLUSH fflush
-#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
-#define MZ_DELETE_FILE remove
-#elif defined(__GNUC__) && _LARGEFILE64_SOURCE
-#ifndef MINIZ_NO_TIME
-#include <utime.h>
-#endif
-#define MZ_FOPEN(f, m) fopen64(f, m)
-#define MZ_FCLOSE fclose
-#define MZ_FREAD fread
-#define MZ_FWRITE fwrite
-#define MZ_FTELL64 ftello64
-#define MZ_FSEEK64 fseeko64
-#define MZ_FILE_STAT_STRUCT stat64
-#define MZ_FILE_STAT stat64
-#define MZ_FFLUSH fflush
-#define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
-#define MZ_DELETE_FILE remove
-#elif defined(__APPLE__) && _LARGEFILE64_SOURCE
-#ifndef MINIZ_NO_TIME
-#include <utime.h>
-#endif
-#define MZ_FOPEN(f, m) fopen(f, m)
-#define MZ_FCLOSE fclose
-#define MZ_FREAD fread
-#define MZ_FWRITE fwrite
-#define MZ_FTELL64 ftello
-#define MZ_FSEEK64 fseeko
-#define MZ_FILE_STAT_STRUCT stat
-#define MZ_FILE_STAT stat
-#define MZ_FFLUSH fflush
-#define MZ_FREOPEN(p, m, s) freopen(p, m, s)
-#define MZ_DELETE_FILE remove
+// #if defined(_MSC_VER) || defined(__MINGW64__)
+// static FILE *mz_fopen(const char *pFilename, const char *pMode)
+// {
+//     FILE *pFile = NULL;
+//     fopen_s(&pFile, pFilename, pMode);
+//     return pFile;
+// }
+// static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
+// {
+//     FILE *pFile = NULL;
+//     if (freopen_s(&pFile, pPath, pMode, pStream))
+//         return NULL;
+//     return pFile;
+// }
+// #ifndef MINIZ_NO_TIME
+// #include <sys/utime.h>
+// #endif
+// #define MZ_FOPEN mz_fopen
+// #define MZ_FCLOSE fclose
+// #define MZ_FREAD fread
+// #define MZ_FWRITE fwrite
+// #define MZ_FTELL64 _ftelli64
+// #define MZ_FSEEK64 _fseeki64
+// #define MZ_FILE_STAT_STRUCT _stat
+// #define MZ_FILE_STAT _stat
+// #define MZ_FFLUSH fflush
+// #define MZ_FREOPEN mz_freopen
+// #define MZ_DELETE_FILE remove
+// #elif defined(__MINGW32__)
+// #ifndef MINIZ_NO_TIME
+// #include <sys/utime.h>
+// #endif
+// #define MZ_FOPEN(f, m) fopen(f, m)
+// #define MZ_FCLOSE fclose
+// #define MZ_FREAD fread
+// #define MZ_FWRITE fwrite
+// #define MZ_FTELL64 ftello64
+// #define MZ_FSEEK64 fseeko64
+// #define MZ_FILE_STAT_STRUCT _stat
+// #define MZ_FILE_STAT _stat
+// #define MZ_FFLUSH fflush
+// #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
+// #define MZ_DELETE_FILE remove
+// #elif defined(__TINYC__)
+// #ifndef MINIZ_NO_TIME
+// #include <sys/utime.h>
+// #endif
+// #define MZ_FOPEN(f, m) fopen(f, m)
+// #define MZ_FCLOSE fclose
+// #define MZ_FREAD fread
+// #define MZ_FWRITE fwrite
+// #define MZ_FTELL64 ftell
+// #define MZ_FSEEK64 fseek
+// #define MZ_FILE_STAT_STRUCT stat
+// #define MZ_FILE_STAT stat
+// #define MZ_FFLUSH fflush
+// #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
+// #define MZ_DELETE_FILE remove
+// #elif defined(__GNUC__) && _LARGEFILE64_SOURCE
+// #ifndef MINIZ_NO_TIME
+// #include <utime.h>
+// #endif
+// #define MZ_FOPEN(f, m) fopen64(f, m)
+// #define MZ_FCLOSE fclose
+// #define MZ_FREAD fread
+// #define MZ_FWRITE fwrite
+// #define MZ_FTELL64 ftello64
+// #define MZ_FSEEK64 fseeko64
+// #define MZ_FILE_STAT_STRUCT stat64
+// #define MZ_FILE_STAT stat64
+// #define MZ_FFLUSH fflush
+// #define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
+// #define MZ_DELETE_FILE remove
+// #elif defined(__APPLE__) && _LARGEFILE64_SOURCE
+// #ifndef MINIZ_NO_TIME
+// #include <utime.h>
+// #endif
+// #define MZ_FOPEN(f, m) fopen(f, m)
+// #define MZ_FCLOSE fclose
+// #define MZ_FREAD fread
+// #define MZ_FWRITE fwrite
+// #define MZ_FTELL64 ftello
+// #define MZ_FSEEK64 fseeko
+// #define MZ_FILE_STAT_STRUCT stat
+// #define MZ_FILE_STAT stat
+// #define MZ_FFLUSH fflush
+// #define MZ_FREOPEN(p, m, s) freopen(p, m, s)
+// #define MZ_DELETE_FILE remove
+
+// #else
+// // #pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
+// #ifndef MINIZ_NO_TIME
+// #include <utime.h>
+// #endif
+// #define MZ_FOPEN(f, m) fopen(f, m)
+// #define MZ_FCLOSE fclose
+// #define MZ_FREAD fread
+// #define MZ_FWRITE fwrite
+// #ifdef __STRICT_ANSI__
+// #define MZ_FTELL64 ftell
+// #define MZ_FSEEK64 fseek
+// #else
+// #define MZ_FTELL64 ftello
+// #define MZ_FSEEK64 fseeko
+// #endif
+// #define MZ_FILE_STAT_STRUCT stat
+// #define MZ_FILE_STAT stat
+// #define MZ_FFLUSH fflush
+// #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
+// #define MZ_DELETE_FILE remove
+// #endif /* #ifdef _MSC_VER */
+// #endif /* #ifdef MINIZ_NO_STDIO */
+
+// #define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))
 
-#else
-// #pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
-#ifndef MINIZ_NO_TIME
-#include <utime.h>
-#endif
-#define MZ_FOPEN(f, m) fopen(f, m)
-#define MZ_FCLOSE fclose
-#define MZ_FREAD fread
-#define MZ_FWRITE fwrite
-#ifdef __STRICT_ANSI__
-#define MZ_FTELL64 ftell
-#define MZ_FSEEK64 fseek
-#else
-#define MZ_FTELL64 ftello
-#define MZ_FSEEK64 fseeko
-#endif
-#define MZ_FILE_STAT_STRUCT stat
-#define MZ_FILE_STAT stat
-#define MZ_FFLUSH fflush
-#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
-#define MZ_DELETE_FILE remove
-#endif /* #ifdef _MSC_VER */
-#endif /* #ifdef MINIZ_NO_STDIO */
+/* Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff. */
+// enum
+// {
+//     /* ZIP archive identifiers and record sizes */
+//     MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
+//     MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
+//     MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
+//     MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
+//     MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
+//     MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
+
+//     /* ZIP64 archive identifier and record sizes */
+//     MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06064b50,
+//     MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG = 0x07064b50,
+//     MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE = 56,
+//     MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE = 20,
+//     MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID = 0x0001,
+//     MZ_ZIP_DATA_DESCRIPTOR_ID = 0x08074b50,
+//     MZ_ZIP_DATA_DESCRIPTER_SIZE64 = 24,
+//     MZ_ZIP_DATA_DESCRIPTER_SIZE32 = 16,
+
+//     /* Central directory header record offsets */
+//     MZ_ZIP_CDH_SIG_OFS = 0,
+//     MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
+//     MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
+//     MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
+//     MZ_ZIP_CDH_METHOD_OFS = 10,
+//     MZ_ZIP_CDH_FILE_TIME_OFS = 12,
+//     MZ_ZIP_CDH_FILE_DATE_OFS = 14,
+//     MZ_ZIP_CDH_CRC32_OFS = 16,
+//     MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
+//     MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
+//     MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
+//     MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
+//     MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
+//     MZ_ZIP_CDH_DISK_START_OFS = 34,
+//     MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
+//     MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
+//     MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
+
+//     /* Local directory header offsets */
+//     MZ_ZIP_LDH_SIG_OFS = 0,
+//     MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
+//     MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
+//     MZ_ZIP_LDH_METHOD_OFS = 8,
+//     MZ_ZIP_LDH_FILE_TIME_OFS = 10,
+//     MZ_ZIP_LDH_FILE_DATE_OFS = 12,
+//     MZ_ZIP_LDH_CRC32_OFS = 14,
+//     MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
+//     MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
+//     MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
+//     MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
+//     MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR = 1 << 3,
+
+//     /* End of central directory offsets */
+//     MZ_ZIP_ECDH_SIG_OFS = 0,
+//     MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
+//     MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
+//     MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
+//     MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
+//     MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
+//     MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
+//     MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
+
+//     /* ZIP64 End of central directory locator offsets */
+//     MZ_ZIP64_ECDL_SIG_OFS = 0,                    /* 4 bytes */
+//     MZ_ZIP64_ECDL_NUM_DISK_CDIR_OFS = 4,          /* 4 bytes */
+//     MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS = 8,  /* 8 bytes */
+//     MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS = 16, /* 4 bytes */
+
+//     /* ZIP64 End of central directory header offsets */
+//     MZ_ZIP64_ECDH_SIG_OFS = 0,                       /* 4 bytes */
+//     MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS = 4,            /* 8 bytes */
+//     MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS = 12,          /* 2 bytes */
+//     MZ_ZIP64_ECDH_VERSION_NEEDED_OFS = 14,           /* 2 bytes */
+//     MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS = 16,            /* 4 bytes */
+//     MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS = 20,            /* 4 bytes */
+//     MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 24, /* 8 bytes */
+//     MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS = 32,       /* 8 bytes */
+//     MZ_ZIP64_ECDH_CDIR_SIZE_OFS = 40,                /* 8 bytes */
+//     MZ_ZIP64_ECDH_CDIR_OFS_OFS = 48,                 /* 8 bytes */
+//     MZ_ZIP_VERSION_MADE_BY_DOS_FILESYSTEM_ID = 0,
+//     MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG = 0x10,
+//     MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED = 1,
+//     MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG = 32,
+//     MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION = 64,
+//     MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED = 8192,
+//     MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8 = 1 << 11
+// };
+
+// typedef struct
+// {
+//     void *m_p;
+//     size_t m_size, m_capacity;
+//     mz_uint m_element_size;
+// } mz_zip_array;
 
-#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))
+// struct mz_zip_internal_state_tag
+// {
+//     mz_zip_array m_central_dir;
+//     mz_zip_array m_central_dir_offsets;
+//     mz_zip_array m_sorted_central_dir_offsets;
 
-/* Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff. */
-enum
-{
-    /* ZIP archive identifiers and record sizes */
-    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
-    MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
-    MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
-    MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
-    MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
-    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
-
-    /* ZIP64 archive identifier and record sizes */
-    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06064b50,
-    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG = 0x07064b50,
-    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE = 56,
-    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE = 20,
-    MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID = 0x0001,
-    MZ_ZIP_DATA_DESCRIPTOR_ID = 0x08074b50,
-    MZ_ZIP_DATA_DESCRIPTER_SIZE64 = 24,
-    MZ_ZIP_DATA_DESCRIPTER_SIZE32 = 16,
-
-    /* Central directory header record offsets */
-    MZ_ZIP_CDH_SIG_OFS = 0,
-    MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
-    MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
-    MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
-    MZ_ZIP_CDH_METHOD_OFS = 10,
-    MZ_ZIP_CDH_FILE_TIME_OFS = 12,
-    MZ_ZIP_CDH_FILE_DATE_OFS = 14,
-    MZ_ZIP_CDH_CRC32_OFS = 16,
-    MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
-    MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
-    MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
-    MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
-    MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
-    MZ_ZIP_CDH_DISK_START_OFS = 34,
-    MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
-    MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
-    MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
-
-    /* Local directory header offsets */
-    MZ_ZIP_LDH_SIG_OFS = 0,
-    MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
-    MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
-    MZ_ZIP_LDH_METHOD_OFS = 8,
-    MZ_ZIP_LDH_FILE_TIME_OFS = 10,
-    MZ_ZIP_LDH_FILE_DATE_OFS = 12,
-    MZ_ZIP_LDH_CRC32_OFS = 14,
-    MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
-    MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
-    MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
-    MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
-    MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR = 1 << 3,
-
-    /* End of central directory offsets */
-    MZ_ZIP_ECDH_SIG_OFS = 0,
-    MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
-    MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
-    MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
-    MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
-    MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
-    MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
-    MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
-
-    /* ZIP64 End of central directory locator offsets */
-    MZ_ZIP64_ECDL_SIG_OFS = 0,                    /* 4 bytes */
-    MZ_ZIP64_ECDL_NUM_DISK_CDIR_OFS = 4,          /* 4 bytes */
-    MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS = 8,  /* 8 bytes */
-    MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS = 16, /* 4 bytes */
-
-    /* ZIP64 End of central directory header offsets */
-    MZ_ZIP64_ECDH_SIG_OFS = 0,                       /* 4 bytes */
-    MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS = 4,            /* 8 bytes */
-    MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS = 12,          /* 2 bytes */
-    MZ_ZIP64_ECDH_VERSION_NEEDED_OFS = 14,           /* 2 bytes */
-    MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS = 16,            /* 4 bytes */
-    MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS = 20,            /* 4 bytes */
-    MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 24, /* 8 bytes */
-    MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS = 32,       /* 8 bytes */
-    MZ_ZIP64_ECDH_CDIR_SIZE_OFS = 40,                /* 8 bytes */
-    MZ_ZIP64_ECDH_CDIR_OFS_OFS = 48,                 /* 8 bytes */
-    MZ_ZIP_VERSION_MADE_BY_DOS_FILESYSTEM_ID = 0,
-    MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG = 0x10,
-    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED = 1,
-    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG = 32,
-    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION = 64,
-    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED = 8192,
-    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8 = 1 << 11
-};
+//     /* The flags passed in when the archive is initially opened. */
+//     uint32_t m_init_flags;
 
-typedef struct
-{
-    void *m_p;
-    size_t m_size, m_capacity;
-    mz_uint m_element_size;
-} mz_zip_array;
+//     /* MZ_TRUE if the archive has a zip64 end of central directory headers, etc. */
+//     mz_bool m_zip64;
 
-struct mz_zip_internal_state_tag
-{
-    mz_zip_array m_central_dir;
-    mz_zip_array m_central_dir_offsets;
-    mz_zip_array m_sorted_central_dir_offsets;
+//     /* MZ_TRUE if we found zip64 extended info in the central directory (m_zip64 will also be slammed to true too, even if we didn't find a zip64 end of central dir header, etc.) */
+//     mz_bool m_zip64_has_extended_info_fields;
 
-    /* The flags passed in when the archive is initially opened. */
-    uint32_t m_init_flags;
+//     /* These fields are used by the file, FILE, memory, and memory/heap read/write helpers. */
+//     MZ_FILE *m_pFile;
+//     mz_uint64 m_file_archive_start_ofs;
 
-    /* MZ_TRUE if the archive has a zip64 end of central directory headers, etc. */
-    mz_bool m_zip64;
+//     void *m_pMem;
+//     size_t m_mem_size;
+//     size_t m_mem_capacity;
+// };
 
-    /* MZ_TRUE if we found zip64 extended info in the central directory (m_zip64 will also be slammed to true too, even if we didn't find a zip64 end of central dir header, etc.) */
-    mz_bool m_zip64_has_extended_info_fields;
+// #define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size
 
-    /* These fields are used by the file, FILE, memory, and memory/heap read/write helpers. */
-    MZ_FILE *m_pFile;
-    mz_uint64 m_file_archive_start_ofs;
+// #if defined(DEBUG) || defined(_DEBUG) || defined(NDEBUG)
+// static MZ_FORCEINLINE mz_uint mz_zip_array_range_check(const mz_zip_array *pArray, mz_uint index)
+// {
+//     MZ_ASSERT(index < pArray->m_size);
+//     return index;
+// }
+// #define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[mz_zip_array_range_check(array_ptr, index)]
+// #else
+// #define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]
+// #endif
 
-    void *m_pMem;
-    size_t m_mem_size;
-    size_t m_mem_capacity;
-};
+// static MZ_FORCEINLINE void mz_zip_array_init(mz_zip_array *pArray, mz_uint32 element_size)
+// {
+//     memset(pArray, 0, sizeof(mz_zip_array));
+//     pArray->m_element_size = element_size;
+// }
 
-#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size
+// static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)
+// {
+//     pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
+//     memset(pArray, 0, sizeof(mz_zip_array));
+// }
 
-#if defined(DEBUG) || defined(_DEBUG) || defined(NDEBUG)
-static MZ_FORCEINLINE mz_uint mz_zip_array_range_check(const mz_zip_array *pArray, mz_uint index)
-{
-    MZ_ASSERT(index < pArray->m_size);
-    return index;
-}
-#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[mz_zip_array_range_check(array_ptr, index)]
-#else
-#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]
-#endif
+// static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)
+// {
+//     void *pNew_p;
+//     size_t new_capacity = min_new_capacity;
+//     MZ_ASSERT(pArray->m_element_size);
+//     if (pArray->m_capacity >= min_new_capacity)
+//         return MZ_TRUE;
+//     if (growing)
+//     {
+//         new_capacity = MZ_MAX(1, pArray->m_capacity);
+//         while (new_capacity < min_new_capacity)
+//             new_capacity *= 2;
+//     }
+//     if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity)))
+//         return MZ_FALSE;
+//     pArray->m_p = pNew_p;
+//     pArray->m_capacity = new_capacity;
+//     return MZ_TRUE;
+// }
 
-static MZ_FORCEINLINE void mz_zip_array_init(mz_zip_array *pArray, mz_uint32 element_size)
-{
-    memset(pArray, 0, sizeof(mz_zip_array));
-    pArray->m_element_size = element_size;
-}
+// static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)
+// {
+//     if (new_capacity > pArray->m_capacity)
+//     {
+//         if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))
+//             return MZ_FALSE;
+//     }
+//     return MZ_TRUE;
+// }
 
-static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)
-{
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
-    memset(pArray, 0, sizeof(mz_zip_array));
-}
+// static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
+// {
+//     if (new_size > pArray->m_capacity)
+//     {
+//         if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))
+//             return MZ_FALSE;
+//     }
+//     pArray->m_size = new_size;
+//     return MZ_TRUE;
+// }
 
-static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)
-{
-    void *pNew_p;
-    size_t new_capacity = min_new_capacity;
-    MZ_ASSERT(pArray->m_element_size);
-    if (pArray->m_capacity >= min_new_capacity)
-        return MZ_TRUE;
-    if (growing)
-    {
-        new_capacity = MZ_MAX(1, pArray->m_capacity);
-        while (new_capacity < min_new_capacity)
-            new_capacity *= 2;
-    }
-    if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity)))
-        return MZ_FALSE;
-    pArray->m_p = pNew_p;
-    pArray->m_capacity = new_capacity;
-    return MZ_TRUE;
-}
+// static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
+// {
+//     return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
+// }
 
-static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)
-{
-    if (new_capacity > pArray->m_capacity)
-    {
-        if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))
-            return MZ_FALSE;
-    }
-    return MZ_TRUE;
-}
+// static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)
+// {
+//     size_t orig_size = pArray->m_size;
+//     if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))
+//         return MZ_FALSE;
+//     memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
+//     return MZ_TRUE;
+// }
 
-static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
-{
-    if (new_size > pArray->m_capacity)
-    {
-        if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))
-            return MZ_FALSE;
-    }
-    pArray->m_size = new_size;
-    return MZ_TRUE;
-}
+// #ifndef MINIZ_NO_TIME
+// static MZ_TIME_T mz_zip_dos_to_time_t(int dos_time, int dos_date)
+// {
+//     struct tm tm;
+//     memset(&tm, 0, sizeof(tm));
+//     tm.tm_isdst = -1;
+//     tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
+//     tm.tm_mon = ((dos_date >> 5) & 15) - 1;
+//     tm.tm_mday = dos_date & 31;
+//     tm.tm_hour = (dos_time >> 11) & 31;
+//     tm.tm_min = (dos_time >> 5) & 63;
+//     tm.tm_sec = (dos_time << 1) & 62;
+//     return mktime(&tm);
+// }
 
-static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
-{
-    return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
-}
+// #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
+// static void mz_zip_time_t_to_dos_time(MZ_TIME_T time_, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
+// {
+// #ifdef _MSC_VER
+//     struct tm tm_struct;
+//     struct tm *tm = &tm_struct;
+//     errno_t err = localtime_s(tm, &time_);
+//     if (err)
+//     {
+//         *pDOS_date = 0;
+//         *pDOS_time = 0;
+//         return;
+//     }
+// #else
+//     struct tm *tm = localtime(&time_);
+// #endif /* #ifdef _MSC_VER */
 
-static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)
-{
-    size_t orig_size = pArray->m_size;
-    if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))
-        return MZ_FALSE;
-    memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
-    return MZ_TRUE;
-}
+//     *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
+//     *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
+// }
+// #endif /* MINIZ_NO_ARCHIVE_WRITING_APIS */
 
-#ifndef MINIZ_NO_TIME
-static MZ_TIME_T mz_zip_dos_to_time_t(int dos_time, int dos_date)
-{
-    struct tm tm;
-    memset(&tm, 0, sizeof(tm));
-    tm.tm_isdst = -1;
-    tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
-    tm.tm_mon = ((dos_date >> 5) & 15) - 1;
-    tm.tm_mday = dos_date & 31;
-    tm.tm_hour = (dos_time >> 11) & 31;
-    tm.tm_min = (dos_time >> 5) & 63;
-    tm.tm_sec = (dos_time << 1) & 62;
-    return mktime(&tm);
-}
+// #ifndef MINIZ_NO_STDIO
+// #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
+// static mz_bool mz_zip_get_file_modified_time(const char *pFilename, MZ_TIME_T *pTime)
+// {
+//     struct MZ_FILE_STAT_STRUCT file_stat;
 
-#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-static void mz_zip_time_t_to_dos_time(MZ_TIME_T time_, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
-{
-#ifdef _MSC_VER
-    struct tm tm_struct;
-    struct tm *tm = &tm_struct;
-    errno_t err = localtime_s(tm, &time_);
-    if (err)
-    {
-        *pDOS_date = 0;
-        *pDOS_time = 0;
-        return;
-    }
-#else
-    struct tm *tm = localtime(&time_);
-#endif /* #ifdef _MSC_VER */
+//     /* On Linux with x86 glibc, this call will fail on large files (I think >= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh. */
+//     if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
+//         return MZ_FALSE;
 
-    *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
-    *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
-}
-#endif /* MINIZ_NO_ARCHIVE_WRITING_APIS */
+//     *pTime = file_stat.st_mtime;
 
-#ifndef MINIZ_NO_STDIO
-#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-static mz_bool mz_zip_get_file_modified_time(const char *pFilename, MZ_TIME_T *pTime)
-{
-    struct MZ_FILE_STAT_STRUCT file_stat;
+//     return MZ_TRUE;
+// }
+// #endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS*/
 
-    /* On Linux with x86 glibc, this call will fail on large files (I think >= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh. */
-    if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
-        return MZ_FALSE;
+// static mz_bool mz_zip_set_file_times(const char *pFilename, MZ_TIME_T access_time, MZ_TIME_T modified_time)
+// {
+//     struct utimbuf t;
 
-    *pTime = file_stat.st_mtime;
+//     memset(&t, 0, sizeof(t));
+//     t.actime = access_time;
+//     t.modtime = modified_time;
 
-    return MZ_TRUE;
-}
-#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS*/
+//     return !utime(pFilename, &t);
+// }
+// #endif /* #ifndef MINIZ_NO_STDIO */
+// #endif /* #ifndef MINIZ_NO_TIME */
 
-static mz_bool mz_zip_set_file_times(const char *pFilename, MZ_TIME_T access_time, MZ_TIME_T modified_time)
-{
-    struct utimbuf t;
+// static MZ_FORCEINLINE mz_bool mz_zip_set_error(mz_zip_archive *pZip, mz_zip_error err_num)
+// {
+//     if (pZip)
+//         pZip->m_last_error = err_num;
+//     return MZ_FALSE;
+// }
 
-    memset(&t, 0, sizeof(t));
-    t.actime = access_time;
-    t.modtime = modified_time;
+// static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint flags)
+// {
+//     (void)flags;
+//     if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    return !utime(pFilename, &t);
-}
-#endif /* #ifndef MINIZ_NO_STDIO */
-#endif /* #ifndef MINIZ_NO_TIME */
+//     if (!pZip->m_pAlloc)
+//         pZip->m_pAlloc = miniz_def_alloc_func;
+//     if (!pZip->m_pFree)
+//         pZip->m_pFree = miniz_def_free_func;
+//     if (!pZip->m_pRealloc)
+//         pZip->m_pRealloc = miniz_def_realloc_func;
 
-static MZ_FORCEINLINE mz_bool mz_zip_set_error(mz_zip_archive *pZip, mz_zip_error err_num)
-{
-    if (pZip)
-        pZip->m_last_error = err_num;
-    return MZ_FALSE;
-}
+//     pZip->m_archive_size = 0;
+//     pZip->m_central_directory_file_ofs = 0;
+//     pZip->m_total_files = 0;
+//     pZip->m_last_error = MZ_ZIP_NO_ERROR;
 
-static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint flags)
-{
-    (void)flags;
-    if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-
-    if (!pZip->m_pAlloc)
-        pZip->m_pAlloc = miniz_def_alloc_func;
-    if (!pZip->m_pFree)
-        pZip->m_pFree = miniz_def_free_func;
-    if (!pZip->m_pRealloc)
-        pZip->m_pRealloc = miniz_def_realloc_func;
-
-    pZip->m_archive_size = 0;
-    pZip->m_central_directory_file_ofs = 0;
-    pZip->m_total_files = 0;
-    pZip->m_last_error = MZ_ZIP_NO_ERROR;
-
-    if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
-        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-
-    memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
-    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
-    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
-    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
-    pZip->m_pState->m_init_flags = flags;
-    pZip->m_pState->m_zip64 = MZ_FALSE;
-    pZip->m_pState->m_zip64_has_extended_info_fields = MZ_FALSE;
-
-    pZip->m_zip_mode = MZ_ZIP_MODE_READING;
+//     if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
+//         return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
 
-    return MZ_TRUE;
-}
+//     memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
+//     MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
+//     MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
+//     MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
+//     pZip->m_pState->m_init_flags = flags;
+//     pZip->m_pState->m_zip64 = MZ_FALSE;
+//     pZip->m_pState->m_zip64_has_extended_info_fields = MZ_FALSE;
 
-static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
-{
-    const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
-    const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
-    mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-    mz_uint8 l = 0, r = 0;
-    pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-    pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-    pE = pL + MZ_MIN(l_len, r_len);
-    while (pL < pE)
-    {
-        if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
-            break;
-        pL++;
-        pR++;
-    }
-    return (pL == pE) ? (l_len < r_len) : (l < r);
-}
+//     pZip->m_zip_mode = MZ_ZIP_MODE_READING;
+
+//     return MZ_TRUE;
+// }
 
+// static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
+// {
+//     const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
+//     const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
+//     mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+//     mz_uint8 l = 0, r = 0;
+//     pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
+//     pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
+//     pE = pL + MZ_MIN(l_len, r_len);
+//     while (pL < pE)
+//     {
+//         if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
+//             break;
+//         pL++;
+//         pR++;
+//     }
+//     return (pL == pE) ? (l_len < r_len) : (l < r);
+// }
+/*
 #define MZ_SWAP_UINT32(a, b) \
     do                       \
     {                        \
@@ -3388,1708 +3387,1708 @@ static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pC
         b = t;               \
     }                        \
     MZ_MACRO_END
-
+*/
 /* Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.) */
-static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
-{
-    mz_zip_internal_state *pState = pZip->m_pState;
-    const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
-    const mz_zip_array *pCentral_dir = &pState->m_central_dir;
-    mz_uint32 *pIndices;
-    mz_uint32 start, end;
-    const mz_uint32 size = pZip->m_total_files;
-
-    if (size <= 1U)
-        return;
+// static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
+// {
+//     mz_zip_internal_state *pState = pZip->m_pState;
+//     const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
+//     const mz_zip_array *pCentral_dir = &pState->m_central_dir;
+//     mz_uint32 *pIndices;
+//     mz_uint32 start, end;
+//     const mz_uint32 size = pZip->m_total_files;
 
-    pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
+//     if (size <= 1U)
+//         return;
 
-    start = (size - 2U) >> 1U;
-    for (;;)
-    {
-        mz_uint64 child, root = start;
-        for (;;)
-        {
-            if ((child = (root << 1U) + 1U) >= size)
-                break;
-            child += (((child + 1U) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U])));
-            if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
-                break;
-            MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
-            root = child;
-        }
-        if (!start)
-            break;
-        start--;
-    }
+//     pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
 
-    end = size - 1;
-    while (end > 0)
-    {
-        mz_uint64 child, root = 0;
-        MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
-        for (;;)
-        {
-            if ((child = (root << 1U) + 1U) >= end)
-                break;
-            child += (((child + 1U) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U]));
-            if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
-                break;
-            MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
-            root = child;
-        }
-        end--;
-    }
-}
+//     start = (size - 2U) >> 1U;
+//     for (;;)
+//     {
+//         mz_uint64 child, root = start;
+//         for (;;)
+//         {
+//             if ((child = (root << 1U) + 1U) >= size)
+//                 break;
+//             child += (((child + 1U) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U])));
+//             if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
+//                 break;
+//             MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
+//             root = child;
+//         }
+//         if (!start)
+//             break;
+//         start--;
+//     }
 
-static mz_bool mz_zip_reader_locate_header_sig(mz_zip_archive *pZip, mz_uint32 record_sig, mz_uint32 record_size, mz_int64 *pOfs)
-{
-    mz_int64 cur_file_ofs;
-    mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
-    mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
+//     end = size - 1;
+//     while (end > 0)
+//     {
+//         mz_uint64 child, root = 0;
+//         MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
+//         for (;;)
+//         {
+//             if ((child = (root << 1U) + 1U) >= end)
+//                 break;
+//             child += (((child + 1U) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U]));
+//             if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
+//                 break;
+//             MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
+//             root = child;
+//         }
+//         end--;
+//     }
+// }
 
-    /* Basic sanity checks - reject files which are too small */
-    if (pZip->m_archive_size < record_size)
-        return MZ_FALSE;
+// static mz_bool mz_zip_reader_locate_header_sig(mz_zip_archive *pZip, mz_uint32 record_sig, mz_uint32 record_size, mz_int64 *pOfs)
+// {
+//     mz_int64 cur_file_ofs;
+//     mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
+//     mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
 
-    /* Find the record by scanning the file from the end towards the beginning. */
-    cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
-    for (;;)
-    {
-        int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);
+//     /* Basic sanity checks - reject files which are too small */
+//     if (pZip->m_archive_size < record_size)
+//         return MZ_FALSE;
 
-        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
-            return MZ_FALSE;
+//     /* Find the record by scanning the file from the end towards the beginning. */
+//     cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
+//     for (;;)
+//     {
+//         int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);
 
-        for (i = n - 4; i >= 0; --i)
-        {
-            mz_uint s = MZ_READ_LE32(pBuf + i);
-            if (s == record_sig)
-            {
-                if ((pZip->m_archive_size - (cur_file_ofs + i)) >= record_size)
-                    break;
-            }
-        }
+//         if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
+//             return MZ_FALSE;
 
-        if (i >= 0)
-        {
-            cur_file_ofs += i;
-            break;
-        }
+//         for (i = n - 4; i >= 0; --i)
+//         {
+//             mz_uint s = MZ_READ_LE32(pBuf + i);
+//             if (s == record_sig)
+//             {
+//                 if ((pZip->m_archive_size - (cur_file_ofs + i)) >= record_size)
+//                     break;
+//             }
+//         }
 
-        /* Give up if we've searched the entire file, or we've gone back "too far" (~64kb) */
-        if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (MZ_UINT16_MAX + record_size)))
-            return MZ_FALSE;
+//         if (i >= 0)
+//         {
+//             cur_file_ofs += i;
+//             break;
+//         }
 
-        cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
-    }
+//         /* Give up if we've searched the entire file, or we've gone back "too far" (~64kb) */
+//         if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (MZ_UINT16_MAX + record_size)))
+//             return MZ_FALSE;
 
-    *pOfs = cur_file_ofs;
-    return MZ_TRUE;
-}
+//         cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
+//     }
 
-static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint flags)
-{
-    mz_uint cdir_size = 0, cdir_entries_on_this_disk = 0, num_this_disk = 0, cdir_disk_index = 0;
-    mz_uint64 cdir_ofs = 0;
-    mz_int64 cur_file_ofs = 0;
-    const mz_uint8 *p;
+//     *pOfs = cur_file_ofs;
+//     return MZ_TRUE;
+// }
 
-    mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
-    mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
-    mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
-    mz_uint32 zip64_end_of_central_dir_locator_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
-    mz_uint8 *pZip64_locator = (mz_uint8 *)zip64_end_of_central_dir_locator_u32;
+// static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint flags)
+// {
+//     mz_uint cdir_size = 0, cdir_entries_on_this_disk = 0, num_this_disk = 0, cdir_disk_index = 0;
+//     mz_uint64 cdir_ofs = 0;
+//     mz_int64 cur_file_ofs = 0;
+//     const mz_uint8 *p;
 
-    mz_uint32 zip64_end_of_central_dir_header_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
-    mz_uint8 *pZip64_end_of_central_dir = (mz_uint8 *)zip64_end_of_central_dir_header_u32;
+//     mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
+//     mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
+//     mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
+//     mz_uint32 zip64_end_of_central_dir_locator_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
+//     mz_uint8 *pZip64_locator = (mz_uint8 *)zip64_end_of_central_dir_locator_u32;
 
-    mz_uint64 zip64_end_of_central_dir_ofs = 0;
+//     mz_uint32 zip64_end_of_central_dir_header_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
+//     mz_uint8 *pZip64_end_of_central_dir = (mz_uint8 *)zip64_end_of_central_dir_header_u32;
 
-    /* Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there. */
-    if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
-        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
+//     mz_uint64 zip64_end_of_central_dir_ofs = 0;
 
-    if (!mz_zip_reader_locate_header_sig(pZip, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE, &cur_file_ofs))
-        return mz_zip_set_error(pZip, MZ_ZIP_FAILED_FINDING_CENTRAL_DIR);
+//     /* Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there. */
+//     if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
+//         return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
 
-    /* Read and verify the end of central directory record. */
-    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
+//     if (!mz_zip_reader_locate_header_sig(pZip, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE, &cur_file_ofs))
+//         return mz_zip_set_error(pZip, MZ_ZIP_FAILED_FINDING_CENTRAL_DIR);
 
-    if (MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
-        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
+//     /* Read and verify the end of central directory record. */
+//     if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
 
-    if (cur_file_ofs >= (MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
-    {
-        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs - MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE, pZip64_locator, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
-        {
-            if (MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG)
-            {
-                zip64_end_of_central_dir_ofs = MZ_READ_LE64(pZip64_locator + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS);
-                if (zip64_end_of_central_dir_ofs > (pZip->m_archive_size - MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
-                    return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
+//     if (MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
+//         return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
 
-                if (pZip->m_pRead(pZip->m_pIO_opaque, zip64_end_of_central_dir_ofs, pZip64_end_of_central_dir, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
-                {
-                    if (MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG)
-                    {
-                        pZip->m_pState->m_zip64 = MZ_TRUE;
-                    }
-                }
-            }
-        }
-    }
+//     if (cur_file_ofs >= (MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
+//     {
+//         if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs - MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE, pZip64_locator, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
+//         {
+//             if (MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG)
+//             {
+//                 zip64_end_of_central_dir_ofs = MZ_READ_LE64(pZip64_locator + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS);
+//                 if (zip64_end_of_central_dir_ofs > (pZip->m_archive_size - MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
+//                     return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
 
-    pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS);
-    cdir_entries_on_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
-    num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
-    cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
-    cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS);
-    cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
+//                 if (pZip->m_pRead(pZip->m_pIO_opaque, zip64_end_of_central_dir_ofs, pZip64_end_of_central_dir, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
+//                 {
+//                     if (MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG)
+//                     {
+//                         pZip->m_pState->m_zip64 = MZ_TRUE;
+//                     }
+//                 }
+//             }
+//         }
+//     }
 
-    if (pZip->m_pState->m_zip64)
-    {
-        mz_uint32 zip64_total_num_of_disks = MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS);
-        mz_uint64 zip64_cdir_total_entries = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS);
-        mz_uint64 zip64_cdir_total_entries_on_this_disk = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
-        mz_uint64 zip64_size_of_end_of_central_dir_record = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS);
-        mz_uint64 zip64_size_of_central_directory = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_SIZE_OFS);
+//     pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS);
+//     cdir_entries_on_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
+//     num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
+//     cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
+//     cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS);
+//     cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
 
-        if (zip64_size_of_end_of_central_dir_record < (MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - 12))
-            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//     if (pZip->m_pState->m_zip64)
+//     {
+//         mz_uint32 zip64_total_num_of_disks = MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS);
+//         mz_uint64 zip64_cdir_total_entries = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS);
+//         mz_uint64 zip64_cdir_total_entries_on_this_disk = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
+//         mz_uint64 zip64_size_of_end_of_central_dir_record = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS);
+//         mz_uint64 zip64_size_of_central_directory = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_SIZE_OFS);
 
-        if (zip64_total_num_of_disks != 1U)
-            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);
+//         if (zip64_size_of_end_of_central_dir_record < (MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - 12))
+//             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-        /* Check for miniz's practical limits */
-        if (zip64_cdir_total_entries > MZ_UINT32_MAX)
-            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
+//         if (zip64_total_num_of_disks != 1U)
+//             return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);
 
-        pZip->m_total_files = (mz_uint32)zip64_cdir_total_entries;
+//         /* Check for miniz's practical limits */
+//         if (zip64_cdir_total_entries > MZ_UINT32_MAX)
+//             return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
 
-        if (zip64_cdir_total_entries_on_this_disk > MZ_UINT32_MAX)
-            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
+//         pZip->m_total_files = (mz_uint32)zip64_cdir_total_entries;
 
-        cdir_entries_on_this_disk = (mz_uint32)zip64_cdir_total_entries_on_this_disk;
+//         if (zip64_cdir_total_entries_on_this_disk > MZ_UINT32_MAX)
+//             return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
 
-        /* Check for miniz's current practical limits (sorry, this should be enough for millions of files) */
-        if (zip64_size_of_central_directory > MZ_UINT32_MAX)
-            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
+//         cdir_entries_on_this_disk = (mz_uint32)zip64_cdir_total_entries_on_this_disk;
 
-        cdir_size = (mz_uint32)zip64_size_of_central_directory;
+//         /* Check for miniz's current practical limits (sorry, this should be enough for millions of files) */
+//         if (zip64_size_of_central_directory > MZ_UINT32_MAX)
+//             return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
 
-        num_this_disk = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS);
+//         cdir_size = (mz_uint32)zip64_size_of_central_directory;
 
-        cdir_disk_index = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS);
+//         num_this_disk = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS);
 
-        cdir_ofs = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_OFS_OFS);
-    }
+//         cdir_disk_index = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS);
 
-    if (pZip->m_total_files != cdir_entries_on_this_disk)
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);
+//         cdir_ofs = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_OFS_OFS);
+//     }
 
-    if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);
+//     if (pZip->m_total_files != cdir_entries_on_this_disk)
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);
 
-    if (cdir_size < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//     if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);
 
-    if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//     if (cdir_size < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-    pZip->m_central_directory_file_ofs = cdir_ofs;
+//     if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-    if (pZip->m_total_files)
-    {
-        mz_uint i, n;
-        /* Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and possibly another to hold the sorted indices. */
-        if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||
-            (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
-            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//     pZip->m_central_directory_file_ofs = cdir_ofs;
 
-        if (sort_central_dir)
-        {
-            if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))
-                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-        }
+//     if (pZip->m_total_files)
+//     {
+//         mz_uint i, n;
+//         /* Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and possibly another to hold the sorted indices. */
+//         if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||
+//             (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
+//             return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
 
-        if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
+//         if (sort_central_dir)
+//         {
+//             if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))
+//                 return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//         }
 
-        /* Now create an index into the central directory file records, do some basic sanity checking on each record */
-        p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
-        for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)
-        {
-            mz_uint total_header_size, disk_index, bit_flags, filename_size, ext_data_size;
-            mz_uint64 comp_size, decomp_size, local_header_ofs;
+//         if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
 
-            if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
-                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//         /* Now create an index into the central directory file records, do some basic sanity checking on each record */
+//         p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
+//         for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)
+//         {
+//             mz_uint total_header_size, disk_index, bit_flags, filename_size, ext_data_size;
+//             mz_uint64 comp_size, decomp_size, local_header_ofs;
 
-            MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);
+//             if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
+//                 return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-            if (sort_central_dir)
-                MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;
+//             MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);
 
-            comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-            decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
-            local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
-            filename_size = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-            ext_data_size = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);
+//             if (sort_central_dir)
+//                 MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;
 
-            if ((!pZip->m_pState->m_zip64_has_extended_info_fields) &&
-                (ext_data_size) &&
-                (MZ_MAX(MZ_MAX(comp_size, decomp_size), local_header_ofs) == MZ_UINT32_MAX))
-            {
-                /* Attempt to find zip64 extended information field in the entry's extra data */
-                mz_uint32 extra_size_remaining = ext_data_size;
+//             comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
+//             decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
+//             local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
+//             filename_size = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+//             ext_data_size = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);
 
-                if (extra_size_remaining)
-                {
-                    const mz_uint8 *pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size;
+//             if ((!pZip->m_pState->m_zip64_has_extended_info_fields) &&
+//                 (ext_data_size) &&
+//                 (MZ_MAX(MZ_MAX(comp_size, decomp_size), local_header_ofs) == MZ_UINT32_MAX))
+//             {
+//                 /* Attempt to find zip64 extended information field in the entry's extra data */
+//                 mz_uint32 extra_size_remaining = ext_data_size;
 
-                    do
-                    {
-                        mz_uint32 field_id;
-                        mz_uint32 field_data_size;
+//                 if (extra_size_remaining)
+//                 {
+//                     const mz_uint8 *pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size;
 
-                        if (extra_size_remaining < (sizeof(mz_uint16) * 2))
-                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//                     do
+//                     {
+//                         mz_uint32 field_id;
+//                         mz_uint32 field_data_size;
 
-                        field_id = MZ_READ_LE16(pExtra_data);
-                        field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
+//                         if (extra_size_remaining < (sizeof(mz_uint16) * 2))
+//                             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-                        if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
-                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//                         field_id = MZ_READ_LE16(pExtra_data);
+//                         field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
 
-                        if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
-                        {
-                            /* Ok, the archive didn't have any zip64 headers but it uses a zip64 extended information field so mark it as zip64 anyway (this can occur with infozip's zip util when it reads compresses files from stdin). */
-                            pZip->m_pState->m_zip64 = MZ_TRUE;
-                            pZip->m_pState->m_zip64_has_extended_info_fields = MZ_TRUE;
-                            break;
-                        }
+//                         if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
+//                             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-                        pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
-                        extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
-                    } while (extra_size_remaining);
-                }
-            }
+//                         if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
+//                         {
+//                             /* Ok, the archive didn't have any zip64 headers but it uses a zip64 extended information field so mark it as zip64 anyway (this can occur with infozip's zip util when it reads compresses files from stdin). */
+//                             pZip->m_pState->m_zip64 = MZ_TRUE;
+//                             pZip->m_pState->m_zip64_has_extended_info_fields = MZ_TRUE;
+//                             break;
+//                         }
 
-            /* I've seen archives that aren't marked as zip64 that uses zip64 ext data, argh */
-            if ((comp_size != MZ_UINT32_MAX) && (decomp_size != MZ_UINT32_MAX))
-            {
-                if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size))
-                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
-            }
+//                         pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
+//                         extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
+//                     } while (extra_size_remaining);
+//                 }
+//             }
 
-            disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
-            if ((disk_index == MZ_UINT16_MAX) || ((disk_index != num_this_disk) && (disk_index != 1)))
-                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);
+//             /* I've seen archives that aren't marked as zip64 that uses zip64 ext data, argh */
+//             if ((comp_size != MZ_UINT32_MAX) && (decomp_size != MZ_UINT32_MAX))
+//             {
+//                 if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size))
+//                     return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//             }
 
-            if (comp_size != MZ_UINT32_MAX)
-            {
-                if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
-                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
-            }
+//             disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
+//             if ((disk_index == MZ_UINT16_MAX) || ((disk_index != num_this_disk) && (disk_index != 1)))
+//                 return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);
 
-            bit_flags = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
-            if (bit_flags & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED)
-                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
+//             if (comp_size != MZ_UINT32_MAX)
+//             {
+//                 if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
+//                     return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//             }
 
-            if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)
-                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//             bit_flags = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
+//             if (bit_flags & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED)
+//                 return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
 
-            n -= total_header_size;
-            p += total_header_size;
-        }
-    }
+//             if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)
+//                 return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-    if (sort_central_dir)
-        mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);
+//             n -= total_header_size;
+//             p += total_header_size;
+//         }
+//     }
 
-    return MZ_TRUE;
-}
+//     if (sort_central_dir)
+//         mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);
 
-void mz_zip_zero_struct(mz_zip_archive *pZip)
-{
-    if (pZip)
-        MZ_CLEAR_OBJ(*pZip);
-}
+//     return MZ_TRUE;
+// }
 
-static mz_bool mz_zip_reader_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
-{
-    mz_bool status = MZ_TRUE;
+// void mz_zip_zero_struct(mz_zip_archive *pZip)
+// {
+//     if (pZip)
+//         MZ_CLEAR_OBJ(*pZip);
+// }
 
-    if (!pZip)
-        return MZ_FALSE;
+// static mz_bool mz_zip_reader_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
+// {
+//     mz_bool status = MZ_TRUE;
 
-    if ((!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
-    {
-        if (set_last_error)
-            pZip->m_last_error = MZ_ZIP_INVALID_PARAMETER;
+//     if (!pZip)
+//         return MZ_FALSE;
 
-        return MZ_FALSE;
-    }
+//     if ((!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
+//     {
+//         if (set_last_error)
+//             pZip->m_last_error = MZ_ZIP_INVALID_PARAMETER;
 
-    if (pZip->m_pState)
-    {
-        mz_zip_internal_state *pState = pZip->m_pState;
-        pZip->m_pState = NULL;
+//         return MZ_FALSE;
+//     }
 
-        mz_zip_array_clear(pZip, &pState->m_central_dir);
-        mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
-        mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
+//     if (pZip->m_pState)
+//     {
+//         mz_zip_internal_state *pState = pZip->m_pState;
+//         pZip->m_pState = NULL;
 
-#ifndef MINIZ_NO_STDIO
-        if (pState->m_pFile)
-        {
-            if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
-            {
-                if (MZ_FCLOSE(pState->m_pFile) == EOF)
-                {
-                    if (set_last_error)
-                        pZip->m_last_error = MZ_ZIP_FILE_CLOSE_FAILED;
-                    status = MZ_FALSE;
-                }
-            }
-            pState->m_pFile = NULL;
-        }
-#endif /* #ifndef MINIZ_NO_STDIO */
+//         mz_zip_array_clear(pZip, &pState->m_central_dir);
+//         mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
+//         mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
 
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-    }
-    pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
+// #ifndef MINIZ_NO_STDIO
+//         if (pState->m_pFile)
+//         {
+//             if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
+//             {
+//                 if (MZ_FCLOSE(pState->m_pFile) == EOF)
+//                 {
+//                     if (set_last_error)
+//                         pZip->m_last_error = MZ_ZIP_FILE_CLOSE_FAILED;
+//                     status = MZ_FALSE;
+//                 }
+//             }
+//             pState->m_pFile = NULL;
+//         }
+// #endif /* #ifndef MINIZ_NO_STDIO */
 
-    return status;
-}
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//     }
+//     pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
 
-mz_bool mz_zip_reader_end(mz_zip_archive *pZip)
-{
-    return mz_zip_reader_end_internal(pZip, MZ_TRUE);
-}
-mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags)
-{
-    if ((!pZip) || (!pZip->m_pRead))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     return status;
+// }
 
-    if (!mz_zip_reader_init_internal(pZip, flags))
-        return MZ_FALSE;
+// mz_bool mz_zip_reader_end(mz_zip_archive *pZip)
+// {
+//     return mz_zip_reader_end_internal(pZip, MZ_TRUE);
+// }
+// mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags)
+// {
+//     if ((!pZip) || (!pZip->m_pRead))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    pZip->m_zip_type = MZ_ZIP_TYPE_USER;
-    pZip->m_archive_size = size;
+//     if (!mz_zip_reader_init_internal(pZip, flags))
+//         return MZ_FALSE;
 
-    if (!mz_zip_reader_read_central_dir(pZip, flags))
-    {
-        mz_zip_reader_end_internal(pZip, MZ_FALSE);
-        return MZ_FALSE;
-    }
+//     pZip->m_zip_type = MZ_ZIP_TYPE_USER;
+//     pZip->m_archive_size = size;
 
-    return MZ_TRUE;
-}
+//     if (!mz_zip_reader_read_central_dir(pZip, flags))
+//     {
+//         mz_zip_reader_end_internal(pZip, MZ_FALSE);
+//         return MZ_FALSE;
+//     }
 
-static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
-{
-    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
-    size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
-    memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
-    return s;
-}
+//     return MZ_TRUE;
+// }
 
-mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags)
-{
-    if (!pMem)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+// static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
+// {
+//     mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
+//     size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
+//     memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
+//     return s;
+// }
 
-    if (size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
-        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
+// mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags)
+// {
+//     if (!pMem)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    if (!mz_zip_reader_init_internal(pZip, flags))
-        return MZ_FALSE;
+//     if (size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
+//         return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
 
-    pZip->m_zip_type = MZ_ZIP_TYPE_MEMORY;
-    pZip->m_archive_size = size;
-    pZip->m_pRead = mz_zip_mem_read_func;
-    pZip->m_pIO_opaque = pZip;
-    pZip->m_pNeeds_keepalive = NULL;
+//     if (!mz_zip_reader_init_internal(pZip, flags))
+//         return MZ_FALSE;
 
-#ifdef __cplusplus
-    pZip->m_pState->m_pMem = const_cast<void *>(pMem);
-#else
-    pZip->m_pState->m_pMem = (void *)pMem;
-#endif
+//     pZip->m_zip_type = MZ_ZIP_TYPE_MEMORY;
+//     pZip->m_archive_size = size;
+//     pZip->m_pRead = mz_zip_mem_read_func;
+//     pZip->m_pIO_opaque = pZip;
+//     pZip->m_pNeeds_keepalive = NULL;
 
-    pZip->m_pState->m_mem_size = size;
+// #ifdef __cplusplus
+//     pZip->m_pState->m_pMem = const_cast<void *>(pMem);
+// #else
+//     pZip->m_pState->m_pMem = (void *)pMem;
+// #endif
 
-    if (!mz_zip_reader_read_central_dir(pZip, flags))
-    {
-        mz_zip_reader_end_internal(pZip, MZ_FALSE);
-        return MZ_FALSE;
-    }
+//     pZip->m_pState->m_mem_size = size;
 
-    return MZ_TRUE;
-}
+//     if (!mz_zip_reader_read_central_dir(pZip, flags))
+//     {
+//         mz_zip_reader_end_internal(pZip, MZ_FALSE);
+//         return MZ_FALSE;
+//     }
 
-#ifndef MINIZ_NO_STDIO
-static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
-{
-    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
-    mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
+//     return MZ_TRUE;
+// }
 
-    file_ofs += pZip->m_pState->m_file_archive_start_ofs;
+// #ifndef MINIZ_NO_STDIO
+// static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
+// {
+//     mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
+//     mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
 
-    if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
-        return 0;
+//     file_ofs += pZip->m_pState->m_file_archive_start_ofs;
 
-    return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
-}
+//     if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
+//         return 0;
 
-mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)
-{
-    return mz_zip_reader_init_file_v2(pZip, pFilename, flags, 0, 0);
-}
+//     return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
+// }
 
-mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size)
-{
-    mz_uint64 file_size;
-    MZ_FILE *pFile;
+// mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)
+// {
+//     return mz_zip_reader_init_file_v2(pZip, pFilename, flags, 0, 0);
+// }
 
-    if ((!pZip) || (!pFilename) || ((archive_size) && (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+// mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size)
+// {
+//     mz_uint64 file_size;
+//     MZ_FILE *pFile;
 
-    pFile = MZ_FOPEN(pFilename, "rb");
-    if (!pFile)
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
+//     if ((!pZip) || (!pFilename) || ((archive_size) && (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    file_size = archive_size;
-    if (!file_size)
-    {
-        if (MZ_FSEEK64(pFile, 0, SEEK_END))
-        {
-            MZ_FCLOSE(pFile);
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
-        }
+//     pFile = MZ_FOPEN(pFilename, "rb");
+//     if (!pFile)
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
 
-        file_size = MZ_FTELL64(pFile);
-    }
+//     file_size = archive_size;
+//     if (!file_size)
+//     {
+//         if (MZ_FSEEK64(pFile, 0, SEEK_END))
+//         {
+//             MZ_FCLOSE(pFile);
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
+//         }
 
-    /* TODO: Better sanity check archive_size and the # of actual remaining bytes */
+//         file_size = MZ_FTELL64(pFile);
+//     }
 
-    if (file_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
-    {
-        MZ_FCLOSE(pFile);
-        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
-    }
+//     /* TODO: Better sanity check archive_size and the # of actual remaining bytes */
 
-    if (!mz_zip_reader_init_internal(pZip, flags))
-    {
-        MZ_FCLOSE(pFile);
-        return MZ_FALSE;
-    }
+//     if (file_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
+//     {
+//         MZ_FCLOSE(pFile);
+//         return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
+//     }
 
-    pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
-    pZip->m_pRead = mz_zip_file_read_func;
-    pZip->m_pIO_opaque = pZip;
-    pZip->m_pState->m_pFile = pFile;
-    pZip->m_archive_size = file_size;
-    pZip->m_pState->m_file_archive_start_ofs = file_start_ofs;
+//     if (!mz_zip_reader_init_internal(pZip, flags))
+//     {
+//         MZ_FCLOSE(pFile);
+//         return MZ_FALSE;
+//     }
 
-    if (!mz_zip_reader_read_central_dir(pZip, flags))
-    {
-        mz_zip_reader_end_internal(pZip, MZ_FALSE);
-        return MZ_FALSE;
-    }
+//     pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
+//     pZip->m_pRead = mz_zip_file_read_func;
+//     pZip->m_pIO_opaque = pZip;
+//     pZip->m_pState->m_pFile = pFile;
+//     pZip->m_archive_size = file_size;
+//     pZip->m_pState->m_file_archive_start_ofs = file_start_ofs;
 
-    return MZ_TRUE;
-}
+//     if (!mz_zip_reader_read_central_dir(pZip, flags))
+//     {
+//         mz_zip_reader_end_internal(pZip, MZ_FALSE);
+//         return MZ_FALSE;
+//     }
 
-mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags)
-{
-    mz_uint64 cur_file_ofs;
+//     return MZ_TRUE;
+// }
 
-    if ((!pZip) || (!pFile))
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
+// mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags)
+// {
+//     mz_uint64 cur_file_ofs;
 
-    cur_file_ofs = MZ_FTELL64(pFile);
+//     if ((!pZip) || (!pFile))
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
 
-    if (!archive_size)
-    {
-        if (MZ_FSEEK64(pFile, 0, SEEK_END))
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
+//     cur_file_ofs = MZ_FTELL64(pFile);
 
-        archive_size = MZ_FTELL64(pFile) - cur_file_ofs;
+//     if (!archive_size)
+//     {
+//         if (MZ_FSEEK64(pFile, 0, SEEK_END))
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
 
-        if (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
-            return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
-    }
+//         archive_size = MZ_FTELL64(pFile) - cur_file_ofs;
 
-    if (!mz_zip_reader_init_internal(pZip, flags))
-        return MZ_FALSE;
+//         if (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
+//             return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
+//     }
 
-    pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
-    pZip->m_pRead = mz_zip_file_read_func;
+//     if (!mz_zip_reader_init_internal(pZip, flags))
+//         return MZ_FALSE;
 
-    pZip->m_pIO_opaque = pZip;
-    pZip->m_pState->m_pFile = pFile;
-    pZip->m_archive_size = archive_size;
-    pZip->m_pState->m_file_archive_start_ofs = cur_file_ofs;
+//     pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
+//     pZip->m_pRead = mz_zip_file_read_func;
 
-    if (!mz_zip_reader_read_central_dir(pZip, flags))
-    {
-        mz_zip_reader_end_internal(pZip, MZ_FALSE);
-        return MZ_FALSE;
-    }
+//     pZip->m_pIO_opaque = pZip;
+//     pZip->m_pState->m_pFile = pFile;
+//     pZip->m_archive_size = archive_size;
+//     pZip->m_pState->m_file_archive_start_ofs = cur_file_ofs;
 
-    return MZ_TRUE;
-}
+//     if (!mz_zip_reader_read_central_dir(pZip, flags))
+//     {
+//         mz_zip_reader_end_internal(pZip, MZ_FALSE);
+//         return MZ_FALSE;
+//     }
 
-#endif /* #ifndef MINIZ_NO_STDIO */
+//     return MZ_TRUE;
+// }
 
-static MZ_FORCEINLINE const mz_uint8 *mz_zip_get_cdh(mz_zip_archive *pZip, mz_uint file_index)
-{
-    if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files))
-        return NULL;
-    return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
-}
+// #endif /* #ifndef MINIZ_NO_STDIO */
 
-mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)
-{
-    mz_uint m_bit_flag;
-    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
-    if (!p)
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-        return MZ_FALSE;
-    }
+// static MZ_FORCEINLINE const mz_uint8 *mz_zip_get_cdh(mz_zip_archive *pZip, mz_uint file_index)
+// {
+//     if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files))
+//         return NULL;
+//     return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
+// }
 
-    m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
-    return (m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION)) != 0;
-}
+// mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)
+// {
+//     mz_uint m_bit_flag;
+//     const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
+//     if (!p)
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//         return MZ_FALSE;
+//     }
 
-mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index)
-{
-    mz_uint bit_flag;
-    mz_uint method;
+//     m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
+//     return (m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION)) != 0;
+// }
 
-    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
-    if (!p)
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-        return MZ_FALSE;
-    }
+// mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index)
+// {
+//     mz_uint bit_flag;
+//     mz_uint method;
 
-    method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
-    bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
+//     const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
+//     if (!p)
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//         return MZ_FALSE;
+//     }
 
-    if ((method != 0) && (method != MZ_DEFLATED))
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
-        return MZ_FALSE;
-    }
+//     method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
+//     bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
 
-    if (bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION))
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
-        return MZ_FALSE;
-    }
+//     if ((method != 0) && (method != MZ_DEFLATED))
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
+//         return MZ_FALSE;
+//     }
 
-    if (bit_flag & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG)
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
-        return MZ_FALSE;
-    }
+//     if (bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION))
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
+//         return MZ_FALSE;
+//     }
 
-    return MZ_TRUE;
-}
+//     if (bit_flag & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG)
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
+//         return MZ_FALSE;
+//     }
 
-mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)
-{
-    mz_uint filename_len, attribute_mapping_id, external_attr;
-    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
-    if (!p)
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-        return MZ_FALSE;
-    }
+//     return MZ_TRUE;
+// }
 
-    filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-    if (filename_len)
-    {
-        if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
-            return MZ_TRUE;
-    }
+// mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)
+// {
+//     mz_uint filename_len, attribute_mapping_id, external_attr;
+//     const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
+//     if (!p)
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//         return MZ_FALSE;
+//     }
+
+//     filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+//     if (filename_len)
+//     {
+//         if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
+//             return MZ_TRUE;
+//     }
 
     /* Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct. */
     /* Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field. */
     /* FIXME: Remove this check? Is it necessary - we already check the filename. */
-    attribute_mapping_id = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS) >> 8;
-    (void)attribute_mapping_id;
+//     attribute_mapping_id = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS) >> 8;
+//     (void)attribute_mapping_id;
 
-    external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
-    if ((external_attr & MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG) != 0)
-    {
-        return MZ_TRUE;
-    }
+//     external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
+//     if ((external_attr & MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG) != 0)
+//     {
+//         return MZ_TRUE;
+//     }
 
-    return MZ_FALSE;
-}
+//     return MZ_FALSE;
+// }
 
-static mz_bool mz_zip_file_stat_internal(mz_zip_archive *pZip, mz_uint file_index, const mz_uint8 *pCentral_dir_header, mz_zip_archive_file_stat *pStat, mz_bool *pFound_zip64_extra_data)
-{
-    mz_uint n;
-    const mz_uint8 *p = pCentral_dir_header;
-
-    if (pFound_zip64_extra_data)
-        *pFound_zip64_extra_data = MZ_FALSE;
-
-    if ((!p) || (!pStat))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-
-    /* Extract fields from the central directory record. */
-    pStat->m_file_index = file_index;
-    pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
-    pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
-    pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
-    pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
-    pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
-#ifndef MINIZ_NO_TIME
-    pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
-#endif
-    pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
-    pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-    pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
-    pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
-    pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
-    pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
-
-    /* Copy as much of the filename and comment as possible. */
-    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
-    memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
-    pStat->m_filename[n] = '\0';
-
-    n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
-    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
-    pStat->m_comment_size = n;
-    memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n);
-    pStat->m_comment[n] = '\0';
-
-    /* Set some flags for convienance */
-    pStat->m_is_directory = mz_zip_reader_is_file_a_directory(pZip, file_index);
-    pStat->m_is_encrypted = mz_zip_reader_is_file_encrypted(pZip, file_index);
-    pStat->m_is_supported = mz_zip_reader_is_file_supported(pZip, file_index);
-
-    /* See if we need to read any zip64 extended information fields. */
-    /* Confusingly, these zip64 fields can be present even on non-zip64 archives (Debian zip on a huge files from stdin piped to stdout creates them). */
-    if (MZ_MAX(MZ_MAX(pStat->m_comp_size, pStat->m_uncomp_size), pStat->m_local_header_ofs) == MZ_UINT32_MAX)
-    {
-        /* Attempt to find zip64 extended information field in the entry's extra data */
-        mz_uint32 extra_size_remaining = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);
+// static mz_bool mz_zip_file_stat_internal(mz_zip_archive *pZip, mz_uint file_index, const mz_uint8 *pCentral_dir_header, mz_zip_archive_file_stat *pStat, mz_bool *pFound_zip64_extra_data)
+// {
+//     mz_uint n;
+//     const mz_uint8 *p = pCentral_dir_header;
 
-        if (extra_size_remaining)
-        {
-            const mz_uint8 *pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+//     if (pFound_zip64_extra_data)
+//         *pFound_zip64_extra_data = MZ_FALSE;
 
-            do
-            {
-                mz_uint32 field_id;
-                mz_uint32 field_data_size;
+//     if ((!p) || (!pStat))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-                if (extra_size_remaining < (sizeof(mz_uint16) * 2))
-                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//     /* Extract fields from the central directory record. */
+//     pStat->m_file_index = file_index;
+//     pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
+//     pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
+//     pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
+//     pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
+//     pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
+// #ifndef MINIZ_NO_TIME
+//     pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
+// #endif
+//     pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
+//     pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
+//     pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
+//     pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
+//     pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
+//     pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
+
+//     /* Copy as much of the filename and comment as possible. */
+//     n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+//     n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
+//     memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
+//     pStat->m_filename[n] = '\0';
+
+//     n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
+//     n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
+//     pStat->m_comment_size = n;
+//     memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n);
+//     pStat->m_comment[n] = '\0';
+
+//     /* Set some flags for convienance */
+//     pStat->m_is_directory = mz_zip_reader_is_file_a_directory(pZip, file_index);
+//     pStat->m_is_encrypted = mz_zip_reader_is_file_encrypted(pZip, file_index);
+//     pStat->m_is_supported = mz_zip_reader_is_file_supported(pZip, file_index);
+
+//     /* See if we need to read any zip64 extended information fields. */
+//     /* Confusingly, these zip64 fields can be present even on non-zip64 archives (Debian zip on a huge files from stdin piped to stdout creates them). */
+//     if (MZ_MAX(MZ_MAX(pStat->m_comp_size, pStat->m_uncomp_size), pStat->m_local_header_ofs) == MZ_UINT32_MAX)
+//     {
+//         /* Attempt to find zip64 extended information field in the entry's extra data */
+//         mz_uint32 extra_size_remaining = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);
 
-                field_id = MZ_READ_LE16(pExtra_data);
-                field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
+//         if (extra_size_remaining)
+//         {
+//             const mz_uint8 *pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
 
-                if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
-                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//             do
+//             {
+//                 mz_uint32 field_id;
+//                 mz_uint32 field_data_size;
 
-                if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
-                {
-                    const mz_uint8 *pField_data = pExtra_data + sizeof(mz_uint16) * 2;
-                    mz_uint32 field_data_remaining = field_data_size;
+//                 if (extra_size_remaining < (sizeof(mz_uint16) * 2))
+//                     return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-                    if (pFound_zip64_extra_data)
-                        *pFound_zip64_extra_data = MZ_TRUE;
+//                 field_id = MZ_READ_LE16(pExtra_data);
+//                 field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
 
-                    if (pStat->m_uncomp_size == MZ_UINT32_MAX)
-                    {
-                        if (field_data_remaining < sizeof(mz_uint64))
-                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//                 if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
+//                     return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-                        pStat->m_uncomp_size = MZ_READ_LE64(pField_data);
-                        pField_data += sizeof(mz_uint64);
-                        field_data_remaining -= sizeof(mz_uint64);
-                    }
+//                 if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
+//                 {
+//                     const mz_uint8 *pField_data = pExtra_data + sizeof(mz_uint16) * 2;
+//                     mz_uint32 field_data_remaining = field_data_size;
+
+//                     if (pFound_zip64_extra_data)
+//                         *pFound_zip64_extra_data = MZ_TRUE;
+
+//                     if (pStat->m_uncomp_size == MZ_UINT32_MAX)
+//                     {
+//                         if (field_data_remaining < sizeof(mz_uint64))
+//                             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+
+//                         pStat->m_uncomp_size = MZ_READ_LE64(pField_data);
+//                         pField_data += sizeof(mz_uint64);
+//                         field_data_remaining -= sizeof(mz_uint64);
+//                     }
+
+//                     if (pStat->m_comp_size == MZ_UINT32_MAX)
+//                     {
+//                         if (field_data_remaining < sizeof(mz_uint64))
+//                             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+
+//                         pStat->m_comp_size = MZ_READ_LE64(pField_data);
+//                         pField_data += sizeof(mz_uint64);
+//                         field_data_remaining -= sizeof(mz_uint64);
+//                     }
+
+//                     if (pStat->m_local_header_ofs == MZ_UINT32_MAX)
+//                     {
+//                         if (field_data_remaining < sizeof(mz_uint64))
+//                             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+
+//                         pStat->m_local_header_ofs = MZ_READ_LE64(pField_data);
+//                         pField_data += sizeof(mz_uint64);
+//                         // field_data_remaining -= sizeof(mz_uint64);
+//                     }
+
+//                     break;
+//                 }
 
-                    if (pStat->m_comp_size == MZ_UINT32_MAX)
-                    {
-                        if (field_data_remaining < sizeof(mz_uint64))
-                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//                 pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
+//                 extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
+//             } while (extra_size_remaining);
+//         }
+//     }
 
-                        pStat->m_comp_size = MZ_READ_LE64(pField_data);
-                        pField_data += sizeof(mz_uint64);
-                        field_data_remaining -= sizeof(mz_uint64);
-                    }
+//     return MZ_TRUE;
+// }
 
-                    if (pStat->m_local_header_ofs == MZ_UINT32_MAX)
-                    {
-                        if (field_data_remaining < sizeof(mz_uint64))
-                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+// static MZ_FORCEINLINE mz_bool mz_zip_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)
+// {
+//     mz_uint i;
+//     if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
+//         return 0 == memcmp(pA, pB, len);
+//     for (i = 0; i < len; ++i)
+//         if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
+//             return MZ_FALSE;
+//     return MZ_TRUE;
+// }
 
-                        pStat->m_local_header_ofs = MZ_READ_LE64(pField_data);
-                        pField_data += sizeof(mz_uint64);
-                        // field_data_remaining -= sizeof(mz_uint64);
-                    }
+// static MZ_FORCEINLINE int mz_zip_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)
+// {
+//     const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
+//     mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+//     mz_uint8 l = 0, r = 0;
+//     pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
+//     pE = pL + MZ_MIN(l_len, r_len);
+//     while (pL < pE)
+//     {
+//         if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
+//             break;
+//         pL++;
+//         pR++;
+//     }
+//     return (pL == pE) ? (int)(l_len - r_len) : (l - r);
+// }
 
-                    break;
-                }
+// static mz_bool mz_zip_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename, mz_uint32 *pIndex)
+// {
+//     mz_zip_internal_state *pState = pZip->m_pState;
+//     const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
+//     const mz_zip_array *pCentral_dir = &pState->m_central_dir;
+//     mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
+//     const uint32_t size = pZip->m_total_files;
+//     const mz_uint filename_len = (mz_uint)strlen(pFilename);
 
-                pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
-                extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
-            } while (extra_size_remaining);
-        }
-    }
+//     if (pIndex)
+//         *pIndex = 0;
 
-    return MZ_TRUE;
-}
+//     if (size)
+//     {
+//         /* yes I could use uint32_t's, but then we would have to add some special case checks in the loop, argh, and */
+//         /* honestly the major expense here on 32-bit CPU's will still be the filename compare */
+//         mz_int64 l = 0, h = (mz_int64)size - 1;
 
-static MZ_FORCEINLINE mz_bool mz_zip_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)
-{
-    mz_uint i;
-    if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
-        return 0 == memcmp(pA, pB, len);
-    for (i = 0; i < len; ++i)
-        if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
-            return MZ_FALSE;
-    return MZ_TRUE;
-}
+//         while (l <= h)
+//         {
+//             mz_int64 m = l + ((h - l) >> 1);
+//             uint32_t file_index = pIndices[(uint32_t)m];
 
-static MZ_FORCEINLINE int mz_zip_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)
-{
-    const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
-    mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-    mz_uint8 l = 0, r = 0;
-    pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-    pE = pL + MZ_MIN(l_len, r_len);
-    while (pL < pE)
-    {
-        if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
-            break;
-        pL++;
-        pR++;
-    }
-    return (pL == pE) ? (int)(l_len - r_len) : (l - r);
-}
+//             int comp = mz_zip_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
+//             if (!comp)
+//             {
+//                 if (pIndex)
+//                     *pIndex = file_index;
+//                 return MZ_TRUE;
+//             }
+//             else if (comp < 0)
+//                 l = m + 1;
+//             else
+//                 h = m - 1;
+//         }
+//     }
 
-static mz_bool mz_zip_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename, mz_uint32 *pIndex)
-{
-    mz_zip_internal_state *pState = pZip->m_pState;
-    const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
-    const mz_zip_array *pCentral_dir = &pState->m_central_dir;
-    mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
-    const uint32_t size = pZip->m_total_files;
-    const mz_uint filename_len = (mz_uint)strlen(pFilename);
+//     return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
+// }
 
-    if (pIndex)
-        *pIndex = 0;
+// int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
+// {
+//     mz_uint32 index_;
+//     if (!mz_zip_reader_locate_file_v2(pZip, pName, pComment, flags, &index_))
+//         return -1;
+//     else
+//         return (int)index_;
+// }
 
-    if (size)
-    {
-        /* yes I could use uint32_t's, but then we would have to add some special case checks in the loop, argh, and */
-        /* honestly the major expense here on 32-bit CPU's will still be the filename compare */
-        mz_int64 l = 0, h = (mz_int64)size - 1;
+// mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *pIndex)
+// {
+//     mz_uint file_index;
+//     size_t name_len, comment_len;
 
-        while (l <= h)
-        {
-            mz_int64 m = l + ((h - l) >> 1);
-            uint32_t file_index = pIndices[(uint32_t)m];
+//     if (pIndex)
+//         *pIndex = 0;
 
-            int comp = mz_zip_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
-            if (!comp)
-            {
-                if (pIndex)
-                    *pIndex = file_index;
-                return MZ_TRUE;
-            }
-            else if (comp < 0)
-                l = m + 1;
-            else
-                h = m - 1;
-        }
-    }
+//     if ((!pZip) || (!pZip->m_pState) || (!pName))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
-}
+//     /* See if we can use a binary search */
+//     if (((pZip->m_pState->m_init_flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0) &&
+//         (pZip->m_zip_mode == MZ_ZIP_MODE_READING) &&
+//         ((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
+//     {
+//         return mz_zip_locate_file_binary_search(pZip, pName, pIndex);
+//     }
 
-int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
-{
-    mz_uint32 index_;
-    if (!mz_zip_reader_locate_file_v2(pZip, pName, pComment, flags, &index_))
-        return -1;
-    else
-        return (int)index_;
-}
+//     /* Locate the entry by scanning the entire central directory */
+//     name_len = strlen(pName);
+//     if (name_len > MZ_UINT16_MAX)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *pIndex)
-{
-    mz_uint file_index;
-    size_t name_len, comment_len;
+//     comment_len = pComment ? strlen(pComment) : 0;
+//     if (comment_len > MZ_UINT16_MAX)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    if (pIndex)
-        *pIndex = 0;
+//     for (file_index = 0; file_index < pZip->m_total_files; file_index++)
+//     {
+//         const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
+//         mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+//         const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
+//         if (filename_len < name_len)
+//             continue;
+//         if (comment_len)
+//         {
+//             mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
+//             const char *pFile_comment = pFilename + filename_len + file_extra_len;
+//             if ((file_comment_len != comment_len) || (!mz_zip_string_equal(pComment, pFile_comment, file_comment_len, flags)))
+//                 continue;
+//         }
+//         if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))
+//         {
+//             int ofs = filename_len - 1;
+//             do
+//             {
+//                 if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':'))
+//                     break;
+//             } while (--ofs >= 0);
+//             ofs++;
+//             pFilename += ofs;
+//             filename_len -= ofs;
+//         }
+//         if ((filename_len == name_len) && (mz_zip_string_equal(pName, pFilename, filename_len, flags)))
+//         {
+//             if (pIndex)
+//                 *pIndex = file_index;
+//             return MZ_TRUE;
+//         }
+//     }
 
-    if ((!pZip) || (!pZip->m_pState) || (!pName))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
+// }
 
-    /* See if we can use a binary search */
-    if (((pZip->m_pState->m_init_flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0) &&
-        (pZip->m_zip_mode == MZ_ZIP_MODE_READING) &&
-        ((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
-    {
-        return mz_zip_locate_file_binary_search(pZip, pName, pIndex);
-    }
+// mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
+// {
+//     int status = TINFL_STATUS_DONE;
+//     mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
+//     mz_zip_archive_file_stat file_stat;
+//     void *pRead_buf;
+//     mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
+//     mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
+//     tinfl_decompressor inflator;
 
-    /* Locate the entry by scanning the entire central directory */
-    name_len = strlen(pName);
-    if (name_len > MZ_UINT16_MAX)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     if ((!pZip) || (!pZip->m_pState) || ((buf_size) && (!pBuf)) || ((user_read_buf_size) && (!pUser_read_buf)) || (!pZip->m_pRead))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    comment_len = pComment ? strlen(pComment) : 0;
-    if (comment_len > MZ_UINT16_MAX)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
+//         return MZ_FALSE;
 
-    for (file_index = 0; file_index < pZip->m_total_files; file_index++)
-    {
-        const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
-        mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-        const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-        if (filename_len < name_len)
-            continue;
-        if (comment_len)
-        {
-            mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
-            const char *pFile_comment = pFilename + filename_len + file_extra_len;
-            if ((file_comment_len != comment_len) || (!mz_zip_string_equal(pComment, pFile_comment, file_comment_len, flags)))
-                continue;
-        }
-        if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))
-        {
-            int ofs = filename_len - 1;
-            do
-            {
-                if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':'))
-                    break;
-            } while (--ofs >= 0);
-            ofs++;
-            pFilename += ofs;
-            filename_len -= ofs;
-        }
-        if ((filename_len == name_len) && (mz_zip_string_equal(pName, pFilename, filename_len, flags)))
-        {
-            if (pIndex)
-                *pIndex = file_index;
-            return MZ_TRUE;
-        }
-    }
+//     /* A directory or zero length file */
+//     if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
+//         return MZ_TRUE;
 
-    return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
-}
+//     /* Encryption and patch files are not supported. */
+//     if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
 
-mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
-{
-    int status = TINFL_STATUS_DONE;
-    mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
-    mz_zip_archive_file_stat file_stat;
-    void *pRead_buf;
-    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
-    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
-    tinfl_decompressor inflator;
-
-    if ((!pZip) || (!pZip->m_pState) || ((buf_size) && (!pBuf)) || ((user_read_buf_size) && (!pUser_read_buf)) || (!pZip->m_pRead))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-
-    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
-        return MZ_FALSE;
-
-    /* A directory or zero length file */
-    if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
-        return MZ_TRUE;
-
-    /* Encryption and patch files are not supported. */
-    if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
-
-    /* This function only supports decompressing stored and deflate. */
-    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
-
-    /* Ensure supplied output buffer is large enough. */
-    needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
-    if (buf_size < needed_size)
-        return mz_zip_set_error(pZip, MZ_ZIP_BUF_TOO_SMALL);
-
-    /* Read and parse the local directory entry. */
-    cur_file_ofs = file_stat.m_local_header_ofs;
-    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
-
-    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
-
-    cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
-    if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
-
-    if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
-    {
-        /* The file is stored or the caller has requested the compressed data. */
-        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
+//     /* This function only supports decompressing stored and deflate. */
+//     if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
 
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) == 0)
-        {
-            if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
-                return mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
-        }
-#endif
+//     /* Ensure supplied output buffer is large enough. */
+//     needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
+//     if (buf_size < needed_size)
+//         return mz_zip_set_error(pZip, MZ_ZIP_BUF_TOO_SMALL);
 
-        return MZ_TRUE;
-    }
+//     /* Read and parse the local directory entry. */
+//     cur_file_ofs = file_stat.m_local_header_ofs;
+//     if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
 
-    /* Decompress the file either directly from memory or from a file input buffer. */
-    tinfl_init(&inflator);
+//     if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-    if (pZip->m_pState->m_pMem)
-    {
-        /* Read directly from the archive in memory. */
-        pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
-        read_buf_size = read_buf_avail = file_stat.m_comp_size;
-        comp_remaining = 0;
-    }
-    else if (pUser_read_buf)
-    {
-        /* Use a user provided read buffer. */
-        if (!user_read_buf_size)
-            return MZ_FALSE;
-        pRead_buf = (mz_uint8 *)pUser_read_buf;
-        read_buf_size = user_read_buf_size;
-        read_buf_avail = 0;
-        comp_remaining = file_stat.m_comp_size;
-    }
-    else
-    {
-        /* Temporarily allocate a read buffer. */
-        read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
-        if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
-            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
+//     cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
+//     if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-        if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
-            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//     if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
+//     {
+//         /* The file is stored or the caller has requested the compressed data. */
+//         if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
 
-        read_buf_avail = 0;
-        comp_remaining = file_stat.m_comp_size;
-    }
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//         if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) == 0)
+//         {
+//             if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
+//                 return mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
+//         }
+// #endif
 
-    do
-    {
-        /* The size_t cast here should be OK because we've verified that the output buffer is >= file_stat.m_uncomp_size above */
-        size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
-        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
-        {
-            read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
-            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
-            {
-                status = TINFL_STATUS_FAILED;
-                mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
-                break;
-            }
-            cur_file_ofs += read_buf_avail;
-            comp_remaining -= read_buf_avail;
-            read_buf_ofs = 0;
-        }
-        in_buf_size = (size_t)read_buf_avail;
-        status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
-        read_buf_avail -= in_buf_size;
-        read_buf_ofs += in_buf_size;
-        out_buf_ofs += out_buf_size;
-    } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);
-
-    if (status == TINFL_STATUS_DONE)
-    {
-        /* Make sure the entire file was decompressed, and check its CRC. */
-        if (out_buf_ofs != file_stat.m_uncomp_size)
-        {
-            mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
-            status = TINFL_STATUS_FAILED;
-        }
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-        else if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
-        {
-            mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
-            status = TINFL_STATUS_FAILED;
-        }
-#endif
-    }
+//         return MZ_TRUE;
+//     }
 
-    if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+//     /* Decompress the file either directly from memory or from a file input buffer. */
+//     tinfl_init(&inflator);
 
-    return status == TINFL_STATUS_DONE;
-}
+//     if (pZip->m_pState->m_pMem)
+//     {
+//         /* Read directly from the archive in memory. */
+//         pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
+//         read_buf_size = read_buf_avail = file_stat.m_comp_size;
+//         comp_remaining = 0;
+//     }
+//     else if (pUser_read_buf)
+//     {
+//         /* Use a user provided read buffer. */
+//         if (!user_read_buf_size)
+//             return MZ_FALSE;
+//         pRead_buf = (mz_uint8 *)pUser_read_buf;
+//         read_buf_size = user_read_buf_size;
+//         read_buf_avail = 0;
+//         comp_remaining = file_stat.m_comp_size;
+//     }
+//     else
+//     {
+//         /* Temporarily allocate a read buffer. */
+//         read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
+//         if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
+//             return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
 
-mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
-{
-    mz_uint32 file_index;
-    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
-        return MZ_FALSE;
-    return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size);
-}
+//         if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
+//             return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
 
-mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)
-{
-    return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, NULL, 0);
-}
+//         read_buf_avail = 0;
+//         comp_remaining = file_stat.m_comp_size;
+//     }
 
-mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)
-{
-    return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
-}
+//     do
+//     {
+//         /* The size_t cast here should be OK because we've verified that the output buffer is >= file_stat.m_uncomp_size above */
+//         size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
+//         if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
+//         {
+//             read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
+//             if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
+//             {
+//                 status = TINFL_STATUS_FAILED;
+//                 mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
+//                 break;
+//             }
+//             cur_file_ofs += read_buf_avail;
+//             comp_remaining -= read_buf_avail;
+//             read_buf_ofs = 0;
+//         }
+//         in_buf_size = (size_t)read_buf_avail;
+//         status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
+//         read_buf_avail -= in_buf_size;
+//         read_buf_ofs += in_buf_size;
+//         out_buf_ofs += out_buf_size;
+//     } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);
+
+//     if (status == TINFL_STATUS_DONE)
+//     {
+//         /* Make sure the entire file was decompressed, and check its CRC. */
+//         if (out_buf_ofs != file_stat.m_uncomp_size)
+//         {
+//             mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
+//             status = TINFL_STATUS_FAILED;
+//         }
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//         else if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
+//         {
+//             mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
+//             status = TINFL_STATUS_FAILED;
+//         }
+// #endif
+//     }
 
-void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
-{
-    mz_uint64 comp_size, uncomp_size, alloc_size;
-    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
-    void *pBuf;
+//     if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
 
-    if (pSize)
-        *pSize = 0;
+//     return status == TINFL_STATUS_DONE;
+// }
 
-    if (!p)
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-        return NULL;
-    }
+// mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
+// {
+//     mz_uint32 file_index;
+//     if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
+//         return MZ_FALSE;
+//     return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size);
+// }
 
-    comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-    uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
+// mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)
+// {
+//     return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, NULL, 0);
+// }
 
-    alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;
-    if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
-        return NULL;
-    }
+// mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)
+// {
+//     return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
+// }
 
-    if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-        return NULL;
-    }
+// void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
+// {
+//     mz_uint64 comp_size, uncomp_size, alloc_size;
+//     const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
+//     void *pBuf;
 
-    if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size, flags))
-    {
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-        return NULL;
-    }
+//     if (pSize)
+//         *pSize = 0;
 
-    if (pSize)
-        *pSize = (size_t)alloc_size;
-    return pBuf;
-}
+//     if (!p)
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//         return NULL;
+//     }
 
-void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)
-{
-    mz_uint32 file_index;
-    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
-    {
-        if (pSize)
-            *pSize = 0;
-        return MZ_FALSE;
-    }
-    return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
-}
+//     comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
+//     uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
 
-mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
-{
-    int status = TINFL_STATUS_DONE;
-    mz_uint file_crc32 = MZ_CRC32_INIT;
-    mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
-    mz_zip_archive_file_stat file_stat;
-    void *pRead_buf = NULL;
-    void *pWrite_buf = NULL;
-    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
-    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
-
-    if ((!pZip) || (!pZip->m_pState) || (!pCallback) || (!pZip->m_pRead))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-
-    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
-        return MZ_FALSE;
-
-    /* A directory or zero length file */
-    if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
-        return MZ_TRUE;
-
-    /* Encryption and patch files are not supported. */
-    if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
-
-    /* This function only supports decompressing stored and deflate. */
-    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
-
-    /* Read and do some minimal validation of the local directory entry (this doesn't crack the zip64 stuff, which we already have from the central dir) */
-    cur_file_ofs = file_stat.m_local_header_ofs;
-    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
-
-    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
-
-    cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
-    if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
-
-    /* Decompress the file either directly from memory or from a file input buffer. */
-    if (pZip->m_pState->m_pMem)
-    {
-        pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
-        read_buf_size = read_buf_avail = file_stat.m_comp_size;
-        comp_remaining = 0;
-    }
-    else
-    {
-        read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
-        if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
-            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//     alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;
+//     if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
+//         return NULL;
+//     }
 
-        read_buf_avail = 0;
-        comp_remaining = file_stat.m_comp_size;
-    }
+//     if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//         return NULL;
+//     }
 
-    if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
-    {
-        /* The file is stored or the caller has requested the compressed data. */
-        if (pZip->m_pState->m_pMem)
-        {
-            if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > MZ_UINT32_MAX))
-                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
+//     if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size, flags))
+//     {
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
+//         return NULL;
+//     }
 
-            if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
-            {
-                mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
-                status = TINFL_STATUS_FAILED;
-            }
-            else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-            {
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-                file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);
-#endif
-            }
+//     if (pSize)
+//         *pSize = (size_t)alloc_size;
+//     return pBuf;
+// }
 
-            cur_file_ofs += file_stat.m_comp_size;
-            out_buf_ofs += file_stat.m_comp_size;
-            comp_remaining = 0;
-        }
-        else
-        {
-            while (comp_remaining)
-            {
-                read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
-                if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
-                {
-                    mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
-                    status = TINFL_STATUS_FAILED;
-                    break;
-                }
+// void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)
+// {
+//     mz_uint32 file_index;
+//     if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
+//     {
+//         if (pSize)
+//             *pSize = 0;
+//         return MZ_FALSE;
+//     }
+//     return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
+// }
 
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-                if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-                {
-                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);
-                }
-#endif
+// mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
+// {
+//     int status = TINFL_STATUS_DONE;
+//     mz_uint file_crc32 = MZ_CRC32_INIT;
+//     mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
+//     mz_zip_archive_file_stat file_stat;
+//     void *pRead_buf = NULL;
+//     void *pWrite_buf = NULL;
+//     mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
+//     mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
 
-                if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
-                {
-                    mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
-                    status = TINFL_STATUS_FAILED;
-                    break;
-                }
+//     if ((!pZip) || (!pZip->m_pState) || (!pCallback) || (!pZip->m_pRead))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-                cur_file_ofs += read_buf_avail;
-                out_buf_ofs += read_buf_avail;
-                comp_remaining -= read_buf_avail;
-            }
-        }
-    }
-    else
-    {
-        tinfl_decompressor inflator;
-        tinfl_init(&inflator);
+//     if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
+//         return MZ_FALSE;
 
-        if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
-        {
-            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-            status = TINFL_STATUS_FAILED;
-        }
-        else
-        {
-            do
-            {
-                mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
-                size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
-                if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
-                {
-                    read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
-                    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
-                    {
-                        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
-                        status = TINFL_STATUS_FAILED;
-                        break;
-                    }
-                    cur_file_ofs += read_buf_avail;
-                    comp_remaining -= read_buf_avail;
-                    read_buf_ofs = 0;
-                }
+//     /* A directory or zero length file */
+//     if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
+//         return MZ_TRUE;
 
-                in_buf_size = (size_t)read_buf_avail;
-                status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
-                read_buf_avail -= in_buf_size;
-                read_buf_ofs += in_buf_size;
+//     /* Encryption and patch files are not supported. */
+//     if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
 
-                if (out_buf_size)
-                {
-                    if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)
-                    {
-                        mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
-                        status = TINFL_STATUS_FAILED;
-                        break;
-                    }
+//     /* This function only supports decompressing stored and deflate. */
+//     if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
 
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
-#endif
-                    if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)
-                    {
-                        mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
-                        status = TINFL_STATUS_FAILED;
-                        break;
-                    }
-                }
-            } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
-        }
-    }
+//     /* Read and do some minimal validation of the local directory entry (this doesn't crack the zip64 stuff, which we already have from the central dir) */
+//     cur_file_ofs = file_stat.m_local_header_ofs;
+//     if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
 
-    if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
-    {
-        /* Make sure the entire file was decompressed, and check its CRC. */
-        if (out_buf_ofs != file_stat.m_uncomp_size)
-        {
-            mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
-            status = TINFL_STATUS_FAILED;
-        }
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-        else if (file_crc32 != file_stat.m_crc32)
-        {
-            mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
-            status = TINFL_STATUS_FAILED;
-        }
-#endif
-    }
+//     if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-    if (!pZip->m_pState->m_pMem)
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+//     cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
+//     if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
 
-    if (pWrite_buf)
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);
+//     /* Decompress the file either directly from memory or from a file input buffer. */
+//     if (pZip->m_pState->m_pMem)
+//     {
+//         pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
+//         read_buf_size = read_buf_avail = file_stat.m_comp_size;
+//         comp_remaining = 0;
+//     }
+//     else
+//     {
+//         read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
+//         if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
+//             return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
 
-    return status == TINFL_STATUS_DONE;
-}
+//         read_buf_avail = 0;
+//         comp_remaining = file_stat.m_comp_size;
+//     }
 
-mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
-{
-    mz_uint32 file_index;
-    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
-        return MZ_FALSE;
+//     if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
+//     {
+//         /* The file is stored or the caller has requested the compressed data. */
+//         if (pZip->m_pState->m_pMem)
+//         {
+//             if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > MZ_UINT32_MAX))
+//                 return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
 
-    return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
-}
+//             if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
+//             {
+//                 mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
+//                 status = TINFL_STATUS_FAILED;
+//             }
+//             else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
+//             {
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//                 file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);
+// #endif
+//             }
 
-mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
-{
-    mz_zip_reader_extract_iter_state *pState;
-    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
-    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
+//             cur_file_ofs += file_stat.m_comp_size;
+//             out_buf_ofs += file_stat.m_comp_size;
+//             comp_remaining = 0;
+//         }
+//         else
+//         {
+//             while (comp_remaining)
+//             {
+//                 read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
+//                 if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
+//                 {
+//                     mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
+//                     status = TINFL_STATUS_FAILED;
+//                     break;
+//                 }
 
-    /* Argument sanity check */
-    if ((!pZip) || (!pZip->m_pState))
-        return NULL;
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//                 if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
+//                 {
+//                     file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);
+//                 }
+// #endif
 
-    /* Allocate an iterator status structure */
-    pState = (mz_zip_reader_extract_iter_state*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_reader_extract_iter_state));
-    if (!pState)
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-        return NULL;
-    }
+//                 if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
+//                 {
+//                     mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
+//                     status = TINFL_STATUS_FAILED;
+//                     break;
+//                 }
 
-    /* Fetch file details */
-    if (!mz_zip_reader_file_stat(pZip, file_index, &pState->file_stat))
-    {
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-        return NULL;
-    }
+//                 cur_file_ofs += read_buf_avail;
+//                 out_buf_ofs += read_buf_avail;
+//                 comp_remaining -= read_buf_avail;
+//             }
+//         }
+//     }
+//     else
+//     {
+//         tinfl_decompressor inflator;
+//         tinfl_init(&inflator);
 
-    /* Encryption and patch files are not supported. */
-    if (pState->file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-        return NULL;
-    }
+//         if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
+//         {
+//             mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//             status = TINFL_STATUS_FAILED;
+//         }
+//         else
+//         {
+//             do
+//             {
+//                 mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
+//                 size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
+//                 if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
+//                 {
+//                     read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
+//                     if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
+//                     {
+//                         mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
+//                         status = TINFL_STATUS_FAILED;
+//                         break;
+//                     }
+//                     cur_file_ofs += read_buf_avail;
+//                     comp_remaining -= read_buf_avail;
+//                     read_buf_ofs = 0;
+//                 }
 
-    /* This function only supports decompressing stored and deflate. */
-    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (pState->file_stat.m_method != 0) && (pState->file_stat.m_method != MZ_DEFLATED))
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-        return NULL;
-    }
+//                 in_buf_size = (size_t)read_buf_avail;
+//                 status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
+//                 read_buf_avail -= in_buf_size;
+//                 read_buf_ofs += in_buf_size;
 
-    /* Init state - save args */
-    pState->pZip = pZip;
-    pState->flags = flags;
+//                 if (out_buf_size)
+//                 {
+//                     if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)
+//                     {
+//                         mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
+//                         status = TINFL_STATUS_FAILED;
+//                         break;
+//                     }
+
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//                     file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
+// #endif
+//                     if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)
+//                     {
+//                         mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
+//                         status = TINFL_STATUS_FAILED;
+//                         break;
+//                     }
+//                 }
+//             } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
+//         }
+//     }
 
-    /* Init state - reset variables to defaults */
-    pState->status = TINFL_STATUS_DONE;
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-    pState->file_crc32 = MZ_CRC32_INIT;
-#endif
-    pState->read_buf_ofs = 0;
-    pState->out_buf_ofs = 0;
-    pState->pRead_buf = NULL;
-    pState->pWrite_buf = NULL;
-    pState->out_blk_remain = 0;
-
-    /* Read and parse the local directory entry. */
-    pState->cur_file_ofs = pState->file_stat.m_local_header_ofs;
-    if (pZip->m_pRead(pZip->m_pIO_opaque, pState->cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-        return NULL;
-    }
+//     if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
+//     {
+//         /* Make sure the entire file was decompressed, and check its CRC. */
+//         if (out_buf_ofs != file_stat.m_uncomp_size)
+//         {
+//             mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
+//             status = TINFL_STATUS_FAILED;
+//         }
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//         else if (file_crc32 != file_stat.m_crc32)
+//         {
+//             mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
+//             status = TINFL_STATUS_FAILED;
+//         }
+// #endif
+//     }
 
-    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-        return NULL;
-    }
+//     if (!pZip->m_pState->m_pMem)
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
 
-    pState->cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
-    if ((pState->cur_file_ofs + pState->file_stat.m_comp_size) > pZip->m_archive_size)
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-        return NULL;
-    }
+//     if (pWrite_buf)
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);
 
-    /* Decompress the file either directly from memory or from a file input buffer. */
-    if (pZip->m_pState->m_pMem)
-    {
-        pState->pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + pState->cur_file_ofs;
-        pState->read_buf_size = pState->read_buf_avail = pState->file_stat.m_comp_size;
-        pState->comp_remaining = pState->file_stat.m_comp_size;
-    }
-    else
-    {
-        if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
-        {
-            /* Decompression required, therefore intermediate read buffer required */
-            pState->read_buf_size = MZ_MIN(pState->file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
-            if (NULL == (pState->pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)pState->read_buf_size)))
-            {
-                mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-                return NULL;
-            }
-        }
-        else
-        {
-            /* Decompression not required - we will be reading directly into user buffer, no temp buf required */
-            pState->read_buf_size = 0;
-        }
-        pState->read_buf_avail = 0;
-        pState->comp_remaining = pState->file_stat.m_comp_size;
-    }
+//     return status == TINFL_STATUS_DONE;
+// }
+
+// mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
+// {
+//     mz_uint32 file_index;
+//     if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
+//         return MZ_FALSE;
+
+//     return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
+// }
+
+// mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
+// {
+//     mz_zip_reader_extract_iter_state *pState;
+//     mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
+//     mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
+
+//     /* Argument sanity check */
+//     if ((!pZip) || (!pZip->m_pState))
+//         return NULL;
+
+//     /* Allocate an iterator status structure */
+//     pState = (mz_zip_reader_extract_iter_state*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_reader_extract_iter_state));
+//     if (!pState)
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//         return NULL;
+//     }
+
+//     /* Fetch file details */
+//     if (!mz_zip_reader_file_stat(pZip, file_index, &pState->file_stat))
+//     {
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//         return NULL;
+//     }
+
+//     /* Encryption and patch files are not supported. */
+//     if (pState->file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//         return NULL;
+//     }
+
+//     /* This function only supports decompressing stored and deflate. */
+//     if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (pState->file_stat.m_method != 0) && (pState->file_stat.m_method != MZ_DEFLATED))
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//         return NULL;
+//     }
+
+//     /* Init state - save args */
+//     pState->pZip = pZip;
+//     pState->flags = flags;
+
+//     /* Init state - reset variables to defaults */
+//     pState->status = TINFL_STATUS_DONE;
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//     pState->file_crc32 = MZ_CRC32_INIT;
+// #endif
+//     pState->read_buf_ofs = 0;
+//     pState->out_buf_ofs = 0;
+//     pState->pRead_buf = NULL;
+//     pState->pWrite_buf = NULL;
+//     pState->out_blk_remain = 0;
+
+//     /* Read and parse the local directory entry. */
+//     pState->cur_file_ofs = pState->file_stat.m_local_header_ofs;
+//     if (pZip->m_pRead(pZip->m_pIO_opaque, pState->cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//         return NULL;
+//     }
+
+//     if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//         return NULL;
+//     }
+
+//     pState->cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
+//     if ((pState->cur_file_ofs + pState->file_stat.m_comp_size) > pZip->m_archive_size)
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//         return NULL;
+//     }
 
-    if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
-    {
-        /* Decompression required, init decompressor */
-        tinfl_init( &pState->inflator );
+//     /* Decompress the file either directly from memory or from a file input buffer. */
+//     if (pZip->m_pState->m_pMem)
+//     {
+//         pState->pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + pState->cur_file_ofs;
+//         pState->read_buf_size = pState->read_buf_avail = pState->file_stat.m_comp_size;
+//         pState->comp_remaining = pState->file_stat.m_comp_size;
+//     }
+//     else
+//     {
+//         if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
+//         {
+//             /* Decompression required, therefore intermediate read buffer required */
+//             pState->read_buf_size = MZ_MIN(pState->file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
+//             if (NULL == (pState->pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)pState->read_buf_size)))
+//             {
+//                 mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//                 pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//                 return NULL;
+//             }
+//         }
+//         else
+//         {
+//             /* Decompression not required - we will be reading directly into user buffer, no temp buf required */
+//             pState->read_buf_size = 0;
+//         }
+//         pState->read_buf_avail = 0;
+//         pState->comp_remaining = pState->file_stat.m_comp_size;
+//     }
 
-        /* Allocate write buffer */
-        if (NULL == (pState->pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
-        {
-            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-            if (pState->pRead_buf)
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pState->pRead_buf);
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-            return NULL;
-        }
-    }
+//     if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
+//     {
+//         /* Decompression required, init decompressor */
+//         tinfl_init( &pState->inflator );
 
-    return pState;
-}
+//         /* Allocate write buffer */
+//         if (NULL == (pState->pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
+//         {
+//             mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//             if (pState->pRead_buf)
+//                 pZip->m_pFree(pZip->m_pAlloc_opaque, pState->pRead_buf);
+//             pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//             return NULL;
+//         }
+//     }
 
-mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
-{
-    mz_uint32 file_index;
+//     return pState;
+// }
 
-    /* Locate file index by name */
-    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
-        return NULL;
+// mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
+// {
+//     mz_uint32 file_index;
 
-    /* Construct iterator */
-    return mz_zip_reader_extract_iter_new(pZip, file_index, flags);
-}
+//     /* Locate file index by name */
+//     if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
+//         return NULL;
 
-size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size)
-{
-    size_t copied_to_caller = 0;
+//     /* Construct iterator */
+//     return mz_zip_reader_extract_iter_new(pZip, file_index, flags);
+// }
 
-    /* Argument sanity check */
-    if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState) || (!pvBuf))
-        return 0;
+// size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size)
+// {
+//     size_t copied_to_caller = 0;
 
-    if ((pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method))
-    {
-        /* The file is stored or the caller has requested the compressed data, calc amount to return. */
-        copied_to_caller = MZ_MIN( buf_size, pState->comp_remaining );
+//     /* Argument sanity check */
+//     if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState) || (!pvBuf))
+//         return 0;
 
-        /* Zip is in memory....or requires reading from a file? */
-        if (pState->pZip->m_pState->m_pMem)
-        {
-            /* Copy data to caller's buffer */
-            memcpy( pvBuf, pState->pRead_buf, copied_to_caller );
-            pState->pRead_buf = ((mz_uint8*)pState->pRead_buf) + copied_to_caller;
-        }
-        else
-        {
-            /* Read directly into caller's buffer */
-            if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pvBuf, copied_to_caller) != copied_to_caller)
-            {
-                /* Failed to read all that was asked for, flag failure and alert user */
-                mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
-                pState->status = TINFL_STATUS_FAILED;
-                copied_to_caller = 0;
-            }
-        }
+//     if ((pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method))
+//     {
+//         /* The file is stored or the caller has requested the compressed data, calc amount to return. */
+//         copied_to_caller = MZ_MIN( buf_size, pState->comp_remaining );
 
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-        /* Compute CRC if not returning compressed data only */
-        if (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-            pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, (const mz_uint8 *)pvBuf, copied_to_caller);
-#endif
+//         /* Zip is in memory....or requires reading from a file? */
+//         if (pState->pZip->m_pState->m_pMem)
+//         {
+//             /* Copy data to caller's buffer */
+//             memcpy( pvBuf, pState->pRead_buf, copied_to_caller );
+//             pState->pRead_buf = ((mz_uint8*)pState->pRead_buf) + copied_to_caller;
+//         }
+//         else
+//         {
+//             /* Read directly into caller's buffer */
+//             if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pvBuf, copied_to_caller) != copied_to_caller)
+//             {
+//                 /* Failed to read all that was asked for, flag failure and alert user */
+//                 mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
+//                 pState->status = TINFL_STATUS_FAILED;
+//                 copied_to_caller = 0;
+//             }
+//         }
 
-        /* Advance offsets, dec counters */
-        pState->cur_file_ofs += copied_to_caller;
-        pState->out_buf_ofs += copied_to_caller;
-        pState->comp_remaining -= copied_to_caller;
-    }
-    else
-    {
-        do
-        {
-            /* Calc ptr to write buffer - given current output pos and block size */
-            mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pState->pWrite_buf + (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//         /* Compute CRC if not returning compressed data only */
+//         if (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
+//             pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, (const mz_uint8 *)pvBuf, copied_to_caller);
+// #endif
 
-            /* Calc max output size - given current output pos and block size */
-            size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
+//         /* Advance offsets, dec counters */
+//         pState->cur_file_ofs += copied_to_caller;
+//         pState->out_buf_ofs += copied_to_caller;
+//         pState->comp_remaining -= copied_to_caller;
+//     }
+//     else
+//     {
+//         do
+//         {
+//             /* Calc ptr to write buffer - given current output pos and block size */
+//             mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pState->pWrite_buf + (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
 
-            if (!pState->out_blk_remain)
-            {
-                /* Read more data from file if none available (and reading from file) */
-                if ((!pState->read_buf_avail) && (!pState->pZip->m_pState->m_pMem))
-                {
-                    /* Calc read size */
-                    pState->read_buf_avail = MZ_MIN(pState->read_buf_size, pState->comp_remaining);
-                    if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pState->pRead_buf, (size_t)pState->read_buf_avail) != pState->read_buf_avail)
-                    {
-                        mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
-                        pState->status = TINFL_STATUS_FAILED;
-                        break;
-                    }
+//             /* Calc max output size - given current output pos and block size */
+//             size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
 
-                    /* Advance offsets, dec counters */
-                    pState->cur_file_ofs += pState->read_buf_avail;
-                    pState->comp_remaining -= pState->read_buf_avail;
-                    pState->read_buf_ofs = 0;
-                }
+//             if (!pState->out_blk_remain)
+//             {
+//                 /* Read more data from file if none available (and reading from file) */
+//                 if ((!pState->read_buf_avail) && (!pState->pZip->m_pState->m_pMem))
+//                 {
+//                     /* Calc read size */
+//                     pState->read_buf_avail = MZ_MIN(pState->read_buf_size, pState->comp_remaining);
+//                     if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pState->pRead_buf, (size_t)pState->read_buf_avail) != pState->read_buf_avail)
+//                     {
+//                         mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
+//                         pState->status = TINFL_STATUS_FAILED;
+//                         break;
+//                     }
+
+//                     /* Advance offsets, dec counters */
+//                     pState->cur_file_ofs += pState->read_buf_avail;
+//                     pState->comp_remaining -= pState->read_buf_avail;
+//                     pState->read_buf_ofs = 0;
+//                 }
 
-                /* Perform decompression */
-                in_buf_size = (size_t)pState->read_buf_avail;
-                pState->status = tinfl_decompress(&pState->inflator, (const mz_uint8 *)pState->pRead_buf + pState->read_buf_ofs, &in_buf_size, (mz_uint8 *)pState->pWrite_buf, pWrite_buf_cur, &out_buf_size, pState->comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
-                pState->read_buf_avail -= in_buf_size;
-                pState->read_buf_ofs += in_buf_size;
+//                 /* Perform decompression */
+//                 in_buf_size = (size_t)pState->read_buf_avail;
+//                 pState->status = tinfl_decompress(&pState->inflator, (const mz_uint8 *)pState->pRead_buf + pState->read_buf_ofs, &in_buf_size, (mz_uint8 *)pState->pWrite_buf, pWrite_buf_cur, &out_buf_size, pState->comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
+//                 pState->read_buf_avail -= in_buf_size;
+//                 pState->read_buf_ofs += in_buf_size;
 
-                /* Update current output block size remaining */
-                pState->out_blk_remain = out_buf_size;
-            }
+//                 /* Update current output block size remaining */
+//                 pState->out_blk_remain = out_buf_size;
+//             }
 
-            if (pState->out_blk_remain)
-            {
-                /* Calc amount to return. */
-                size_t to_copy = MZ_MIN( (buf_size - copied_to_caller), pState->out_blk_remain );
+//             if (pState->out_blk_remain)
+//             {
+//                 /* Calc amount to return. */
+//                 size_t to_copy = MZ_MIN( (buf_size - copied_to_caller), pState->out_blk_remain );
 
-                /* Copy data to caller's buffer */
-                memcpy( (uint8_t*)pvBuf + copied_to_caller, pWrite_buf_cur, to_copy );
+//                 /* Copy data to caller's buffer */
+//                 memcpy( (uint8_t*)pvBuf + copied_to_caller, pWrite_buf_cur, to_copy );
 
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-                /* Perform CRC */
-                pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, pWrite_buf_cur, to_copy);
-#endif
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//                 /* Perform CRC */
+//                 pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, pWrite_buf_cur, to_copy);
+// #endif
 
-                /* Decrement data consumed from block */
-                pState->out_blk_remain -= to_copy;
+//                 /* Decrement data consumed from block */
+//                 pState->out_blk_remain -= to_copy;
 
-                /* Inc output offset, while performing sanity check */
-                if ((pState->out_buf_ofs += to_copy) > pState->file_stat.m_uncomp_size)
-                {
-                    mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
-                    pState->status = TINFL_STATUS_FAILED;
-                    break;
-                }
+//                 /* Inc output offset, while performing sanity check */
+//                 if ((pState->out_buf_ofs += to_copy) > pState->file_stat.m_uncomp_size)
+//                 {
+//                     mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
+//                     pState->status = TINFL_STATUS_FAILED;
+//                     break;
+//                 }
 
-                /* Increment counter of data copied to caller */
-                copied_to_caller += to_copy;
-            }
-        } while ( (copied_to_caller < buf_size) && ((pState->status == TINFL_STATUS_NEEDS_MORE_INPUT) || (pState->status == TINFL_STATUS_HAS_MORE_OUTPUT)) );
-    }
+//                 /* Increment counter of data copied to caller */
+//                 copied_to_caller += to_copy;
+//             }
+//         } while ( (copied_to_caller < buf_size) && ((pState->status == TINFL_STATUS_NEEDS_MORE_INPUT) || (pState->status == TINFL_STATUS_HAS_MORE_OUTPUT)) );
+//     }
 
-    /* Return how many bytes were copied into user buffer */
-    return copied_to_caller;
-}
+//     /* Return how many bytes were copied into user buffer */
+//     return copied_to_caller;
+// }
 
-mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState)
-{
-    int status;
+// mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState)
+// {
+//     int status;
 
-    /* Argument sanity check */
-    if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState))
-        return MZ_FALSE;
+//     /* Argument sanity check */
+//     if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState))
+//         return MZ_FALSE;
 
-    /* Was decompression completed and requested? */
-    if ((pState->status == TINFL_STATUS_DONE) && (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
-    {
-        /* Make sure the entire file was decompressed, and check its CRC. */
-        if (pState->out_buf_ofs != pState->file_stat.m_uncomp_size)
-        {
-            mz_zip_set_error(pState->pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
-            pState->status = TINFL_STATUS_FAILED;
-        }
-#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
-        else if (pState->file_crc32 != pState->file_stat.m_crc32)
-        {
-            mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
-            pState->status = TINFL_STATUS_FAILED;
-        }
-#endif
-    }
+//     /* Was decompression completed and requested? */
+//     if ((pState->status == TINFL_STATUS_DONE) && (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
+//     {
+//         /* Make sure the entire file was decompressed, and check its CRC. */
+//         if (pState->out_buf_ofs != pState->file_stat.m_uncomp_size)
+//         {
+//             mz_zip_set_error(pState->pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
+//             pState->status = TINFL_STATUS_FAILED;
+//         }
+// #ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
+//         else if (pState->file_crc32 != pState->file_stat.m_crc32)
+//         {
+//             mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
+//             pState->status = TINFL_STATUS_FAILED;
+//         }
+// #endif
+//     }
 
-    /* Free buffers */
-    if (!pState->pZip->m_pState->m_pMem)
-        pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pRead_buf);
-    if (pState->pWrite_buf)
-        pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pWrite_buf);
+//     /* Free buffers */
+//     if (!pState->pZip->m_pState->m_pMem)
+//         pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pRead_buf);
+//     if (pState->pWrite_buf)
+//         pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pWrite_buf);
 
-    /* Save status */
-    status = pState->status;
+//     /* Save status */
+//     status = pState->status;
 
-    /* Free context */
-    pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState);
+//     /* Free context */
+//     pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState);
 
-    return status == TINFL_STATUS_DONE;
-}
+//     return status == TINFL_STATUS_DONE;
+// }
 
-#ifndef MINIZ_NO_STDIO
-static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)
-{
-    (void)ofs;
+// #ifndef MINIZ_NO_STDIO
+// static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)
+// {
+//     (void)ofs;
 
-    return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);
-}
+//     return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);
+// }
 
-mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)
-{
-    mz_bool status;
-    mz_zip_archive_file_stat file_stat;
-    MZ_FILE *pFile;
+// mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)
+// {
+//     mz_bool status;
+//     mz_zip_archive_file_stat file_stat;
+//     MZ_FILE *pFile;
 
-    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
-        return MZ_FALSE;
+//     if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
+//         return MZ_FALSE;
 
-    if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
+//     if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
 
-    pFile = MZ_FOPEN(pDst_filename, "wb");
-    if (!pFile)
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
+//     pFile = MZ_FOPEN(pDst_filename, "wb");
+//     if (!pFile)
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
 
-    status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
+//     status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
 
-    if (MZ_FCLOSE(pFile) == EOF)
-    {
-        if (status)
-            mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
+//     if (MZ_FCLOSE(pFile) == EOF)
+//     {
+//         if (status)
+//             mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
 
-        status = MZ_FALSE;
-    }
+//         status = MZ_FALSE;
+//     }
 
-#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
-    if (status)
-        mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
-#endif
+// #if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
+//     if (status)
+//         mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
+// #endif
 
-    return status;
-}
+//     return status;
+// }
 
-mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)
-{
-    mz_uint32 file_index;
-    if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
-        return MZ_FALSE;
+// mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)
+// {
+//     mz_uint32 file_index;
+//     if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
+//         return MZ_FALSE;
 
-    return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
-}
+//     return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
+// }
 
-mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *pFile, mz_uint flags)
-{
-    mz_zip_archive_file_stat file_stat;
+// mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *pFile, mz_uint flags)
+// {
+//     mz_zip_archive_file_stat file_stat;
 
-    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
-        return MZ_FALSE;
+//     if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
+//         return MZ_FALSE;
 
-    if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
+//     if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
 
-    return mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
-}
+//     return mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
+// }
 
-mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags)
-{
-    mz_uint32 file_index;
-    if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
-        return MZ_FALSE;
+// mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags)
+// {
+//     mz_uint32 file_index;
+//     if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
+//         return MZ_FALSE;
 
-    return mz_zip_reader_extract_to_cfile(pZip, file_index, pFile, flags);
-}
-#endif /* #ifndef MINIZ_NO_STDIO */
+//     return mz_zip_reader_extract_to_cfile(pZip, file_index, pFile, flags);
+// }
+// #endif /* #ifndef MINIZ_NO_STDIO */
 
 // static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
 // {
@@ -5444,1202 +5443,1202 @@ mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pA
 
 /* ------------------- .ZIP archive writing */
 
-#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
+// #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
 
-static MZ_FORCEINLINE void mz_write_le16(mz_uint8 *p, mz_uint16 v)
-{
-    p[0] = (mz_uint8)v;
-    p[1] = (mz_uint8)(v >> 8);
-}
-static MZ_FORCEINLINE void mz_write_le32(mz_uint8 *p, mz_uint32 v)
-{
-    p[0] = (mz_uint8)v;
-    p[1] = (mz_uint8)(v >> 8);
-    p[2] = (mz_uint8)(v >> 16);
-    p[3] = (mz_uint8)(v >> 24);
-}
-static MZ_FORCEINLINE void mz_write_le64(mz_uint8 *p, mz_uint64 v)
-{
-    mz_write_le32(p, (mz_uint32)v);
-    mz_write_le32(p + sizeof(mz_uint32), (mz_uint32)(v >> 32));
-}
+// static MZ_FORCEINLINE void mz_write_le16(mz_uint8 *p, mz_uint16 v)
+// {
+//     p[0] = (mz_uint8)v;
+//     p[1] = (mz_uint8)(v >> 8);
+// }
+// static MZ_FORCEINLINE void mz_write_le32(mz_uint8 *p, mz_uint32 v)
+// {
+//     p[0] = (mz_uint8)v;
+//     p[1] = (mz_uint8)(v >> 8);
+//     p[2] = (mz_uint8)(v >> 16);
+//     p[3] = (mz_uint8)(v >> 24);
+// }
+// static MZ_FORCEINLINE void mz_write_le64(mz_uint8 *p, mz_uint64 v)
+// {
+//     mz_write_le32(p, (mz_uint32)v);
+//     mz_write_le32(p + sizeof(mz_uint32), (mz_uint32)(v >> 32));
+// }
 
-#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
-#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))
-#define MZ_WRITE_LE64(p, v) mz_write_le64((mz_uint8 *)(p), (mz_uint64)(v))
+// #define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
+// #define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))
+// #define MZ_WRITE_LE64(p, v) mz_write_le64((mz_uint8 *)(p), (mz_uint64)(v))
 
-static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
-{
-    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
-    mz_zip_internal_state *pState = pZip->m_pState;
-    mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);
+// static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
+// {
+//     mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
+//     mz_zip_internal_state *pState = pZip->m_pState;
+//     mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);
 
-    if (!n)
-        return 0;
+//     if (!n)
+//         return 0;
 
-    /* An allocation this big is likely to just fail on 32-bit systems, so don't even go there. */
-    if ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF))
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
-        return 0;
-    }
+//     /* An allocation this big is likely to just fail on 32-bit systems, so don't even go there. */
+//     if ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF))
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
+//         return 0;
+//     }
 
-    if (new_size > pState->m_mem_capacity)
-    {
-        void *pNew_block;
-        size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);
+//     if (new_size > pState->m_mem_capacity)
+//     {
+//         void *pNew_block;
+//         size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);
 
-        while (new_capacity < new_size)
-            new_capacity *= 2;
+//         while (new_capacity < new_size)
+//             new_capacity *= 2;
 
-        if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
-        {
-            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-            return 0;
-        }
+//         if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
+//         {
+//             mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//             return 0;
+//         }
 
-        pState->m_pMem = pNew_block;
-        pState->m_mem_capacity = new_capacity;
-    }
-    memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
-    pState->m_mem_size = (size_t)new_size;
-    return n;
-}
+//         pState->m_pMem = pNew_block;
+//         pState->m_mem_capacity = new_capacity;
+//     }
+//     memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
+//     pState->m_mem_size = (size_t)new_size;
+//     return n;
+// }
 
-static mz_bool mz_zip_writer_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
-{
-    mz_zip_internal_state *pState;
-    mz_bool status = MZ_TRUE;
+// static mz_bool mz_zip_writer_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
+// {
+//     mz_zip_internal_state *pState;
+//     mz_bool status = MZ_TRUE;
 
-    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
-    {
-        if (set_last_error)
-            mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-        return MZ_FALSE;
-    }
+//     if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
+//     {
+//         if (set_last_error)
+//             mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//         return MZ_FALSE;
+//     }
 
-    pState = pZip->m_pState;
-    pZip->m_pState = NULL;
-    mz_zip_array_clear(pZip, &pState->m_central_dir);
-    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
-    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
+//     pState = pZip->m_pState;
+//     pZip->m_pState = NULL;
+//     mz_zip_array_clear(pZip, &pState->m_central_dir);
+//     mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
+//     mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
 
-#ifndef MINIZ_NO_STDIO
-    if (pState->m_pFile)
-    {
-        if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
-        {
-            if (MZ_FCLOSE(pState->m_pFile) == EOF)
-            {
-                if (set_last_error)
-                    mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
-                status = MZ_FALSE;
-            }
-        }
+// #ifndef MINIZ_NO_STDIO
+//     if (pState->m_pFile)
+//     {
+//         if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
+//         {
+//             if (MZ_FCLOSE(pState->m_pFile) == EOF)
+//             {
+//                 if (set_last_error)
+//                     mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
+//                 status = MZ_FALSE;
+//             }
+//         }
 
-        pState->m_pFile = NULL;
-    }
-#endif /* #ifndef MINIZ_NO_STDIO */
+//         pState->m_pFile = NULL;
+//     }
+// #endif /* #ifndef MINIZ_NO_STDIO */
 
-    if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))
-    {
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
-        pState->m_pMem = NULL;
-    }
+//     if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))
+//     {
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
+//         pState->m_pMem = NULL;
+//     }
 
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-    pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
-    return status;
-}
+//     pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+//     pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
+//     return status;
+// }
 
-mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags)
-{
-    mz_bool zip64 = (flags & MZ_ZIP_FLAG_WRITE_ZIP64) != 0;
+// mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags)
+// {
+//     mz_bool zip64 = (flags & MZ_ZIP_FLAG_WRITE_ZIP64) != 0;
 
-    if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
-    {
-        if (!pZip->m_pRead)
-            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-    }
+//     if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
+//     {
+//         if (!pZip->m_pRead)
+//             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     }
 
-    if (pZip->m_file_offset_alignment)
-    {
-        /* Ensure user specified file offset alignment is a power of 2. */
-        if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
-            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-    }
+//     if (pZip->m_file_offset_alignment)
+//     {
+//         /* Ensure user specified file offset alignment is a power of 2. */
+//         if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
+//             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     }
 
-    if (!pZip->m_pAlloc)
-        pZip->m_pAlloc = miniz_def_alloc_func;
-    if (!pZip->m_pFree)
-        pZip->m_pFree = miniz_def_free_func;
-    if (!pZip->m_pRealloc)
-        pZip->m_pRealloc = miniz_def_realloc_func;
+//     if (!pZip->m_pAlloc)
+//         pZip->m_pAlloc = miniz_def_alloc_func;
+//     if (!pZip->m_pFree)
+//         pZip->m_pFree = miniz_def_free_func;
+//     if (!pZip->m_pRealloc)
+//         pZip->m_pRealloc = miniz_def_realloc_func;
 
-    pZip->m_archive_size = existing_size;
-    pZip->m_central_directory_file_ofs = 0;
-    pZip->m_total_files = 0;
+//     pZip->m_archive_size = existing_size;
+//     pZip->m_central_directory_file_ofs = 0;
+//     pZip->m_total_files = 0;
 
-    if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
-        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//     if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
+//         return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
 
-    memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
+//     memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
 
-    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
-    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
-    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
+//     MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
+//     MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
+//     MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
 
-    pZip->m_pState->m_zip64 = zip64;
-    pZip->m_pState->m_zip64_has_extended_info_fields = zip64;
+//     pZip->m_pState->m_zip64 = zip64;
+//     pZip->m_pState->m_zip64_has_extended_info_fields = zip64;
 
-    pZip->m_zip_type = MZ_ZIP_TYPE_USER;
-    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
+//     pZip->m_zip_type = MZ_ZIP_TYPE_USER;
+//     pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
 
-    return MZ_TRUE;
-}
+//     return MZ_TRUE;
+// }
 
-mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)
-{
-    return mz_zip_writer_init_v2(pZip, existing_size, 0);
-}
+// mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)
+// {
+//     return mz_zip_writer_init_v2(pZip, existing_size, 0);
+// }
 
-mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags)
-{
-    pZip->m_pWrite = mz_zip_heap_write_func;
-    pZip->m_pNeeds_keepalive = NULL;
+// mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags)
+// {
+//     pZip->m_pWrite = mz_zip_heap_write_func;
+//     pZip->m_pNeeds_keepalive = NULL;
 
-    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
-        pZip->m_pRead = mz_zip_mem_read_func;
+//     if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
+//         pZip->m_pRead = mz_zip_mem_read_func;
 
-    pZip->m_pIO_opaque = pZip;
+//     pZip->m_pIO_opaque = pZip;
 
-    if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
-        return MZ_FALSE;
+//     if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
+//         return MZ_FALSE;
 
-    pZip->m_zip_type = MZ_ZIP_TYPE_HEAP;
+//     pZip->m_zip_type = MZ_ZIP_TYPE_HEAP;
 
-    if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))
-    {
-        if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))
-        {
-            mz_zip_writer_end_internal(pZip, MZ_FALSE);
-            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-        }
-        pZip->m_pState->m_mem_capacity = initial_allocation_size;
-    }
+//     if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))
+//     {
+//         if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))
+//         {
+//             mz_zip_writer_end_internal(pZip, MZ_FALSE);
+//             return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//         }
+//         pZip->m_pState->m_mem_capacity = initial_allocation_size;
+//     }
 
-    return MZ_TRUE;
-}
+//     return MZ_TRUE;
+// }
 
-mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)
-{
-    return mz_zip_writer_init_heap_v2(pZip, size_to_reserve_at_beginning, initial_allocation_size, 0);
-}
+// mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)
+// {
+//     return mz_zip_writer_init_heap_v2(pZip, size_to_reserve_at_beginning, initial_allocation_size, 0);
+// }
 
-#ifndef MINIZ_NO_STDIO
-static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
-{
-    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
-    mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
+// #ifndef MINIZ_NO_STDIO
+// static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
+// {
+//     mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
+//     mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
 
-    file_ofs += pZip->m_pState->m_file_archive_start_ofs;
+//     file_ofs += pZip->m_pState->m_file_archive_start_ofs;
 
-    if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
-    {
-        mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
-        return 0;
-    }
+//     if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
+//     {
+//         mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
+//         return 0;
+//     }
 
-    return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
-}
+//     return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
+// }
 
-mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
-{
-    return mz_zip_writer_init_file_v2(pZip, pFilename, size_to_reserve_at_beginning, 0);
-}
+// mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
+// {
+//     return mz_zip_writer_init_file_v2(pZip, pFilename, size_to_reserve_at_beginning, 0);
+// }
 
-mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags)
-{
-    MZ_FILE *pFile;
+// mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags)
+// {
+//     MZ_FILE *pFile;
 
-    pZip->m_pWrite = mz_zip_file_write_func;
-    pZip->m_pNeeds_keepalive = NULL;
+//     pZip->m_pWrite = mz_zip_file_write_func;
+//     pZip->m_pNeeds_keepalive = NULL;
 
-    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
-        pZip->m_pRead = mz_zip_file_read_func;
+//     if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
+//         pZip->m_pRead = mz_zip_file_read_func;
 
-    pZip->m_pIO_opaque = pZip;
+//     pZip->m_pIO_opaque = pZip;
+
+//     if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
+//         return MZ_FALSE;
+
+//     if (NULL == (pFile = MZ_FOPEN(pFilename, (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING) ? "w+b" : "wb")))
+//     {
+//         mz_zip_writer_end(pZip);
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
+//     }
 
-    if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
-        return MZ_FALSE;
+//     pZip->m_pState->m_pFile = pFile;
+//     pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
 
-    if (NULL == (pFile = MZ_FOPEN(pFilename, (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING) ? "w+b" : "wb")))
-    {
-        mz_zip_writer_end(pZip);
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
-    }
+//     if (size_to_reserve_at_beginning)
+//     {
+//         mz_uint64 cur_ofs = 0;
+//         char buf[4096];
 
-    pZip->m_pState->m_pFile = pFile;
-    pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
+//         MZ_CLEAR_OBJ(buf);
 
-    if (size_to_reserve_at_beginning)
-    {
-        mz_uint64 cur_ofs = 0;
-        char buf[4096];
+//         do
+//         {
+//             size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
+//             if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)
+//             {
+//                 mz_zip_writer_end(pZip);
+//                 return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//             }
+//             cur_ofs += n;
+//             size_to_reserve_at_beginning -= n;
+//         } while (size_to_reserve_at_beginning);
+//     }
 
-        MZ_CLEAR_OBJ(buf);
+//     return MZ_TRUE;
+// }
 
-        do
-        {
-            size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
-            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)
-            {
-                mz_zip_writer_end(pZip);
-                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-            }
-            cur_ofs += n;
-            size_to_reserve_at_beginning -= n;
-        } while (size_to_reserve_at_beginning);
-    }
+// mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags)
+// {
+//     pZip->m_pWrite = mz_zip_file_write_func;
+//     pZip->m_pNeeds_keepalive = NULL;
 
-    return MZ_TRUE;
-}
+//     if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
+//         pZip->m_pRead = mz_zip_file_read_func;
 
-mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags)
-{
-    pZip->m_pWrite = mz_zip_file_write_func;
-    pZip->m_pNeeds_keepalive = NULL;
+//     pZip->m_pIO_opaque = pZip;
 
-    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
-        pZip->m_pRead = mz_zip_file_read_func;
+//     if (!mz_zip_writer_init_v2(pZip, 0, flags))
+//         return MZ_FALSE;
 
-    pZip->m_pIO_opaque = pZip;
+//     pZip->m_pState->m_pFile = pFile;
+//     pZip->m_pState->m_file_archive_start_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
+//     pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
 
-    if (!mz_zip_writer_init_v2(pZip, 0, flags))
-        return MZ_FALSE;
+//     return MZ_TRUE;
+// }
+// #endif /* #ifndef MINIZ_NO_STDIO */
 
-    pZip->m_pState->m_pFile = pFile;
-    pZip->m_pState->m_file_archive_start_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
-    pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
+// mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
+// {
+//     mz_zip_internal_state *pState;
 
-    return MZ_TRUE;
-}
-#endif /* #ifndef MINIZ_NO_STDIO */
+//     if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
-{
-    mz_zip_internal_state *pState;
+//     if (flags & MZ_ZIP_FLAG_WRITE_ZIP64)
+//     {
+//         /* We don't support converting a non-zip64 file to zip64 - this seems like more trouble than it's worth. (What about the existing 32-bit data descriptors that could follow the compressed data?) */
+//         if (!pZip->m_pState->m_zip64)
+//             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     }
 
-    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     /* No sense in trying to write to an archive that's already at the support max size */
+//     if (pZip->m_pState->m_zip64)
+//     {
+//         if (pZip->m_total_files == MZ_UINT32_MAX)
+//             return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
+//     }
+//     else
+//     {
+//         if (pZip->m_total_files == MZ_UINT16_MAX)
+//             return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
 
-    if (flags & MZ_ZIP_FLAG_WRITE_ZIP64)
-    {
-        /* We don't support converting a non-zip64 file to zip64 - this seems like more trouble than it's worth. (What about the existing 32-bit data descriptors that could follow the compressed data?) */
-        if (!pZip->m_pState->m_zip64)
-            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-    }
+//         if ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
+//     }
 
-    /* No sense in trying to write to an archive that's already at the support max size */
-    if (pZip->m_pState->m_zip64)
-    {
-        if (pZip->m_total_files == MZ_UINT32_MAX)
-            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
-    }
-    else
-    {
-        if (pZip->m_total_files == MZ_UINT16_MAX)
-            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
+//     pState = pZip->m_pState;
 
-        if ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
-    }
+//     if (pState->m_pFile)
+//     {
+// #ifdef MINIZ_NO_STDIO
+//         (void)pFilename;
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+// #else
+//         if (pZip->m_pIO_opaque != pZip)
+//             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    pState = pZip->m_pState;
+//         if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
+//         {
+//             if (!pFilename)
+//                 return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    if (pState->m_pFile)
-    {
-#ifdef MINIZ_NO_STDIO
-        (void)pFilename;
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-#else
-        if (pZip->m_pIO_opaque != pZip)
-            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//             /* Archive is being read from stdio and was originally opened only for reading. Try to reopen as writable. */
+//             if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile)))
+//             {
+//                 /* The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it. */
+//                 mz_zip_reader_end_internal(pZip, MZ_FALSE);
+//                 return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
+//             }
+//         }
 
-        if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
-        {
-            if (!pFilename)
-                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//         pZip->m_pWrite = mz_zip_file_write_func;
+//         pZip->m_pNeeds_keepalive = NULL;
+// #endif /* #ifdef MINIZ_NO_STDIO */
+//     }
+//     else if (pState->m_pMem)
+//     {
+//         /* Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback. */
+//         if (pZip->m_pIO_opaque != pZip)
+//             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-            /* Archive is being read from stdio and was originally opened only for reading. Try to reopen as writable. */
-            if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile)))
-            {
-                /* The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it. */
-                mz_zip_reader_end_internal(pZip, MZ_FALSE);
-                return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
-            }
-        }
+//         pState->m_mem_capacity = pState->m_mem_size;
+//         pZip->m_pWrite = mz_zip_heap_write_func;
+//         pZip->m_pNeeds_keepalive = NULL;
+//     }
+//     /* Archive is being read via a user provided read function - make sure the user has specified a write function too. */
+//     else if (!pZip->m_pWrite)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-        pZip->m_pWrite = mz_zip_file_write_func;
-        pZip->m_pNeeds_keepalive = NULL;
-#endif /* #ifdef MINIZ_NO_STDIO */
-    }
-    else if (pState->m_pMem)
-    {
-        /* Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback. */
-        if (pZip->m_pIO_opaque != pZip)
-            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     /* Start writing new files at the archive's current central directory location. */
+//     /* TODO: We could add a flag that lets the user start writing immediately AFTER the existing central dir - this would be safer. */
+//     pZip->m_archive_size = pZip->m_central_directory_file_ofs;
+//     pZip->m_central_directory_file_ofs = 0;
 
-        pState->m_mem_capacity = pState->m_mem_size;
-        pZip->m_pWrite = mz_zip_heap_write_func;
-        pZip->m_pNeeds_keepalive = NULL;
-    }
-    /* Archive is being read via a user provided read function - make sure the user has specified a write function too. */
-    else if (!pZip->m_pWrite)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     /* Clear the sorted central dir offsets, they aren't useful or maintained now. */
+//     /* Even though we're now in write mode, files can still be extracted and verified, but file locates will be slow. */
+//     /* TODO: We could easily maintain the sorted central directory offsets. */
+//     mz_zip_array_clear(pZip, &pZip->m_pState->m_sorted_central_dir_offsets);
 
-    /* Start writing new files at the archive's current central directory location. */
-    /* TODO: We could add a flag that lets the user start writing immediately AFTER the existing central dir - this would be safer. */
-    pZip->m_archive_size = pZip->m_central_directory_file_ofs;
-    pZip->m_central_directory_file_ofs = 0;
+//     pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
 
-    /* Clear the sorted central dir offsets, they aren't useful or maintained now. */
-    /* Even though we're now in write mode, files can still be extracted and verified, but file locates will be slow. */
-    /* TODO: We could easily maintain the sorted central directory offsets. */
-    mz_zip_array_clear(pZip, &pZip->m_pState->m_sorted_central_dir_offsets);
+//     return MZ_TRUE;
+// }
 
-    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
+// mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)
+// {
+//     return mz_zip_writer_init_from_reader_v2(pZip, pFilename, 0);
+// }
 
-    return MZ_TRUE;
-}
+/* TODO: pArchive_name is a terrible name here! */
+// mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)
+// {
+//     return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
+// }
 
-mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)
-{
-    return mz_zip_writer_init_from_reader_v2(pZip, pFilename, 0);
-}
+// typedef struct
+// {
+//     mz_zip_archive *m_pZip;
+//     mz_uint64 m_cur_archive_file_ofs;
+//     mz_uint64 m_comp_size;
+// } mz_zip_writer_add_state;
 
-/* TODO: pArchive_name is a terrible name here! */
-mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)
-{
-    return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
-}
+// static mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len, void *pUser)
+// {
+//     mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
+//     if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)
+//         return MZ_FALSE;
 
-typedef struct
-{
-    mz_zip_archive *m_pZip;
-    mz_uint64 m_cur_archive_file_ofs;
-    mz_uint64 m_comp_size;
-} mz_zip_writer_add_state;
+//     pState->m_cur_archive_file_ofs += len;
+//     pState->m_comp_size += len;
+//     return MZ_TRUE;
+// }
 
-static mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len, void *pUser)
-{
-    mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
-    if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)
-        return MZ_FALSE;
+// #define MZ_ZIP64_MAX_LOCAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 2)
+// #define MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 3)
+// static mz_uint32 mz_zip_writer_create_zip64_extra_data(mz_uint8 *pBuf, mz_uint64 *pUncomp_size, mz_uint64 *pComp_size, mz_uint64 *pLocal_header_ofs)
+// {
+//     mz_uint8 *pDst = pBuf;
+//     mz_uint32 field_size = 0;
 
-    pState->m_cur_archive_file_ofs += len;
-    pState->m_comp_size += len;
-    return MZ_TRUE;
-}
+//     MZ_WRITE_LE16(pDst + 0, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
+//     MZ_WRITE_LE16(pDst + 2, 0);
+//     pDst += sizeof(mz_uint16) * 2;
 
-#define MZ_ZIP64_MAX_LOCAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 2)
-#define MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 3)
-static mz_uint32 mz_zip_writer_create_zip64_extra_data(mz_uint8 *pBuf, mz_uint64 *pUncomp_size, mz_uint64 *pComp_size, mz_uint64 *pLocal_header_ofs)
-{
-    mz_uint8 *pDst = pBuf;
-    mz_uint32 field_size = 0;
+//     if (pUncomp_size)
+//     {
+//         MZ_WRITE_LE64(pDst, *pUncomp_size);
+//         pDst += sizeof(mz_uint64);
+//         field_size += sizeof(mz_uint64);
+//     }
 
-    MZ_WRITE_LE16(pDst + 0, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
-    MZ_WRITE_LE16(pDst + 2, 0);
-    pDst += sizeof(mz_uint16) * 2;
+//     if (pComp_size)
+//     {
+//         MZ_WRITE_LE64(pDst, *pComp_size);
+//         pDst += sizeof(mz_uint64);
+//         field_size += sizeof(mz_uint64);
+//     }
 
-    if (pUncomp_size)
-    {
-        MZ_WRITE_LE64(pDst, *pUncomp_size);
-        pDst += sizeof(mz_uint64);
-        field_size += sizeof(mz_uint64);
-    }
+//     if (pLocal_header_ofs)
+//     {
+//         MZ_WRITE_LE64(pDst, *pLocal_header_ofs);
+//         pDst += sizeof(mz_uint64);
+//         field_size += sizeof(mz_uint64);
+//     }
 
-    if (pComp_size)
-    {
-        MZ_WRITE_LE64(pDst, *pComp_size);
-        pDst += sizeof(mz_uint64);
-        field_size += sizeof(mz_uint64);
-    }
+//     MZ_WRITE_LE16(pBuf + 2, field_size);
 
-    if (pLocal_header_ofs)
-    {
-        MZ_WRITE_LE64(pDst, *pLocal_header_ofs);
-        pDst += sizeof(mz_uint64);
-        field_size += sizeof(mz_uint64);
-    }
+//     return (mz_uint32)(pDst - pBuf);
+// }
 
-    MZ_WRITE_LE16(pBuf + 2, field_size);
+// static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)
+// {
+//     (void)pZip;
+//     memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
+//     return MZ_TRUE;
+// }
 
-    return (mz_uint32)(pDst - pBuf);
-}
+// static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst,
+//                                                        mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size,
+//                                                        mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
+//                                                        mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
+//                                                        mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
+// {
+//     (void)pZip;
+//     memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
+//     MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
+//     MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_MIN(local_header_ofs, MZ_UINT32_MAX));
+//     return MZ_TRUE;
+// }
 
-static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)
-{
-    (void)pZip;
-    memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
-    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
-    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
-    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
-    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
-    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
-    return MZ_TRUE;
-}
+// static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,
+//                                                 const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size,
+//                                                 mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
+//                                                 mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
+//                                                 mz_uint64 local_header_ofs, mz_uint32 ext_attributes,
+//                                                 const char *user_extra_data, mz_uint user_extra_data_len)
+// {
+//     mz_zip_internal_state *pState = pZip->m_pState;
+//     mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
+//     size_t orig_central_dir_size = pState->m_central_dir.m_size;
+//     mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
 
-static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst,
-                                                       mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size,
-                                                       mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
-                                                       mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
-                                                       mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
-{
-    (void)pZip;
-    memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
-    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
-    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
-    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
-    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
-    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
-    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
-    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
-    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_MIN(local_header_ofs, MZ_UINT32_MAX));
-    return MZ_TRUE;
-}
+//     if (!pZip->m_pState->m_zip64)
+//     {
+//         if (local_header_ofs > 0xFFFFFFFF)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
+//     }
 
-static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,
-                                                const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size,
-                                                mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
-                                                mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
-                                                mz_uint64 local_header_ofs, mz_uint32 ext_attributes,
-                                                const char *user_extra_data, mz_uint user_extra_data_len)
-{
-    mz_zip_internal_state *pState = pZip->m_pState;
-    mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
-    size_t orig_central_dir_size = pState->m_central_dir.m_size;
-    mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
+//     /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
+//     if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + user_extra_data_len + comment_size) >= MZ_UINT32_MAX)
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
 
-    if (!pZip->m_pState->m_zip64)
-    {
-        if (local_header_ofs > 0xFFFFFFFF)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
-    }
+//     if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, extra_size + user_extra_data_len, comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
 
-    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
-    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + user_extra_data_len + comment_size) >= MZ_UINT32_MAX)
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
+//     if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
+//         (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||
+//         (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||
+//         (!mz_zip_array_push_back(pZip, &pState->m_central_dir, user_extra_data, user_extra_data_len)) ||
+//         (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||
+//         (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))
+//     {
+//         /* Try to resize the central directory array back into its original state. */
+//         mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
+//         return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//     }
 
-    if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, extra_size + user_extra_data_len, comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
-        return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
+//     return MZ_TRUE;
+// }
 
-    if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
-        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||
-        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||
-        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, user_extra_data, user_extra_data_len)) ||
-        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||
-        (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))
-    {
-        /* Try to resize the central directory array back into its original state. */
-        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
-        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-    }
+// static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)
+// {
+//     /* Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes. */
+//     if (*pArchive_name == '/')
+//         return MZ_FALSE;
 
-    return MZ_TRUE;
-}
+//     while (*pArchive_name)
+//     {
+//         if ((*pArchive_name == '\\') || (*pArchive_name == ':'))
+//             return MZ_FALSE;
 
-static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)
-{
-    /* Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes. */
-    if (*pArchive_name == '/')
-        return MZ_FALSE;
+//         pArchive_name++;
+//     }
 
-    while (*pArchive_name)
-    {
-        if ((*pArchive_name == '\\') || (*pArchive_name == ':'))
-            return MZ_FALSE;
+//     return MZ_TRUE;
+// }
 
-        pArchive_name++;
-    }
+// static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)
+// {
+//     mz_uint32 n;
+//     if (!pZip->m_file_offset_alignment)
+//         return 0;
+//     n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
+//     return (mz_uint)((pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1));
+// }
 
-    return MZ_TRUE;
-}
+// static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)
+// {
+//     char buf[4096];
+//     memset(buf, 0, MZ_MIN(sizeof(buf), n));
+//     while (n)
+//     {
+//         mz_uint32 s = MZ_MIN(sizeof(buf), n);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)
-{
-    mz_uint32 n;
-    if (!pZip->m_file_offset_alignment)
-        return 0;
-    n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
-    return (mz_uint)((pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1));
-}
+//         cur_file_ofs += s;
+//         n -= s;
+//     }
+//     return MZ_TRUE;
+// }
 
-static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)
-{
-    char buf[4096];
-    memset(buf, 0, MZ_MIN(sizeof(buf), n));
-    while (n)
-    {
-        mz_uint32 s = MZ_MIN(sizeof(buf), n);
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+// mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
+//                                  mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
+// {
+//     return mz_zip_writer_add_mem_ex_v2(pZip, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, uncomp_size, uncomp_crc32, NULL, NULL, 0, NULL, 0);
+// }
 
-        cur_file_ofs += s;
-        n -= s;
-    }
-    return MZ_TRUE;
-}
+// mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size,
+//                                     mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified,
+//                                     const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
+// {
+//     if(!pZip)
+//     {
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     }
 
-mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
-                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
-{
-    return mz_zip_writer_add_mem_ex_v2(pZip, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, uncomp_size, uncomp_crc32, NULL, NULL, 0, NULL, 0);
-}
+//     mz_uint16 method = 0, dos_time = 0, dos_date = 0;
+//     mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
+//     mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
+//     size_t archive_name_size;
+//     mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
+//     tdefl_compressor *pComp = NULL;
+//     mz_bool store_data_uncompressed;
+//     mz_zip_internal_state *pState;
+//     mz_uint8 *pExtra_data = NULL;
+//     mz_uint32 extra_size = 0;
+//     mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
+//     mz_uint16 bit_flags = 0;
 
-mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size,
-                                    mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified,
-                                    const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
-{
-    if(!pZip)
-    {
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-    }
+//     if (uncomp_size || (buf_size && !(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
+//         bit_flags |= MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;
 
-    mz_uint16 method = 0, dos_time = 0, dos_date = 0;
-    mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
-    mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
-    size_t archive_name_size;
-    mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
-    tdefl_compressor *pComp = NULL;
-    mz_bool store_data_uncompressed;
-    mz_zip_internal_state *pState;
-    mz_uint8 *pExtra_data = NULL;
-    mz_uint32 extra_size = 0;
-    mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
-    mz_uint16 bit_flags = 0;
+//     if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
+//         bit_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;
 
-    if (uncomp_size || (buf_size && !(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
-        bit_flags |= MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;
+//     if ((int)level_and_flags < 0)
+//         level_and_flags = MZ_DEFAULT_LEVEL;
+//     level = level_and_flags & 0xF;
+//     store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));
 
-    if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
-        bit_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;
+//     if ((!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    if ((int)level_and_flags < 0)
-        level_and_flags = MZ_DEFAULT_LEVEL;
-    level = level_and_flags & 0xF;
-    store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));
+//     pState = pZip->m_pState;
 
-    if ((!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     if (pState->m_zip64)
+//     {
+//         if (pZip->m_total_files == MZ_UINT32_MAX)
+//             return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
+//     }
+//     else
+//     {
+//         if (pZip->m_total_files == MZ_UINT16_MAX)
+//         {
+//             pState->m_zip64 = MZ_TRUE;
+//             /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
+//         }
+//         if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
+//         {
+//             pState->m_zip64 = MZ_TRUE;
+//             /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
+//         }
+//     }
 
-    pState = pZip->m_pState;
+//     if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    if (pState->m_zip64)
-    {
-        if (pZip->m_total_files == MZ_UINT32_MAX)
-            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
-    }
-    else
-    {
-        if (pZip->m_total_files == MZ_UINT16_MAX)
-        {
-            pState->m_zip64 = MZ_TRUE;
-            /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
-        }
-        if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
-        {
-            pState->m_zip64 = MZ_TRUE;
-            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
-        }
-    }
+//     if (!mz_zip_writer_validate_archive_name(pArchive_name))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);
 
-    if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+// #ifndef MINIZ_NO_TIME
+//     if (last_modified != NULL)
+//     {
+//         mz_zip_time_t_to_dos_time(*last_modified, &dos_time, &dos_date);
+//     }
+//     else
+//     {
+//         MZ_TIME_T cur_time;
+//         time(&cur_time);
+//         mz_zip_time_t_to_dos_time(cur_time, &dos_time, &dos_date);
+//     }
+// #endif /* #ifndef MINIZ_NO_TIME */
 
-    if (!mz_zip_writer_validate_archive_name(pArchive_name))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);
+//     archive_name_size = strlen(pArchive_name);
+//     if (archive_name_size > MZ_UINT16_MAX)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);
 
-#ifndef MINIZ_NO_TIME
-    if (last_modified != NULL)
-    {
-        mz_zip_time_t_to_dos_time(*last_modified, &dos_time, &dos_date);
-    }
-    else
-    {
-        MZ_TIME_T cur_time;
-        time(&cur_time);
-        mz_zip_time_t_to_dos_time(cur_time, &dos_time, &dos_date);
-    }
-#endif /* #ifndef MINIZ_NO_TIME */
+//     num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
 
-    archive_name_size = strlen(pArchive_name);
-    if (archive_name_size > MZ_UINT16_MAX)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);
+//     /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
+//     if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
 
-    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
+//     if (!pState->m_zip64)
+//     {
+//         /* Bail early if the archive would obviously become too large */
+//         if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size 
+//             + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + user_extra_data_len + 
+//             pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + user_extra_data_central_len
+//             + MZ_ZIP_DATA_DESCRIPTER_SIZE32) > 0xFFFFFFFF)
+//         {
+//             pState->m_zip64 = MZ_TRUE;
+//             /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
+//         }
+//     }
 
-    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
-    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
+//     if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))
+//     {
+//         /* Set DOS Subdirectory attribute bit. */
+//         ext_attributes |= MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG;
 
-    if (!pState->m_zip64)
-    {
-        /* Bail early if the archive would obviously become too large */
-        if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size 
-           + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + user_extra_data_len + 
-           pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + user_extra_data_central_len
-           + MZ_ZIP_DATA_DESCRIPTER_SIZE32) > 0xFFFFFFFF)
-        {
-            pState->m_zip64 = MZ_TRUE;
-            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
-        }
-    }
+//         /* Subdirectories cannot contain data. */
+//         if ((buf_size) || (uncomp_size))
+//             return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     }
 
-    if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))
-    {
-        /* Set DOS Subdirectory attribute bit. */
-        ext_attributes |= MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG;
+//     /* Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.) */
+//     if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + (pState->m_zip64 ? MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE : 0))) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
+//         return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
 
-        /* Subdirectories cannot contain data. */
-        if ((buf_size) || (uncomp_size))
-            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-    }
+//     if ((!store_data_uncompressed) && (buf_size))
+//     {
+//         if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
+//             return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//     }
 
-    /* Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.) */
-    if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + (pState->m_zip64 ? MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE : 0))) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
-        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//     if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
+//     {
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+//         return MZ_FALSE;
+//     }
 
-    if ((!store_data_uncompressed) && (buf_size))
-    {
-        if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
-            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-    }
+//     local_dir_header_ofs += num_alignment_padding_bytes;
+//     if (pZip->m_file_offset_alignment)
+//     {
+//         MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
+//     }
+//     cur_archive_file_ofs += num_alignment_padding_bytes;
 
-    if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
-    {
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-        return MZ_FALSE;
-    }
+//     MZ_CLEAR_OBJ(local_dir_header);
 
-    local_dir_header_ofs += num_alignment_padding_bytes;
-    if (pZip->m_file_offset_alignment)
-    {
-        MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
-    }
-    cur_archive_file_ofs += num_alignment_padding_bytes;
+//     if (!store_data_uncompressed || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
+//     {
+//         method = MZ_DEFLATED;
+//     }
 
-    MZ_CLEAR_OBJ(local_dir_header);
+//     if (pState->m_zip64)
+//     {
+//         if (uncomp_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
+//         {
+//             pExtra_data = extra_data;
+//             extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
+//                                                                (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
+//         }
 
-    if (!store_data_uncompressed || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-    {
-        method = MZ_DEFLATED;
-    }
+//         if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, extra_size + user_extra_data_len, 0, 0, 0, method, bit_flags, dos_time, dos_date))
+//             return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
 
-    if (pState->m_zip64)
-    {
-        if (uncomp_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
-        {
-            pExtra_data = extra_data;
-            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
-                                                               (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
-        }
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, extra_size + user_extra_data_len, 0, 0, 0, method, bit_flags, dos_time, dos_date))
-            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
+//         cur_archive_file_ofs += sizeof(local_dir_header);
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
+//         {
+//             pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         }
+//         cur_archive_file_ofs += archive_name_size;
 
-        cur_archive_file_ofs += sizeof(local_dir_header);
+//         if (pExtra_data != NULL)
+//         {
+//             if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
+//                 return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
-        {
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-        }
-        cur_archive_file_ofs += archive_name_size;
+//             cur_archive_file_ofs += extra_size;
+//         }
+//     }
+//     else
+//     {
+//         if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
+//             return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
+//         if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, user_extra_data_len, 0, 0, 0, method, bit_flags, dos_time, dos_date))
+//             return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
 
-        if (pExtra_data != NULL)
-        {
-            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
-                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-            cur_archive_file_ofs += extra_size;
-        }
-    }
-    else
-    {
-        if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
-            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
-        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, user_extra_data_len, 0, 0, 0, method, bit_flags, dos_time, dos_date))
-            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
+//         cur_archive_file_ofs += sizeof(local_dir_header);
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
+//         {
+//             pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         }
+//         cur_archive_file_ofs += archive_name_size;
+//     }
 
-        cur_archive_file_ofs += sizeof(local_dir_header);
+//     if (user_extra_data_len > 0)
+//     {
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
-        {
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-        }
-        cur_archive_file_ofs += archive_name_size;
-    }
+//         cur_archive_file_ofs += user_extra_data_len;
+//     }
 
-    if (user_extra_data_len > 0)
-    {
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//     if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
+//     {
+//         uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);
+//         uncomp_size = buf_size;
+//         if (uncomp_size <= 3)
+//         {
+//             level = 0;
+//             store_data_uncompressed = MZ_TRUE;
+//         }
+//     }
 
-        cur_archive_file_ofs += user_extra_data_len;
-    }
+//     if (store_data_uncompressed)
+//     {
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)
+//         {
+//             pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         }
 
-    if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-    {
-        uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);
-        uncomp_size = buf_size;
-        if (uncomp_size <= 3)
-        {
-            level = 0;
-            store_data_uncompressed = MZ_TRUE;
-        }
-    }
+//         cur_archive_file_ofs += buf_size;
+//         comp_size = buf_size;
+//     }
+//     else if (buf_size)
+//     {
+//         mz_zip_writer_add_state state;
 
-    if (store_data_uncompressed)
-    {
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)
-        {
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-        }
+//         state.m_pZip = pZip;
+//         state.m_cur_archive_file_ofs = cur_archive_file_ofs;
+//         state.m_comp_size = 0;
 
-        cur_archive_file_ofs += buf_size;
-        comp_size = buf_size;
-    }
-    else if (buf_size)
-    {
-        mz_zip_writer_add_state state;
+//         if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||
+//             (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))
+//         {
+//             pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+//             return mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
+//         }
 
-        state.m_pZip = pZip;
-        state.m_cur_archive_file_ofs = cur_archive_file_ofs;
-        state.m_comp_size = 0;
+//         comp_size = state.m_comp_size;
+//         cur_archive_file_ofs = state.m_cur_archive_file_ofs;
+//     }
 
-        if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||
-            (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))
-        {
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-            return mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
-        }
+//     pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+//     pComp = NULL;
 
-        comp_size = state.m_comp_size;
-        cur_archive_file_ofs = state.m_cur_archive_file_ofs;
-    }
+//     if (uncomp_size)
+//     {
+//         mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
+//         mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;
 
-    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-    pComp = NULL;
+//         MZ_ASSERT(bit_flags & MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR);
 
-    if (uncomp_size)
-    {
-        mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
-        mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;
+//         MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
+//         MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
+//         if (pExtra_data == NULL)
+//         {
+//             if (comp_size > MZ_UINT32_MAX)
+//                 return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
 
-        MZ_ASSERT(bit_flags & MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR);
+//             MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
+//             MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
+//         }
+//         else
+//         {
+//             MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
+//             MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
+//             local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
+//         }
 
-        MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
-        MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
-        if (pExtra_data == NULL)
-        {
-            if (comp_size > MZ_UINT32_MAX)
-                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
+//             return MZ_FALSE;
 
-            MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
-            MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
-        }
-        else
-        {
-            MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
-            MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
-            local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
-        }
+//         cur_archive_file_ofs += local_dir_footer_size;
+//     }
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
-            return MZ_FALSE;
+//     if (pExtra_data != NULL)
+//     {
+//         extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
+//                                                            (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
+//     }
 
-        cur_archive_file_ofs += local_dir_footer_size;
-    }
+//     if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, extra_size, pComment,
+//                                           comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
+//                                           user_extra_data_central, user_extra_data_central_len))
+//         return MZ_FALSE;
 
-    if (pExtra_data != NULL)
-    {
-        extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
-                                                           (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
-    }
+//     pZip->m_total_files++;
+//     pZip->m_archive_size = cur_archive_file_ofs;
 
-    if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, extra_size, pComment,
-                                          comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
-                                          user_extra_data_central, user_extra_data_central_len))
-        return MZ_FALSE;
+//     return MZ_TRUE;
+// }
 
-    pZip->m_total_files++;
-    pZip->m_archive_size = cur_archive_file_ofs;
+// #ifndef MINIZ_NO_STDIO
+// mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 size_to_add, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
+//                                 const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
+// {
+//     if(!pZip)
+//     {
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     }
 
-    return MZ_TRUE;
-}
+//     mz_uint16 gen_flags = MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;
+//     mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
+//     mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
+//     mz_uint64 local_dir_header_ofs, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = size_to_add, comp_size = 0;
+//     size_t archive_name_size;
+//     mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
+//     mz_uint8 *pExtra_data = NULL;
+//     mz_uint32 extra_size = 0;
+//     mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
+//     mz_zip_internal_state *pState;
 
-#ifndef MINIZ_NO_STDIO
-mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 size_to_add, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
-                                const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
-{
-    if(!pZip)
-    {
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-    }
+//     if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
+//         gen_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;
 
-    mz_uint16 gen_flags = MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;
-    mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
-    mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
-    mz_uint64 local_dir_header_ofs, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = size_to_add, comp_size = 0;
-    size_t archive_name_size;
-    mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
-    mz_uint8 *pExtra_data = NULL;
-    mz_uint32 extra_size = 0;
-    mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
-    mz_zip_internal_state *pState;
+//     if ((int)level_and_flags < 0)
+//         level_and_flags = MZ_DEFAULT_LEVEL;
+//     level = level_and_flags & 0xF;
 
-    if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
-        gen_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;
+//     /* Sanity checks */
+//     if ((!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    if ((int)level_and_flags < 0)
-        level_and_flags = MZ_DEFAULT_LEVEL;
-    level = level_and_flags & 0xF;
+//     pState = pZip->m_pState;
 
-    /* Sanity checks */
-    if ((!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     if ((!pState->m_zip64) && (uncomp_size > MZ_UINT32_MAX))
+//     {
+//         /* Source file is too large for non-zip64 */
+//         /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
+//         pState->m_zip64 = MZ_TRUE;
+//     }
 
-    pState = pZip->m_pState;
+//     /* We could support this, but why? */
+//     if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    if ((!pState->m_zip64) && (uncomp_size > MZ_UINT32_MAX))
-    {
-        /* Source file is too large for non-zip64 */
-        /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
-        pState->m_zip64 = MZ_TRUE;
-    }
+//     if (!mz_zip_writer_validate_archive_name(pArchive_name))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);
 
-    /* We could support this, but why? */
-    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     if (pState->m_zip64)
+//     {
+//         if (pZip->m_total_files == MZ_UINT32_MAX)
+//             return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
+//     }
+//     else
+//     {
+//         if (pZip->m_total_files == MZ_UINT16_MAX)
+//         {
+//             pState->m_zip64 = MZ_TRUE;
+//             /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
+//         }
+//     }
 
-    if (!mz_zip_writer_validate_archive_name(pArchive_name))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);
+//     archive_name_size = strlen(pArchive_name);
+//     if (archive_name_size > MZ_UINT16_MAX)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);
 
-    if (pState->m_zip64)
-    {
-        if (pZip->m_total_files == MZ_UINT32_MAX)
-            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
-    }
-    else
-    {
-        if (pZip->m_total_files == MZ_UINT16_MAX)
-        {
-            pState->m_zip64 = MZ_TRUE;
-            /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
-        }
-    }
+//     num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
 
-    archive_name_size = strlen(pArchive_name);
-    if (archive_name_size > MZ_UINT16_MAX)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);
+//     /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
+//     if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
+//         return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
 
-    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
+//     if (!pState->m_zip64)
+//     {
+//         /* Bail early if the archive would obviously become too large */
+//         if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE 
+//             + archive_name_size + comment_size + user_extra_data_len + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 1024
+//             + MZ_ZIP_DATA_DESCRIPTER_SIZE32 + user_extra_data_central_len) > 0xFFFFFFFF)
+//         {
+//             pState->m_zip64 = MZ_TRUE;
+//             /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
+//         }
+//     }
 
-    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
-    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
-        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
+// #ifndef MINIZ_NO_TIME
+//     if (pFile_time)
+//     {
+//         mz_zip_time_t_to_dos_time(*pFile_time, &dos_time, &dos_date);
+//     }
+// #endif
 
-    if (!pState->m_zip64)
-    {
-        /* Bail early if the archive would obviously become too large */
-        if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE 
-           + archive_name_size + comment_size + user_extra_data_len + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 1024
-           + MZ_ZIP_DATA_DESCRIPTER_SIZE32 + user_extra_data_central_len) > 0xFFFFFFFF)
-        {
-            pState->m_zip64 = MZ_TRUE;
-            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
-        }
-    }
+//     if (uncomp_size <= 3)
+//         level = 0;
 
-#ifndef MINIZ_NO_TIME
-    if (pFile_time)
-    {
-        mz_zip_time_t_to_dos_time(*pFile_time, &dos_time, &dos_date);
-    }
-#endif
+//     if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
+//     {
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//     }
 
-    if (uncomp_size <= 3)
-        level = 0;
+//     cur_archive_file_ofs += num_alignment_padding_bytes;
+//     local_dir_header_ofs = cur_archive_file_ofs;
 
-    if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
-    {
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-    }
+//     if (pZip->m_file_offset_alignment)
+//     {
+//         MZ_ASSERT((cur_archive_file_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
+//     }
 
-    cur_archive_file_ofs += num_alignment_padding_bytes;
-    local_dir_header_ofs = cur_archive_file_ofs;
+//     if (uncomp_size && level)
+//     {
+//         method = MZ_DEFLATED;
+//     }
 
-    if (pZip->m_file_offset_alignment)
-    {
-        MZ_ASSERT((cur_archive_file_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
-    }
+//     MZ_CLEAR_OBJ(local_dir_header);
+//     if (pState->m_zip64)
+//     {
+//         if (uncomp_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
+//         {
+//             pExtra_data = extra_data;
+//             extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
+//                                                                (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
+//         }
 
-    if (uncomp_size && level)
-    {
-        method = MZ_DEFLATED;
-    }
+//         if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, extra_size + user_extra_data_len, 0, 0, 0, method, gen_flags, dos_time, dos_date))
+//             return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
 
-    MZ_CLEAR_OBJ(local_dir_header);
-    if (pState->m_zip64)
-    {
-        if (uncomp_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
-        {
-            pExtra_data = extra_data;
-            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
-                                                               (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
-        }
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, extra_size + user_extra_data_len, 0, 0, 0, method, gen_flags, dos_time, dos_date))
-            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
+//         cur_archive_file_ofs += sizeof(local_dir_header);
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
+//         {
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         }
 
-        cur_archive_file_ofs += sizeof(local_dir_header);
+//         cur_archive_file_ofs += archive_name_size;
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
-        {
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-        }
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-        cur_archive_file_ofs += archive_name_size;
+//         cur_archive_file_ofs += extra_size;
+//     }
+//     else
+//     {
+//         if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
+//             return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
+//         if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, user_extra_data_len, 0, 0, 0, method, gen_flags, dos_time, dos_date))
+//             return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-        cur_archive_file_ofs += extra_size;
-    }
-    else
-    {
-        if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
-            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
-        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, user_extra_data_len, 0, 0, 0, method, gen_flags, dos_time, dos_date))
-            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
+//         cur_archive_file_ofs += sizeof(local_dir_header);
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
+//         {
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         }
 
-        cur_archive_file_ofs += sizeof(local_dir_header);
+//         cur_archive_file_ofs += archive_name_size;
+//     }
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
-        {
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-        }
+//     if (user_extra_data_len > 0)
+//     {
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-        cur_archive_file_ofs += archive_name_size;
-    }
+//         cur_archive_file_ofs += user_extra_data_len;
+//     }
 
-    if (user_extra_data_len > 0)
-    {
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//     if (uncomp_size)
+//     {
+//         mz_uint64 uncomp_remaining = uncomp_size;
+//         void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
+//         if (!pRead_buf)
+//         {
+//             return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//         }
 
-        cur_archive_file_ofs += user_extra_data_len;
-    }
+//         if (!level)
+//         {
+//             while (uncomp_remaining)
+//             {
+//                 mz_uint n = (mz_uint)MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);
+//                 if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) || (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n))
+//                 {
+//                     pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+//                     return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
+//                 }
+//                 uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
+//                 uncomp_remaining -= n;
+//                 cur_archive_file_ofs += n;
+//             }
+//             comp_size = uncomp_size;
+//         }
+//         else
+//         {
+//             mz_bool result = MZ_FALSE;
+//             mz_zip_writer_add_state state;
+//             tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
+//             if (!pComp)
+//             {
+//                 pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+//                 return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
+//             }
 
-    if (uncomp_size)
-    {
-        mz_uint64 uncomp_remaining = uncomp_size;
-        void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
-        if (!pRead_buf)
-        {
-            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-        }
+//             state.m_pZip = pZip;
+//             state.m_cur_archive_file_ofs = cur_archive_file_ofs;
+//             state.m_comp_size = 0;
 
-        if (!level)
-        {
-            while (uncomp_remaining)
-            {
-                mz_uint n = (mz_uint)MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);
-                if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) || (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n))
-                {
-                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
-                }
-                uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
-                uncomp_remaining -= n;
-                cur_archive_file_ofs += n;
-            }
-            comp_size = uncomp_size;
-        }
-        else
-        {
-            mz_bool result = MZ_FALSE;
-            mz_zip_writer_add_state state;
-            tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
-            if (!pComp)
-            {
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
-            }
+//             if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)
+//             {
+//                 pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+//                 pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+//                 return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
+//             }
 
-            state.m_pZip = pZip;
-            state.m_cur_archive_file_ofs = cur_archive_file_ofs;
-            state.m_comp_size = 0;
+//             for (;;)
+//             {
+//                 size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
+//                 tdefl_status status;
+//                 tdefl_flush flush = TDEFL_NO_FLUSH;
 
-            if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)
-            {
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
-            }
+//                 if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)
+//                 {
+//                     mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
+//                     break;
+//                 }
 
-            for (;;)
-            {
-                size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
-                tdefl_status status;
-                tdefl_flush flush = TDEFL_NO_FLUSH;
+//                 uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);
+//                 uncomp_remaining -= in_buf_size;
 
-                if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)
-                {
-                    mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
-                    break;
-                }
+//                 if (pZip->m_pNeeds_keepalive != NULL && pZip->m_pNeeds_keepalive(pZip->m_pIO_opaque))
+//                     flush = TDEFL_FULL_FLUSH;
 
-                uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);
-                uncomp_remaining -= in_buf_size;
+//                 status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size, uncomp_remaining ? flush : TDEFL_FINISH);
+//                 if (status == TDEFL_STATUS_DONE)
+//                 {
+//                     result = MZ_TRUE;
+//                     break;
+//                 }
+//                 else if (status != TDEFL_STATUS_OKAY)
+//                 {
+//                     mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
+//                     break;
+//                 }
+//             }
 
-                if (pZip->m_pNeeds_keepalive != NULL && pZip->m_pNeeds_keepalive(pZip->m_pIO_opaque))
-                    flush = TDEFL_FULL_FLUSH;
+//             pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
 
-                status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size, uncomp_remaining ? flush : TDEFL_FINISH);
-                if (status == TDEFL_STATUS_DONE)
-                {
-                    result = MZ_TRUE;
-                    break;
-                }
-                else if (status != TDEFL_STATUS_OKAY)
-                {
-                    mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
-                    break;
-                }
-            }
+//             if (!result)
+//             {
+//                 pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+//                 return MZ_FALSE;
+//             }
 
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+//             comp_size = state.m_comp_size;
+//             cur_archive_file_ofs = state.m_cur_archive_file_ofs;
+//         }
 
-            if (!result)
-            {
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-                return MZ_FALSE;
-            }
+//         pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+//     }
 
-            comp_size = state.m_comp_size;
-            cur_archive_file_ofs = state.m_cur_archive_file_ofs;
-        }
+//     {
+//         mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
+//         mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;
 
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-    }
+//         MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
+//         MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
+//         if (pExtra_data == NULL)
+//         {
+//             if (comp_size > MZ_UINT32_MAX)
+//                 return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
 
-    {
-        mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
-        mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;
+//             MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
+//             MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
+//         }
+//         else
+//         {
+//             MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
+//             MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
+//             local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
+//         }
 
-        MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
-        MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
-        if (pExtra_data == NULL)
-        {
-            if (comp_size > MZ_UINT32_MAX)
-                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
+//             return MZ_FALSE;
 
-            MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
-            MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
-        }
-        else
-        {
-            MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
-            MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
-            local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
-        }
+//         cur_archive_file_ofs += local_dir_footer_size;
+//     }
 
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
-            return MZ_FALSE;
+//     if (pExtra_data != NULL)
+//     {
+//         extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
+//                                                            (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
+//     }
 
-        cur_archive_file_ofs += local_dir_footer_size;
-    }
+//     if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, extra_size, pComment, comment_size,
+//                                           uncomp_size, comp_size, uncomp_crc32, method, gen_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
+//                                           user_extra_data_central, user_extra_data_central_len))
+//         return MZ_FALSE;
 
-    if (pExtra_data != NULL)
-    {
-        extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
-                                                           (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
-    }
+//     pZip->m_total_files++;
+//     pZip->m_archive_size = cur_archive_file_ofs;
 
-    if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, extra_size, pComment, comment_size,
-                                          uncomp_size, comp_size, uncomp_crc32, method, gen_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
-                                          user_extra_data_central, user_extra_data_central_len))
-        return MZ_FALSE;
+//     return MZ_TRUE;
+// }
 
-    pZip->m_total_files++;
-    pZip->m_archive_size = cur_archive_file_ofs;
+// mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
+// {
+//     MZ_FILE *pSrc_file = NULL;
+//     mz_uint64 uncomp_size = 0;
+//     MZ_TIME_T file_modified_time;
+//     MZ_TIME_T *pFile_time = NULL;
+//     mz_bool status;
 
-    return MZ_TRUE;
-}
+//     memset(&file_modified_time, 0, sizeof(file_modified_time));
 
-mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
-{
-    MZ_FILE *pSrc_file = NULL;
-    mz_uint64 uncomp_size = 0;
-    MZ_TIME_T file_modified_time;
-    MZ_TIME_T *pFile_time = NULL;
-    mz_bool status;
-
-    memset(&file_modified_time, 0, sizeof(file_modified_time));
-
-#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
-    pFile_time = &file_modified_time;
-    if (!mz_zip_get_file_modified_time(pSrc_filename, &file_modified_time))
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_STAT_FAILED);
-#endif
+// #if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
+//     pFile_time = &file_modified_time;
+//     if (!mz_zip_get_file_modified_time(pSrc_filename, &file_modified_time))
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_STAT_FAILED);
+// #endif
 
-    pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
-    if (!pSrc_file)
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
+//     pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
+//     if (!pSrc_file)
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
 
-    MZ_FSEEK64(pSrc_file, 0, SEEK_END);
-    uncomp_size = MZ_FTELL64(pSrc_file);
-    MZ_FSEEK64(pSrc_file, 0, SEEK_SET);
+//     MZ_FSEEK64(pSrc_file, 0, SEEK_END);
+//     uncomp_size = MZ_FTELL64(pSrc_file);
+//     MZ_FSEEK64(pSrc_file, 0, SEEK_SET);
 
-    status = mz_zip_writer_add_cfile(pZip, pArchive_name, pSrc_file, uncomp_size, pFile_time, pComment, comment_size, level_and_flags, NULL, 0, NULL, 0);
+//     status = mz_zip_writer_add_cfile(pZip, pArchive_name, pSrc_file, uncomp_size, pFile_time, pComment, comment_size, level_and_flags, NULL, 0, NULL, 0);
 
-    MZ_FCLOSE(pSrc_file);
+//     MZ_FCLOSE(pSrc_file);
 
-    return status;
-}
-#endif /* #ifndef MINIZ_NO_STDIO */
+//     return status;
+// }
+// #endif /* #ifndef MINIZ_NO_STDIO */
 
 // static mz_bool mz_zip_writer_update_zip64_extension_block(mz_zip_array *pNew_ext, mz_zip_archive *pZip, const mz_uint8 *pExt, uint32_t ext_len, mz_uint64 *pComp_size, mz_uint64 *pUncomp_size, mz_uint64 *pLocal_header_ofs, mz_uint32 *pDisk_start)
 // {
@@ -7083,491 +7082,491 @@ mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name,
 //     return MZ_TRUE;
 // }
 
-mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)
-{
-    mz_zip_internal_state *pState;
-    mz_uint64 central_dir_ofs, central_dir_size;
-    mz_uint8 hdr[256];
+// mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)
+// {
+//     mz_zip_internal_state *pState;
+//     mz_uint64 central_dir_ofs, central_dir_size;
+//     mz_uint8 hdr[256];
 
-    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    pState = pZip->m_pState;
+//     pState = pZip->m_pState;
 
-    if (pState->m_zip64)
-    {
-        if ((pZip->m_total_files > MZ_UINT32_MAX) || (pState->m_central_dir.m_size >= MZ_UINT32_MAX))
-            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
-    }
-    else
-    {
-        if ((pZip->m_total_files > MZ_UINT16_MAX) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX))
-            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
-    }
+//     if (pState->m_zip64)
+//     {
+//         if ((pZip->m_total_files > MZ_UINT32_MAX) || (pState->m_central_dir.m_size >= MZ_UINT32_MAX))
+//             return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
+//     }
+//     else
+//     {
+//         if ((pZip->m_total_files > MZ_UINT16_MAX) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX))
+//             return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
+//     }
 
-    central_dir_ofs = 0;
-    central_dir_size = 0;
-    if (pZip->m_total_files)
-    {
-        /* Write central directory */
-        central_dir_ofs = pZip->m_archive_size;
-        central_dir_size = pState->m_central_dir.m_size;
-        pZip->m_central_directory_file_ofs = central_dir_ofs;
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-
-        pZip->m_archive_size += central_dir_size;
-    }
+//     central_dir_ofs = 0;
+//     central_dir_size = 0;
+//     if (pZip->m_total_files)
+//     {
+//         /* Write central directory */
+//         central_dir_ofs = pZip->m_archive_size;
+//         central_dir_size = pState->m_central_dir.m_size;
+//         pZip->m_central_directory_file_ofs = central_dir_ofs;
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-    if (pState->m_zip64)
-    {
-        /* Write zip64 end of central directory header */
-        mz_uint64 rel_ofs_to_zip64_ecdr = pZip->m_archive_size;
-
-        MZ_CLEAR_OBJ(hdr);
-        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDH_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG);
-        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - sizeof(mz_uint32) - sizeof(mz_uint64));
-        MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS, 0x031E); /* TODO: always Unix */
-        MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_NEEDED_OFS, 0x002D);
-        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
-        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
-        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_SIZE_OFS, central_dir_size);
-        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_OFS_OFS, central_dir_ofs);
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-
-        pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE;
-
-        /* Write zip64 end of central directory locator */
-        MZ_CLEAR_OBJ(hdr);
-        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG);
-        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS, rel_ofs_to_zip64_ecdr);
-        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS, 1);
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
-            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
-
-        pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE;
-    }
+//         pZip->m_archive_size += central_dir_size;
+//     }
 
-    /* Write end of central directory record */
-    MZ_CLEAR_OBJ(hdr);
-    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
-    MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
-    MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
-    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_size));
-    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_ofs));
+//     if (pState->m_zip64)
+//     {
+//         /* Write zip64 end of central directory header */
+//         mz_uint64 rel_ofs_to_zip64_ecdr = pZip->m_archive_size;
+
+//         MZ_CLEAR_OBJ(hdr);
+//         MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDH_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG);
+//         MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - sizeof(mz_uint32) - sizeof(mz_uint64));
+//         MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS, 0x031E); /* TODO: always Unix */
+//         MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_NEEDED_OFS, 0x002D);
+//         MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
+//         MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
+//         MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_SIZE_OFS, central_dir_size);
+//         MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_OFS_OFS, central_dir_ofs);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-    if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
+//         pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE;
 
-#ifndef MINIZ_NO_STDIO
-    if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
-        return mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
-#endif /* #ifndef MINIZ_NO_STDIO */
+//         /* Write zip64 end of central directory locator */
+//         MZ_CLEAR_OBJ(hdr);
+//         MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG);
+//         MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS, rel_ofs_to_zip64_ecdr);
+//         MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS, 1);
+//         if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
+//             return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-    pZip->m_archive_size += MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE;
+//         pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE;
+//     }
 
-    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
-    return MZ_TRUE;
-}
+//     /* Write end of central directory record */
+//     MZ_CLEAR_OBJ(hdr);
+//     MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
+//     MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
+//     MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
+//     MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_size));
+//     MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_ofs));
 
-mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize)
-{
-    if ((!ppBuf) || (!pSize))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
 
-    *ppBuf = NULL;
-    *pSize = 0;
+// #ifndef MINIZ_NO_STDIO
+//     if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
+//         return mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
+// #endif /* #ifndef MINIZ_NO_STDIO */
 
-    if ((!pZip) || (!pZip->m_pState))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     pZip->m_archive_size += MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE;
 
-    if (pZip->m_pWrite != mz_zip_heap_write_func)
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//     pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
+//     return MZ_TRUE;
+// }
 
-    if (!mz_zip_writer_finalize_archive(pZip))
-        return MZ_FALSE;
+// mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize)
+// {
+//     if ((!ppBuf) || (!pSize))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    *ppBuf = pZip->m_pState->m_pMem;
-    *pSize = pZip->m_pState->m_mem_size;
-    pZip->m_pState->m_pMem = NULL;
-    pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;
+//     *ppBuf = NULL;
+//     *pSize = 0;
 
-    return MZ_TRUE;
-}
+//     if ((!pZip) || (!pZip->m_pState))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-mz_bool mz_zip_writer_end(mz_zip_archive *pZip)
-{
-    return mz_zip_writer_end_internal(pZip, MZ_TRUE);
-}
+//     if (pZip->m_pWrite != mz_zip_heap_write_func)
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-#ifndef MINIZ_NO_STDIO
-mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
-{
-    return mz_zip_add_mem_to_archive_file_in_place_v2(pZip_filename, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, NULL);
-}
+//     if (!mz_zip_writer_finalize_archive(pZip))
+//         return MZ_FALSE;
 
-mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr)
-{
-    mz_bool status, created_new_archive = MZ_FALSE;
-    mz_zip_archive zip_archive;
-    struct MZ_FILE_STAT_STRUCT file_stat;
-    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;
+//     *ppBuf = pZip->m_pState->m_pMem;
+//     *pSize = pZip->m_pState->m_mem_size;
+//     pZip->m_pState->m_pMem = NULL;
+//     pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;
 
-    mz_zip_zero_struct(&zip_archive);
-    if ((int)level_and_flags < 0)
-        level_and_flags = MZ_DEFAULT_LEVEL;
+//     return MZ_TRUE;
+// }
 
-    if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
-    {
-        if (pErr)
-            *pErr = MZ_ZIP_INVALID_PARAMETER;
-        return MZ_FALSE;
-    }
+// mz_bool mz_zip_writer_end(mz_zip_archive *pZip)
+// {
+//     return mz_zip_writer_end_internal(pZip, MZ_TRUE);
+// }
 
-    if (!mz_zip_writer_validate_archive_name(pArchive_name))
-    {
-        if (pErr)
-            *pErr = MZ_ZIP_INVALID_FILENAME;
-        return MZ_FALSE;
-    }
+// #ifndef MINIZ_NO_STDIO
+// mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
+// {
+//     return mz_zip_add_mem_to_archive_file_in_place_v2(pZip_filename, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, NULL);
+// }
 
-    /* Important: The regular non-64 bit version of stat() can fail here if the file is very large, which could cause the archive to be overwritten. */
-    /* So be sure to compile with _LARGEFILE64_SOURCE 1 */
-    if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)
-    {
-        /* Create a new archive. */
-        if (!mz_zip_writer_init_file_v2(&zip_archive, pZip_filename, 0, level_and_flags))
-        {
-            if (pErr)
-                *pErr = zip_archive.m_last_error;
-            return MZ_FALSE;
-        }
+// mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr)
+// {
+//     mz_bool status, created_new_archive = MZ_FALSE;
+//     mz_zip_archive zip_archive;
+//     struct MZ_FILE_STAT_STRUCT file_stat;
+//     mz_zip_error actual_err = MZ_ZIP_NO_ERROR;
 
-        created_new_archive = MZ_TRUE;
-    }
-    else
-    {
-        /* Append to an existing archive. */
-        if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
-        {
-            if (pErr)
-                *pErr = zip_archive.m_last_error;
-            return MZ_FALSE;
-        }
+//     mz_zip_zero_struct(&zip_archive);
+//     if ((int)level_and_flags < 0)
+//         level_and_flags = MZ_DEFAULT_LEVEL;
 
-        if (!mz_zip_writer_init_from_reader_v2(&zip_archive, pZip_filename, level_and_flags))
-        {
-            if (pErr)
-                *pErr = zip_archive.m_last_error;
+//     if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
+//     {
+//         if (pErr)
+//             *pErr = MZ_ZIP_INVALID_PARAMETER;
+//         return MZ_FALSE;
+//     }
 
-            mz_zip_reader_end_internal(&zip_archive, MZ_FALSE);
+//     if (!mz_zip_writer_validate_archive_name(pArchive_name))
+//     {
+//         if (pErr)
+//             *pErr = MZ_ZIP_INVALID_FILENAME;
+//         return MZ_FALSE;
+//     }
 
-            return MZ_FALSE;
-        }
-    }
+//     /* Important: The regular non-64 bit version of stat() can fail here if the file is very large, which could cause the archive to be overwritten. */
+//     /* So be sure to compile with _LARGEFILE64_SOURCE 1 */
+//     if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)
+//     {
+//         /* Create a new archive. */
+//         if (!mz_zip_writer_init_file_v2(&zip_archive, pZip_filename, 0, level_and_flags))
+//         {
+//             if (pErr)
+//                 *pErr = zip_archive.m_last_error;
+//             return MZ_FALSE;
+//         }
 
-    status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
-    actual_err = zip_archive.m_last_error;
+//         created_new_archive = MZ_TRUE;
+//     }
+//     else
+//     {
+//         /* Append to an existing archive. */
+//         if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
+//         {
+//             if (pErr)
+//                 *pErr = zip_archive.m_last_error;
+//             return MZ_FALSE;
+//         }
 
-    /* Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.) */
-    if (!mz_zip_writer_finalize_archive(&zip_archive))
-    {
-        if (!actual_err)
-            actual_err = zip_archive.m_last_error;
+//         if (!mz_zip_writer_init_from_reader_v2(&zip_archive, pZip_filename, level_and_flags))
+//         {
+//             if (pErr)
+//                 *pErr = zip_archive.m_last_error;
 
-        status = MZ_FALSE;
-    }
+//             mz_zip_reader_end_internal(&zip_archive, MZ_FALSE);
 
-    if (!mz_zip_writer_end_internal(&zip_archive, status))
-    {
-        if (!actual_err)
-            actual_err = zip_archive.m_last_error;
+//             return MZ_FALSE;
+//         }
+//     }
 
-        status = MZ_FALSE;
-    }
+//     status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
+//     actual_err = zip_archive.m_last_error;
 
-    if ((!status) && (created_new_archive))
-    {
-        /* It's a new archive and something went wrong, so just delete it. */
-        int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
-        (void)ignoredStatus;
-    }
+//     /* Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.) */
+//     if (!mz_zip_writer_finalize_archive(&zip_archive))
+//     {
+//         if (!actual_err)
+//             actual_err = zip_archive.m_last_error;
 
-    if (pErr)
-        *pErr = actual_err;
+//         status = MZ_FALSE;
+//     }
 
-    return status;
-}
+//     if (!mz_zip_writer_end_internal(&zip_archive, status))
+//     {
+//         if (!actual_err)
+//             actual_err = zip_archive.m_last_error;
 
-void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr)
-{
-    mz_uint32 file_index;
-    mz_zip_archive zip_archive;
-    void *p = NULL;
+//         status = MZ_FALSE;
+//     }
 
-    if (pSize)
-        *pSize = 0;
+//     if ((!status) && (created_new_archive))
+//     {
+//         /* It's a new archive and something went wrong, so just delete it. */
+//         int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
+//         (void)ignoredStatus;
+//     }
 
-    if ((!pZip_filename) || (!pArchive_name))
-    {
-        if (pErr)
-            *pErr = MZ_ZIP_INVALID_PARAMETER;
+//     if (pErr)
+//         *pErr = actual_err;
 
-        return NULL;
-    }
+//     return status;
+// }
 
-    mz_zip_zero_struct(&zip_archive);
-    if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
-    {
-        if (pErr)
-            *pErr = zip_archive.m_last_error;
+// void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr)
+// {
+//     mz_uint32 file_index;
+//     mz_zip_archive zip_archive;
+//     void *p = NULL;
 
-        return NULL;
-    }
+//     if (pSize)
+//         *pSize = 0;
 
-    if (mz_zip_reader_locate_file_v2(&zip_archive, pArchive_name, pComment, flags, &file_index))
-    {
-        p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
-    }
+//     if ((!pZip_filename) || (!pArchive_name))
+//     {
+//         if (pErr)
+//             *pErr = MZ_ZIP_INVALID_PARAMETER;
 
-    mz_zip_reader_end_internal(&zip_archive, p != NULL);
+//         return NULL;
+//     }
 
-    if (pErr)
-        *pErr = zip_archive.m_last_error;
+//     mz_zip_zero_struct(&zip_archive);
+//     if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
+//     {
+//         if (pErr)
+//             *pErr = zip_archive.m_last_error;
 
-    return p;
-}
+//         return NULL;
+//     }
 
-void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)
-{
-    return mz_zip_extract_archive_file_to_heap_v2(pZip_filename, pArchive_name, NULL, pSize, flags, NULL);
-}
+//     if (mz_zip_reader_locate_file_v2(&zip_archive, pArchive_name, pComment, flags, &file_index))
+//     {
+//         p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
+//     }
+
+//     mz_zip_reader_end_internal(&zip_archive, p != NULL);
+
+//     if (pErr)
+//         *pErr = zip_archive.m_last_error;
+
+//     return p;
+// }
+
+// void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)
+// {
+//     return mz_zip_extract_archive_file_to_heap_v2(pZip_filename, pArchive_name, NULL, pSize, flags, NULL);
+// }
 
-#endif /* #ifndef MINIZ_NO_STDIO */
+// #endif /* #ifndef MINIZ_NO_STDIO */
 
-#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */
+// #endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */
 
 /* ------------------- Misc utils */
 
-mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip)
-{
-    return pZip ? pZip->m_zip_mode : MZ_ZIP_MODE_INVALID;
-}
+// mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip)
+// {
+//     return pZip ? pZip->m_zip_mode : MZ_ZIP_MODE_INVALID;
+// }
 
-mz_zip_type mz_zip_get_type(mz_zip_archive *pZip)
-{
-    return pZip ? pZip->m_zip_type : MZ_ZIP_TYPE_INVALID;
-}
+// mz_zip_type mz_zip_get_type(mz_zip_archive *pZip)
+// {
+//     return pZip ? pZip->m_zip_type : MZ_ZIP_TYPE_INVALID;
+// }
 
-mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num)
-{
-    mz_zip_error prev_err;
+// mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num)
+// {
+//     mz_zip_error prev_err;
 
-    if (!pZip)
-        return MZ_ZIP_INVALID_PARAMETER;
+//     if (!pZip)
+//         return MZ_ZIP_INVALID_PARAMETER;
 
-    prev_err = pZip->m_last_error;
+//     prev_err = pZip->m_last_error;
 
-    pZip->m_last_error = err_num;
-    return prev_err;
-}
+//     pZip->m_last_error = err_num;
+//     return prev_err;
+// }
 
-mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip)
-{
-    if (!pZip)
-        return MZ_ZIP_INVALID_PARAMETER;
+// mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip)
+// {
+//     if (!pZip)
+//         return MZ_ZIP_INVALID_PARAMETER;
 
-    return pZip->m_last_error;
-}
+//     return pZip->m_last_error;
+// }
 
-mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip)
-{
-    return mz_zip_set_last_error(pZip, MZ_ZIP_NO_ERROR);
-}
+// mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip)
+// {
+//     return mz_zip_set_last_error(pZip, MZ_ZIP_NO_ERROR);
+// }
 
-mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip)
-{
-    mz_zip_error prev_err;
+// mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip)
+// {
+//     mz_zip_error prev_err;
 
-    if (!pZip)
-        return MZ_ZIP_INVALID_PARAMETER;
+//     if (!pZip)
+//         return MZ_ZIP_INVALID_PARAMETER;
 
-    prev_err = pZip->m_last_error;
+//     prev_err = pZip->m_last_error;
 
-    pZip->m_last_error = MZ_ZIP_NO_ERROR;
-    return prev_err;
-}
+//     pZip->m_last_error = MZ_ZIP_NO_ERROR;
+//     return prev_err;
+// }
 
-const char *mz_zip_get_error_string(mz_zip_error mz_err)
-{
-    switch (mz_err)
-    {
-        case MZ_ZIP_NO_ERROR:
-            return "no error";
-        case MZ_ZIP_UNDEFINED_ERROR:
-            return "undefined error";
-        case MZ_ZIP_TOO_MANY_FILES:
-            return "too many files";
-        case MZ_ZIP_FILE_TOO_LARGE:
-            return "file too large";
-        case MZ_ZIP_UNSUPPORTED_METHOD:
-            return "unsupported method";
-        case MZ_ZIP_UNSUPPORTED_ENCRYPTION:
-            return "unsupported encryption";
-        case MZ_ZIP_UNSUPPORTED_FEATURE:
-            return "unsupported feature";
-        case MZ_ZIP_FAILED_FINDING_CENTRAL_DIR:
-            return "failed finding central directory";
-        case MZ_ZIP_NOT_AN_ARCHIVE:
-            return "not a ZIP archive";
-        case MZ_ZIP_INVALID_HEADER_OR_CORRUPTED:
-            return "invalid header or archive is corrupted";
-        case MZ_ZIP_UNSUPPORTED_MULTIDISK:
-            return "unsupported multidisk archive";
-        case MZ_ZIP_DECOMPRESSION_FAILED:
-            return "decompression failed or archive is corrupted";
-        case MZ_ZIP_COMPRESSION_FAILED:
-            return "compression failed";
-        case MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE:
-            return "unexpected decompressed size";
-        case MZ_ZIP_CRC_CHECK_FAILED:
-            return "CRC-32 check failed";
-        case MZ_ZIP_UNSUPPORTED_CDIR_SIZE:
-            return "unsupported central directory size";
-        case MZ_ZIP_ALLOC_FAILED:
-            return "allocation failed";
-        case MZ_ZIP_FILE_OPEN_FAILED:
-            return "file open failed";
-        case MZ_ZIP_FILE_CREATE_FAILED:
-            return "file create failed";
-        case MZ_ZIP_FILE_WRITE_FAILED:
-            return "file write failed";
-        case MZ_ZIP_FILE_READ_FAILED:
-            return "file read failed";
-        case MZ_ZIP_FILE_CLOSE_FAILED:
-            return "file close failed";
-        case MZ_ZIP_FILE_SEEK_FAILED:
-            return "file seek failed";
-        case MZ_ZIP_FILE_STAT_FAILED:
-            return "file stat failed";
-        case MZ_ZIP_INVALID_PARAMETER:
-            return "invalid parameter";
-        case MZ_ZIP_INVALID_FILENAME:
-            return "invalid filename";
-        case MZ_ZIP_BUF_TOO_SMALL:
-            return "buffer too small";
-        case MZ_ZIP_INTERNAL_ERROR:
-            return "internal error";
-        case MZ_ZIP_FILE_NOT_FOUND:
-            return "file not found";
-        case MZ_ZIP_ARCHIVE_TOO_LARGE:
-            return "archive is too large";
-        case MZ_ZIP_VALIDATION_FAILED:
-            return "validation failed";
-        case MZ_ZIP_WRITE_CALLBACK_FAILED:
-            return "write calledback failed";
-        default:
-            break;
-    }
+// const char *mz_zip_get_error_string(mz_zip_error mz_err)
+// {
+//     switch (mz_err)
+//     {
+//         case MZ_ZIP_NO_ERROR:
+//             return "no error";
+//         case MZ_ZIP_UNDEFINED_ERROR:
+//             return "undefined error";
+//         case MZ_ZIP_TOO_MANY_FILES:
+//             return "too many files";
+//         case MZ_ZIP_FILE_TOO_LARGE:
+//             return "file too large";
+//         case MZ_ZIP_UNSUPPORTED_METHOD:
+//             return "unsupported method";
+//         case MZ_ZIP_UNSUPPORTED_ENCRYPTION:
+//             return "unsupported encryption";
+//         case MZ_ZIP_UNSUPPORTED_FEATURE:
+//             return "unsupported feature";
+//         case MZ_ZIP_FAILED_FINDING_CENTRAL_DIR:
+//             return "failed finding central directory";
+//         case MZ_ZIP_NOT_AN_ARCHIVE:
+//             return "not a ZIP archive";
+//         case MZ_ZIP_INVALID_HEADER_OR_CORRUPTED:
+//             return "invalid header or archive is corrupted";
+//         case MZ_ZIP_UNSUPPORTED_MULTIDISK:
+//             return "unsupported multidisk archive";
+//         case MZ_ZIP_DECOMPRESSION_FAILED:
+//             return "decompression failed or archive is corrupted";
+//         case MZ_ZIP_COMPRESSION_FAILED:
+//             return "compression failed";
+//         case MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE:
+//             return "unexpected decompressed size";
+//         case MZ_ZIP_CRC_CHECK_FAILED:
+//             return "CRC-32 check failed";
+//         case MZ_ZIP_UNSUPPORTED_CDIR_SIZE:
+//             return "unsupported central directory size";
+//         case MZ_ZIP_ALLOC_FAILED:
+//             return "allocation failed";
+//         case MZ_ZIP_FILE_OPEN_FAILED:
+//             return "file open failed";
+//         case MZ_ZIP_FILE_CREATE_FAILED:
+//             return "file create failed";
+//         case MZ_ZIP_FILE_WRITE_FAILED:
+//             return "file write failed";
+//         case MZ_ZIP_FILE_READ_FAILED:
+//             return "file read failed";
+//         case MZ_ZIP_FILE_CLOSE_FAILED:
+//             return "file close failed";
+//         case MZ_ZIP_FILE_SEEK_FAILED:
+//             return "file seek failed";
+//         case MZ_ZIP_FILE_STAT_FAILED:
+//             return "file stat failed";
+//         case MZ_ZIP_INVALID_PARAMETER:
+//             return "invalid parameter";
+//         case MZ_ZIP_INVALID_FILENAME:
+//             return "invalid filename";
+//         case MZ_ZIP_BUF_TOO_SMALL:
+//             return "buffer too small";
+//         case MZ_ZIP_INTERNAL_ERROR:
+//             return "internal error";
+//         case MZ_ZIP_FILE_NOT_FOUND:
+//             return "file not found";
+//         case MZ_ZIP_ARCHIVE_TOO_LARGE:
+//             return "archive is too large";
+//         case MZ_ZIP_VALIDATION_FAILED:
+//             return "validation failed";
+//         case MZ_ZIP_WRITE_CALLBACK_FAILED:
+//             return "write calledback failed";
+//         default:
+//             break;
+//     }
 
-    return "unknown error";
-}
+//     return "unknown error";
+// }
 
 /* Note: Just because the archive is not zip64 doesn't necessarily mean it doesn't have Zip64 extended information extra field, argh. */
-mz_bool mz_zip_is_zip64(mz_zip_archive *pZip)
-{
-    if ((!pZip) || (!pZip->m_pState))
-        return MZ_FALSE;
+// mz_bool mz_zip_is_zip64(mz_zip_archive *pZip)
+// {
+//     if ((!pZip) || (!pZip->m_pState))
+//         return MZ_FALSE;
 
-    return pZip->m_pState->m_zip64;
-}
+//     return pZip->m_pState->m_zip64;
+// }
 
-size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip)
-{
-    if ((!pZip) || (!pZip->m_pState))
-        return 0;
+// size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip)
+// {
+//     if ((!pZip) || (!pZip->m_pState))
+//         return 0;
 
-    return pZip->m_pState->m_central_dir.m_size;
-}
+//     return pZip->m_pState->m_central_dir.m_size;
+// }
 
-mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)
-{
-    return pZip ? pZip->m_total_files : 0;
-}
+// mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)
+// {
+//     return pZip ? pZip->m_total_files : 0;
+// }
 
-mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip)
-{
-    if (!pZip)
-        return 0;
-    return pZip->m_archive_size;
-}
+// mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip)
+// {
+//     if (!pZip)
+//         return 0;
+//     return pZip->m_archive_size;
+// }
 
-mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip)
-{
-    if ((!pZip) || (!pZip->m_pState))
-        return 0;
-    return pZip->m_pState->m_file_archive_start_ofs;
-}
+// mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip)
+// {
+//     if ((!pZip) || (!pZip->m_pState))
+//         return 0;
+//     return pZip->m_pState->m_file_archive_start_ofs;
+// }
 
-MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip)
-{
-    if ((!pZip) || (!pZip->m_pState))
-        return 0;
-    return pZip->m_pState->m_pFile;
-}
+// MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip)
+// {
+//     if ((!pZip) || (!pZip->m_pState))
+//         return 0;
+//     return pZip->m_pState->m_pFile;
+// }
 
-size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n)
-{
-    if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pZip->m_pRead))
-        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+// size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n)
+// {
+//     if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pZip->m_pRead))
+//         return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
 
-    return pZip->m_pRead(pZip->m_pIO_opaque, file_ofs, pBuf, n);
-}
+//     return pZip->m_pRead(pZip->m_pIO_opaque, file_ofs, pBuf, n);
+// }
 
-mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)
-{
-    mz_uint n;
-    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
-    if (!p)
-    {
-        if (filename_buf_size)
-            pFilename[0] = '\0';
-        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
-        return 0;
-    }
-    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-    if (filename_buf_size)
-    {
-        n = MZ_MIN(n, filename_buf_size - 1);
-        memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
-        pFilename[n] = '\0';
-    }
-    return n + 1;
-}
+// mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)
+// {
+//     mz_uint n;
+//     const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
+//     if (!p)
+//     {
+//         if (filename_buf_size)
+//             pFilename[0] = '\0';
+//         mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
+//         return 0;
+//     }
+//     n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+//     if (filename_buf_size)
+//     {
+//         n = MZ_MIN(n, filename_buf_size - 1);
+//         memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
+//         pFilename[n] = '\0';
+//     }
+//     return n + 1;
+// }
 
-mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
-{
-    return mz_zip_file_stat_internal(pZip, file_index, mz_zip_get_cdh(pZip, file_index), pStat, NULL);
-}
+// mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
+// {
+//     return mz_zip_file_stat_internal(pZip, file_index, mz_zip_get_cdh(pZip, file_index), pStat, NULL);
+// }
 
-mz_bool mz_zip_end(mz_zip_archive *pZip)
-{
-    if (!pZip)
-        return MZ_FALSE;
-
-    if (pZip->m_zip_mode == MZ_ZIP_MODE_READING)
-        return mz_zip_reader_end(pZip);
-#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-    else if ((pZip->m_zip_mode == MZ_ZIP_MODE_WRITING) || (pZip->m_zip_mode == MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED))
-        return mz_zip_writer_end(pZip);
-#endif
+// mz_bool mz_zip_end(mz_zip_archive *pZip)
+// {
+//     if (!pZip)
+//         return MZ_FALSE;
 
-    return MZ_FALSE;
-}
+//     if (pZip->m_zip_mode == MZ_ZIP_MODE_READING)
+//         return mz_zip_reader_end(pZip);
+// #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
+//     else if ((pZip->m_zip_mode == MZ_ZIP_MODE_WRITING) || (pZip->m_zip_mode == MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED))
+//         return mz_zip_writer_end(pZip);
+// #endif
 
-#ifdef __cplusplus
-}
-#endif
+//     return MZ_FALSE;
+// }
+
+// #ifdef __cplusplus
+// }
+// #endif
 
-#endif /*#ifndef MINIZ_NO_ARCHIVE_APIS*/
+// #endif /*#ifndef MINIZ_NO_ARCHIVE_APIS*/
