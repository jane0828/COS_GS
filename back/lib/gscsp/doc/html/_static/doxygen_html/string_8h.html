<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ProductInterfaceApplication: lib/libutil/include/gs/util/string.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProductInterfaceApplication
   &#160;<span id="projectnumber">2.7.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_d33dcd303d95ce5fe59e2f71a2621271.html">libutil</a></li><li class="navelem"><a class="el" href="dir_61da064695c3da01adeedb707fb3606a.html">include</a></li><li class="navelem"><a class="el" href="dir_62973ac180f0e2ca4a057023376cc3c9.html">gs</a></li><li class="navelem"><a class="el" href="dir_9a1bdad0e085a4bbb311cde986f47fce.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">string.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>String utilitizes. </p>
<p>All string parsing functions will return <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbca21d0994cd19d1d3512772ef4772f5383" title="Success - ok (POSIX). ">GS_OK</a> if the string was parsed entirely. If the string contains characters that are not part of the selected base, the functions will return <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbcafc03c418f355721ec91eebd6c9ed7e81" title="Data error (GOMspace). ">GS_ERROR_DATA</a>. If the value parsed is bigger than the output type, the functions will return <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbcacf41437682e204d2d2431ab4cc77065b" title="Value too large to be stored in data type (POSIX.1: EOVERFLOW). ">GS_ERROR_OVERFLOW</a>. Spaces are ignored by all functions. </p>
</div><div class="textblock"><code>#include &lt;<a class="el" href="libutil_2include_2gs_2util_2error_8h_source.html">gs/util/error.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="string_8h_source.html">string.h</a>&gt;</code><br />
</div>
<p><a href="string_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a33b1d47cdab6f8f9478b29ec01dd5cc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33b1d47cdab6f8f9478b29ec01dd5cc0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a33b1d47cdab6f8f9478b29ec01dd5cc0">GS_STRINGZ</a>(x)&#160;&#160;&#160;#x</td></tr>
<tr class="memdesc:a33b1d47cdab6f8f9478b29ec01dd5cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro helper for concatening tokens. <br /></td></tr>
<tr class="separator:a33b1d47cdab6f8f9478b29ec01dd5cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886e77ebda6d3a7e9ffc4f745590d045"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a886e77ebda6d3a7e9ffc4f745590d045"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a886e77ebda6d3a7e9ffc4f745590d045">GS_DEF2STRING</a>(x)&#160;&#160;&#160;<a class="el" href="string_8h.html#a33b1d47cdab6f8f9478b29ec01dd5cc0">GS_STRINGZ</a>(x)</td></tr>
<tr class="memdesc:a886e77ebda6d3a7e9ffc4f745590d045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringify a preprocessing token. <br /></td></tr>
<tr class="separator:a886e77ebda6d3a7e9ffc4f745590d045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cadd89ed93705426116daf0a52bcb79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cadd89ed93705426116daf0a52bcb79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a8cadd89ed93705426116daf0a52bcb79">GS_STRNCPY</a>(dst,  src)&#160;&#160;&#160;strncpy(dst,src,<a class="el" href="libutil_2include_2gs_2util_2types_8h.html#a5f7faa614a491f67774e1fdf837e0221">GS_ARRAY_SIZE</a>(dst));dst[<a class="el" href="libutil_2include_2gs_2util_2types_8h.html#a5f7faa614a491f67774e1fdf837e0221">GS_ARRAY_SIZE</a>(dst)-1] = 0</td></tr>
<tr class="memdesc:a8cadd89ed93705426116daf0a52bcb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strncpy (using size of destination) and forced zero termination. <br /></td></tr>
<tr class="separator:a8cadd89ed93705426116daf0a52bcb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a799d737582c2b0a65cf3851d77caec1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a799d737582c2b0a65cf3851d77caec1c">gs_string_to_int32</a> (const char *string, int32_t *value)</td></tr>
<tr class="memdesc:a799d737582c2b0a65cf3851d77caec1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to int32 (decimal or hexadecimal).  <a href="#a799d737582c2b0a65cf3851d77caec1c">More...</a><br /></td></tr>
<tr class="separator:a799d737582c2b0a65cf3851d77caec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25742ce805423d0aa63a9ea67d1807ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a25742ce805423d0aa63a9ea67d1807ef">gs_string_to_uint32</a> (const char *string, uint32_t *value)</td></tr>
<tr class="memdesc:a25742ce805423d0aa63a9ea67d1807ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to uint32 (decimal or hexadecimal).  <a href="#a25742ce805423d0aa63a9ea67d1807ef">More...</a><br /></td></tr>
<tr class="separator:a25742ce805423d0aa63a9ea67d1807ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cf68f8115ad9e0567d4d23ef1378fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a57cf68f8115ad9e0567d4d23ef1378fb">gs_string_to_int64</a> (const char *string, int64_t *value)</td></tr>
<tr class="memdesc:a57cf68f8115ad9e0567d4d23ef1378fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to int64 (decimal or hexadecimal).  <a href="#a57cf68f8115ad9e0567d4d23ef1378fb">More...</a><br /></td></tr>
<tr class="separator:a57cf68f8115ad9e0567d4d23ef1378fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7239cb0e60456c8d54303c2cd7ea2e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a7239cb0e60456c8d54303c2cd7ea2e52">gs_string_to_uint64</a> (const char *string, uint64_t *value)</td></tr>
<tr class="memdesc:a7239cb0e60456c8d54303c2cd7ea2e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to uint64 (decimal or hexadecimal).  <a href="#a7239cb0e60456c8d54303c2cd7ea2e52">More...</a><br /></td></tr>
<tr class="separator:a7239cb0e60456c8d54303c2cd7ea2e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667e7518241b8c24abc962bc8dc4942d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a667e7518241b8c24abc962bc8dc4942d">gs_string_to_int8</a> (const char *string, int8_t *value)</td></tr>
<tr class="memdesc:a667e7518241b8c24abc962bc8dc4942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to int8 (decimal or hexadecimal).  <a href="#a667e7518241b8c24abc962bc8dc4942d">More...</a><br /></td></tr>
<tr class="separator:a667e7518241b8c24abc962bc8dc4942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1047e7f27a38d9c03c67abba1d6584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#aba1047e7f27a38d9c03c67abba1d6584">gs_string_to_uint8</a> (const char *string, uint8_t *value)</td></tr>
<tr class="memdesc:aba1047e7f27a38d9c03c67abba1d6584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to uint8 (decimal or hexadecimal).  <a href="#aba1047e7f27a38d9c03c67abba1d6584">More...</a><br /></td></tr>
<tr class="separator:aba1047e7f27a38d9c03c67abba1d6584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d4a8092528ca798a86c7052d4f7eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a196d4a8092528ca798a86c7052d4f7eb">gs_string_to_int16</a> (const char *string, int16_t *value)</td></tr>
<tr class="memdesc:a196d4a8092528ca798a86c7052d4f7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to int16 (decimal or hexadecimal).  <a href="#a196d4a8092528ca798a86c7052d4f7eb">More...</a><br /></td></tr>
<tr class="separator:a196d4a8092528ca798a86c7052d4f7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b68d6f18861ae50823ff534bc551365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a3b68d6f18861ae50823ff534bc551365">gs_string_to_uint16</a> (const char *string, uint16_t *value)</td></tr>
<tr class="memdesc:a3b68d6f18861ae50823ff534bc551365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to uint16 (decimal or hexadecimal).  <a href="#a3b68d6f18861ae50823ff534bc551365">More...</a><br /></td></tr>
<tr class="separator:a3b68d6f18861ae50823ff534bc551365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec22c490df1810c17c4b456b8b575b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a7ec22c490df1810c17c4b456b8b575b3">gs_string_hex_to_uint32</a> (const char *string, uint32_t *value)</td></tr>
<tr class="memdesc:a7ec22c490df1810c17c4b456b8b575b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to uint32 (hexadecimal).  <a href="#a7ec22c490df1810c17c4b456b8b575b3">More...</a><br /></td></tr>
<tr class="separator:a7ec22c490df1810c17c4b456b8b575b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f671278893975d4069b6b40c41e8357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a0f671278893975d4069b6b40c41e8357">gs_string_hex_to_uint64</a> (const char *string, uint64_t *value)</td></tr>
<tr class="memdesc:a0f671278893975d4069b6b40c41e8357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to uint64 (hexadecimal).  <a href="#a0f671278893975d4069b6b40c41e8357">More...</a><br /></td></tr>
<tr class="separator:a0f671278893975d4069b6b40c41e8357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563c64b09477621c294a91717e1de0ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a563c64b09477621c294a91717e1de0ac">gs_string_to_bool</a> (const char *string, bool *pvalue)</td></tr>
<tr class="memdesc:a563c64b09477621c294a91717e1de0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to boolean.  <a href="#a563c64b09477621c294a91717e1de0ac">More...</a><br /></td></tr>
<tr class="separator:a563c64b09477621c294a91717e1de0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb47b8fe0246620b58c7e323eba4c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a3bb47b8fe0246620b58c7e323eba4c48">gs_string_to_float</a> (const char *string, float *pvalue)</td></tr>
<tr class="memdesc:a3bb47b8fe0246620b58c7e323eba4c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to float.  <a href="#a3bb47b8fe0246620b58c7e323eba4c48">More...</a><br /></td></tr>
<tr class="separator:a3bb47b8fe0246620b58c7e323eba4c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552b642283d80b4ff7389c440d88df8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a552b642283d80b4ff7389c440d88df8b">gs_string_to_double</a> (const char *string, double *pvalue)</td></tr>
<tr class="memdesc:a552b642283d80b4ff7389c440d88df8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to double.  <a href="#a552b642283d80b4ff7389c440d88df8b">More...</a><br /></td></tr>
<tr class="separator:a552b642283d80b4ff7389c440d88df8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38eb4004f1100099d56528bda7151750"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a38eb4004f1100099d56528bda7151750">gs_string_from_bool</a> (bool value)</td></tr>
<tr class="memdesc:a38eb4004f1100099d56528bda7151750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string for boolean value (true or false).  <a href="#a38eb4004f1100099d56528bda7151750">More...</a><br /></td></tr>
<tr class="separator:a38eb4004f1100099d56528bda7151750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09fb1246c82338a7fcf11e4dc9c8e36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ae09fb1246c82338a7fcf11e4dc9c8e36">gs_string_to_pointer</a> (const char *string, void **value)</td></tr>
<tr class="memdesc:ae09fb1246c82338a7fcf11e4dc9c8e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to pointer (decimal or hexadecimal).  <a href="#ae09fb1246c82338a7fcf11e4dc9c8e36">More...</a><br /></td></tr>
<tr class="separator:ae09fb1246c82338a7fcf11e4dc9c8e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fceb465c6f511fdf27b12d293911006"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a4fceb465c6f511fdf27b12d293911006">gs_string_bytesize</a> (long size, char *buffer, size_t buffer_size)</td></tr>
<tr class="memdesc:a4fceb465c6f511fdf27b12d293911006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format size as Bytes, Kilo or Mega.  <a href="#a4fceb465c6f511fdf27b12d293911006">More...</a><br /></td></tr>
<tr class="separator:a4fceb465c6f511fdf27b12d293911006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa28e53fc3a79ce82453f66964118a8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#aaaa28e53fc3a79ce82453f66964118a8">gs_string_strto32int</a> (const char *nptr, char **endptr, uint8_t base, <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> *err)</td></tr>
<tr class="memdesc:aaaa28e53fc3a79ce82453f66964118a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GS implementation of gcc's strtol Instead of setting errno this function takes a pointer to err which is set the same way as with gcc's strtol.  <a href="#aaaa28e53fc3a79ce82453f66964118a8">More...</a><br /></td></tr>
<tr class="separator:aaaa28e53fc3a79ce82453f66964118a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae947bccc033cd49d53561ca0faa3e47a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ae947bccc033cd49d53561ca0faa3e47a">gs_string_strto64uint</a> (const char *nptr, char **endptr, uint8_t base, <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> *err)</td></tr>
<tr class="memdesc:ae947bccc033cd49d53561ca0faa3e47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GS implementation of gcc's strtoul Instead of setting errno this function takes a pointer to err which is set the same way as with gcc's strtoul.  <a href="#ae947bccc033cd49d53561ca0faa3e47a">More...</a><br /></td></tr>
<tr class="separator:ae947bccc033cd49d53561ca0faa3e47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac717927a1e5b25f439dfefa7c30ef71f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ac717927a1e5b25f439dfefa7c30ef71f">gs_string_strto64int</a> (const char *nptr, char **endptr, uint8_t base, <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> *err)</td></tr>
<tr class="memdesc:ac717927a1e5b25f439dfefa7c30ef71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GS implementation of gcc's strtoul Instead of setting errno this function takes a pointer to err which is set the same way as with gcc's strtoul.  <a href="#ac717927a1e5b25f439dfefa7c30ef71f">More...</a><br /></td></tr>
<tr class="separator:ac717927a1e5b25f439dfefa7c30ef71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce79624ffc8775709f13736c82fac17"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a8ce79624ffc8775709f13736c82fac17">gs_string_strto32uint</a> (const char *nptr, char **endptr, uint8_t base, <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> *err)</td></tr>
<tr class="memdesc:a8ce79624ffc8775709f13736c82fac17"><td class="mdescLeft">&#160;</td><td class="mdescRight">GS implementation of gcc's strtoul Instead of setting errno this function takes a pointer to err which is set the same way as with gcc's strtoul.  <a href="#a8ce79624ffc8775709f13736c82fac17">More...</a><br /></td></tr>
<tr class="separator:a8ce79624ffc8775709f13736c82fac17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839145ebb114212fb2b6c079901626e3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a839145ebb114212fb2b6c079901626e3">gs_string_skip_leading_spaces</a> (const char *string)</td></tr>
<tr class="memdesc:a839145ebb114212fb2b6c079901626e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to first none-space character.  <a href="#a839145ebb114212fb2b6c079901626e3">More...</a><br /></td></tr>
<tr class="separator:a839145ebb114212fb2b6c079901626e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7999ef8c1cf27b8ef0fb1d882ef28884"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a7999ef8c1cf27b8ef0fb1d882ef28884">gs_string_empty</a> (const char *string)</td></tr>
<tr class="memdesc:a7999ef8c1cf27b8ef0fb1d882ef28884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string is NULL or empty.  <a href="#a7999ef8c1cf27b8ef0fb1d882ef28884">More...</a><br /></td></tr>
<tr class="separator:a7999ef8c1cf27b8ef0fb1d882ef28884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50444f8514e9e9008b4f7b834198a510"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a50444f8514e9e9008b4f7b834198a510">gs_string_match</a> (const char *pattern, const char *string)</td></tr>
<tr class="memdesc:a50444f8514e9e9008b4f7b834198a510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insentive wilcard match (similiar to fnmatch).  <a href="#a50444f8514e9e9008b4f7b834198a510">More...</a><br /></td></tr>
<tr class="separator:a50444f8514e9e9008b4f7b834198a510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56be1a264cccf046e64e4e47939ba508"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a56be1a264cccf046e64e4e47939ba508">gs_string_has_wildcards</a> (const char *string)</td></tr>
<tr class="memdesc:a56be1a264cccf046e64e4e47939ba508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>true</em> if string contains wildcards.  <a href="#a56be1a264cccf046e64e4e47939ba508">More...</a><br /></td></tr>
<tr class="separator:a56be1a264cccf046e64e4e47939ba508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472626a74f2b1d42a100b8e0cfea7a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a472626a74f2b1d42a100b8e0cfea7a3c">gs_string_trim</a> (char *buffer, size_t buffer_size)</td></tr>
<tr class="memdesc:a472626a74f2b1d42a100b8e0cfea7a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim string in buffer by removing leading/trailing white space.  <a href="#a472626a74f2b1d42a100b8e0cfea7a3c">More...</a><br /></td></tr>
<tr class="separator:a472626a74f2b1d42a100b8e0cfea7a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5443b703dd4d9184422afca408d03a99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a5443b703dd4d9184422afca408d03a99">gs_string_endswith</a> (const char *string, const char *endswith)</td></tr>
<tr class="memdesc:a5443b703dd4d9184422afca408d03a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>true</em> if string ends with endswith.  <a href="#a5443b703dd4d9184422afca408d03a99">More...</a><br /></td></tr>
<tr class="separator:a5443b703dd4d9184422afca408d03a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2679585f175d576c5485c87a0e1764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a0c2679585f175d576c5485c87a0e1764">gs_string_get_suboption</a> (const char *options, const char *suboption, char *buf, size_t buf_size)</td></tr>
<tr class="memdesc:a0c2679585f175d576c5485c87a0e1764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract suboption from a string.  <a href="#a0c2679585f175d576c5485c87a0e1764">More...</a><br /></td></tr>
<tr class="separator:a0c2679585f175d576c5485c87a0e1764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b5df1b68469ad47a7e873f1b8bec99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a16b5df1b68469ad47a7e873f1b8bec99">gs_string_get_suboption_string</a> (const char *options, const char *suboption, const char *def, char *buf, size_t buf_size)</td></tr>
<tr class="memdesc:a16b5df1b68469ad47a7e873f1b8bec99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract suboption (as string) from a string.  <a href="#a16b5df1b68469ad47a7e873f1b8bec99">More...</a><br /></td></tr>
<tr class="separator:a16b5df1b68469ad47a7e873f1b8bec99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa7590432077d2efe5fc6be1a33737f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a7fa7590432077d2efe5fc6be1a33737f">gs_string_get_suboption_uint8</a> (const char *options, const char *suboption, uint8_t def, uint8_t *value)</td></tr>
<tr class="memdesc:a7fa7590432077d2efe5fc6be1a33737f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract suboption (as uint8) from a string.  <a href="#a7fa7590432077d2efe5fc6be1a33737f">More...</a><br /></td></tr>
<tr class="separator:a7fa7590432077d2efe5fc6be1a33737f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c281153f71aa4ca1ae76250a5bfff7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a4c281153f71aa4ca1ae76250a5bfff7c">gs_string_get_suboption_uint16</a> (const char *options, const char *suboption, uint16_t def, uint16_t *value)</td></tr>
<tr class="memdesc:a4c281153f71aa4ca1ae76250a5bfff7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract suboption (as uint16) from a string.  <a href="#a4c281153f71aa4ca1ae76250a5bfff7c">More...</a><br /></td></tr>
<tr class="separator:a4c281153f71aa4ca1ae76250a5bfff7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb987e96ad2b88d166d892fae410ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a4bb987e96ad2b88d166d892fae410ee4">gs_string_get_suboption_uint32</a> (const char *options, const char *suboption, uint32_t def, uint32_t *value)</td></tr>
<tr class="memdesc:a4bb987e96ad2b88d166d892fae410ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract suboption (as uint32) from a string.  <a href="#a4bb987e96ad2b88d166d892fae410ee4">More...</a><br /></td></tr>
<tr class="separator:a4bb987e96ad2b88d166d892fae410ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04480c8dd56c1d585611534b93a90a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ae04480c8dd56c1d585611534b93a90a0">gs_string_get_suboption_bool</a> (const char *options, const char *suboption, bool def, bool *value)</td></tr>
<tr class="memdesc:ae04480c8dd56c1d585611534b93a90a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract suboption (as bool) from a string.  <a href="#ae04480c8dd56c1d585611534b93a90a0">More...</a><br /></td></tr>
<tr class="separator:ae04480c8dd56c1d585611534b93a90a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd9f9ed989275267f8b395b7cb923a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a1bd9f9ed989275267f8b395b7cb923a7">gs_snprintf</a> (char *buffer, size_t buffer_size, const char *format,...)</td></tr>
<tr class="memdesc:a1bd9f9ed989275267f8b395b7cb923a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convience wrapping of standard snprintf.  <a href="#a1bd9f9ed989275267f8b395b7cb923a7">More...</a><br /></td></tr>
<tr class="separator:a1bd9f9ed989275267f8b395b7cb923a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1bd9f9ed989275267f8b395b7cb923a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gs_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convience wrapping of standard snprintf. </p>
<p>Implemented using standard vsnprintf().</p>
<p>In the <em>old</em> days, it was possible to suppress return value from snprintf(), by using <em></em>(void) cast. This is no longer supported in GCC 7, which makes it difficult to support older/newer GCC versions. This wrapper has the same functionality as standard snprintf, but eliminates the GCC check - it's still up to the programmer to take proper action in case of truncation or other errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>user allocated buffer for receiving formatted string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of <em>buffer</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>printf syntax </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value from vsnprintf(). On success, number of characters printed (excluding the null byte used to end output to <em>buffer</em>). </dd></dl>

</div>
</div>
<a class="anchor" id="a4fceb465c6f511fdf27b12d293911006"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* gs_string_bytesize </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format size as Bytes, Kilo or Mega. </p>
<p>Output examples: <em>512.0B</em>, <em>1.0K</em> and <em>1.0M</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>formatted size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of <em>buf</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a7999ef8c1cf27b8ef0fb1d882ef28884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gs_string_empty </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string is NULL or empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if string is empty or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a5443b703dd4d9184422afca408d03a99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gs_string_endswith </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>endswith</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <em>true</em> if string ends with endswith. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endswith</td><td>string that string should end with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if string endswith endswith </dd></dl>

</div>
</div>
<a class="anchor" id="a38eb4004f1100099d56528bda7151750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* gs_string_from_bool </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return string for boolean value (true or false). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>'true'</em> if input is true, else <em>'false'</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c2679585f175d576c5485c87a0e1764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_get_suboption </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suboption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract suboption from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options string, e.g. "/dev/ttyUSB1,speed=9600,parity=no,databits=8". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suboption</td><td>sub-option to extract. If NULL or empty, the first option will be extracted (if present). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>user buffer for returning value of sub-option. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_size</td><td>size of <em>buf</em> user buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ae04480c8dd56c1d585611534b93a90a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_get_suboption_bool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suboption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract suboption (as bool) from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options string, e.g. "/dev/ttyUSB1,speed=9600,parity=no,databits=8". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suboption</td><td>sub-option to extract. If NULL or empty, the first option will be extracted (if present). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>default value, returned if sub-option isn't found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>user supplied buffer for returning the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the sub-option isn't found, the <em>def</em> default value will be copied to <em>value</em> and <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbca21d0994cd19d1d3512772ef4772f5383" title="Success - ok (POSIX). ">GS_OK</a> will be returned. </dd>
<dd>
GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a16b5df1b68469ad47a7e873f1b8bec99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_get_suboption_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suboption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract suboption (as string) from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options string, e.g. "/dev/ttyUSB1,speed=9600,parity=no,databits=8". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suboption</td><td>sub-option to extract. If NULL or empty, the first option will be extracted (if present). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>default value, returned if sub-option isn't found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>user buffer for returning value of sub-option. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_size</td><td>size of <em>buf</em> user buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the sub-option isn't found, the <em>def</em> default value will be copied to <em>buf</em> and <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbca21d0994cd19d1d3512772ef4772f5383" title="Success - ok (POSIX). ">GS_OK</a> will be returned. </dd>
<dd>
GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a4c281153f71aa4ca1ae76250a5bfff7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_get_suboption_uint16 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suboption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract suboption (as uint16) from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options string, e.g. "/dev/ttyUSB1,speed=9600,parity=no,databits=8". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suboption</td><td>sub-option to extract. If NULL or empty, the first option will be extracted (if present). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>default value, returned if sub-option isn't found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>user supplied buffer for returning the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the sub-option isn't found, the <em>def</em> default value will be copied to <em>value</em> and <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbca21d0994cd19d1d3512772ef4772f5383" title="Success - ok (POSIX). ">GS_OK</a> will be returned. </dd>
<dd>
GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a4bb987e96ad2b88d166d892fae410ee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_get_suboption_uint32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suboption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract suboption (as uint32) from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options string, e.g. "/dev/ttyUSB1,speed=9600,parity=no,databits=8". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suboption</td><td>sub-option to extract. If NULL or empty, the first option will be extracted (if present). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>default value, returned if sub-option isn't found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>user supplied buffer for returning the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the sub-option isn't found, the <em>def</em> default value will be copied to <em>value</em> and <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbca21d0994cd19d1d3512772ef4772f5383" title="Success - ok (POSIX). ">GS_OK</a> will be returned. </dd>
<dd>
GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a7fa7590432077d2efe5fc6be1a33737f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_get_suboption_uint8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suboption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract suboption (as uint8) from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options string, e.g. "/dev/ttyUSB1,speed=9600,parity=no,databits=8". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suboption</td><td>sub-option to extract. If NULL or empty, the first option will be extracted (if present). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>default value, returned if sub-option isn't found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>user supplied buffer for returning the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the sub-option isn't found, the <em>def</em> default value will be copied to <em>value</em> and <a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbca21d0994cd19d1d3512772ef4772f5383" title="Success - ok (POSIX). ">GS_OK</a> will be returned. </dd>
<dd>
GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a56be1a264cccf046e64e4e47939ba508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gs_string_has_wildcards </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <em>true</em> if string contains wildcards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to check for wildcards. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if string contains wildcards recognized by <a class="el" href="string_8h.html#a50444f8514e9e9008b4f7b834198a510" title="Case-insentive wilcard match (similiar to fnmatch). ">gs_string_match()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ec22c490df1810c17c4b456b8b575b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_hex_to_uint32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to uint32 (hexadecimal). </p>
<p>Accepts: hexadecimal (no leading 0x), e.g. a123, A123. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a0f671278893975d4069b6b40c41e8357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_hex_to_uint64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to uint64 (hexadecimal). </p>
<p>Accepts: hexadecimal (no leading 0x), e.g. a123, A123. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a50444f8514e9e9008b4f7b834198a510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gs_string_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Case-insentive wilcard match (similiar to fnmatch). </p>
<p>Supports following wildcard(s):</p><ul>
<li>* (asterix) zero or more characters.</li>
</ul>
<p>This may be extended in future versions and will not be considered a break of the API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>pattern to match against <em>string</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to match against <em>pattern</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if match, else \ false </dd></dl>

</div>
</div>
<a class="anchor" id="a839145ebb114212fb2b6c079901626e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* gs_string_skip_leading_spaces </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to first none-space character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if <em>string</em> is NULL, otherwise first none-space character. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaa28e53fc3a79ce82453f66964118a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gs_string_strto32int </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GS implementation of gcc's strtol Instead of setting errno this function takes a pointer to err which is set the same way as with gcc's strtol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nptr</td><td>input string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endptr</td><td>the pointer to the end of the string parsed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>number system (10 or 16) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>return value if overflow </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value </dd></dl>

</div>
</div>
<a class="anchor" id="a8ce79624ffc8775709f13736c82fac17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t gs_string_strto32uint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GS implementation of gcc's strtoul Instead of setting errno this function takes a pointer to err which is set the same way as with gcc's strtoul. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nptr</td><td>input string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endptr</td><td>the pointer to the end of the string parsed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>number system (10 or 16) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>return value if overflow </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value </dd></dl>

</div>
</div>
<a class="anchor" id="ac717927a1e5b25f439dfefa7c30ef71f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t gs_string_strto64int </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GS implementation of gcc's strtoul Instead of setting errno this function takes a pointer to err which is set the same way as with gcc's strtoul. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nptr</td><td>input string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endptr</td><td>the pointer to the end of the string parsed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>number system (10 or 16) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>return value if overflow </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value </dd></dl>

</div>
</div>
<a class="anchor" id="ae947bccc033cd49d53561ca0faa3e47a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gs_string_strto64uint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GS implementation of gcc's strtoul Instead of setting errno this function takes a pointer to err which is set the same way as with gcc's strtoul. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nptr</td><td>input string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endptr</td><td>the pointer to the end of the string parsed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>number system (10 or 16) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>return value if overflow </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted value </dd></dl>

</div>
</div>
<a class="anchor" id="a563c64b09477621c294a91717e1de0ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_bool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pvalue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to boolean. </p>
<p>Accepts: true, false, on, off, 1, 0 (ignores case) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvalue</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a552b642283d80b4ff7389c440d88df8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_double </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pvalue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvalue</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a3bb47b8fe0246620b58c7e323eba4c48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_float </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pvalue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvalue</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a196d4a8092528ca798a86c7052d4f7eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_int16 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to int16 (decimal or hexadecimal). </p>
<p>Accepts: decimal or hexadecimal, 1234 (decimal), 0x1234 (hexadecimal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a799d737582c2b0a65cf3851d77caec1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_int32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to int32 (decimal or hexadecimal). </p>
<p>Accepts: decimal or hexadecimal, 1234 (decimal), 0x1234 (hexadecimal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a57cf68f8115ad9e0567d4d23ef1378fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_int64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to int64 (decimal or hexadecimal). </p>
<p>Accepts: decimal or hexadecimal, 1234 (decimal), 0x1234 (hexadecimal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a667e7518241b8c24abc962bc8dc4942d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_int8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to int8 (decimal or hexadecimal). </p>
<p>Accepts: decimal or hexadecimal, 12 (decimal), 0x12 (hexadecimal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ae09fb1246c82338a7fcf11e4dc9c8e36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_pointer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to pointer (decimal or hexadecimal). </p>
<p>Accepts: decimal or hexadecimal, 1234 (decimal), 0x1234 (hexadecimal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a3b68d6f18861ae50823ff534bc551365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_uint16 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to uint16 (decimal or hexadecimal). </p>
<p>Accepts: decimal or hexadecimal, 1234 (decimal), 0x1234 (hexadecimal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a25742ce805423d0aa63a9ea67d1807ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_uint32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to uint32 (decimal or hexadecimal). </p>
<p>Accepts: decimal or hexadecimal, 1234 (decimal), 0x1234 (hexadecimal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a7239cb0e60456c8d54303c2cd7ea2e52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_uint64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to uint64 (decimal or hexadecimal). </p>
<p>Accepts: decimal or hexadecimal, 1234 (decimal), 0x1234 (hexadecimal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="aba1047e7f27a38d9c03c67abba1d6584"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_string_to_uint8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to uint8 (decimal or hexadecimal). </p>
<p>Accepts: decimal or hexadecimal, 12 (decimal), 0x12 (hexadecimal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>string to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>converted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_ERROR_OVERFLOW if the resulting value is larger than the output type </dd>
<dd>
GS_ERROR_DATA if the input string could not be parsed completely </dd>
<dd>
GS_ERROR_ARG if the input string is a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a472626a74f2b1d42a100b8e0cfea7a3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gs_string_trim </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim string in buffer by removing leading/trailing white space. </p>
<p>Uses isspace(c).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>buffer to trim. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of <em>buffer</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
    <table width="100%" border="0">
      <tr>
	<td>Copyright &copy; 2013-2020 GomSpace A/S. All rights reserved. </td>
	<td><right>Generated by Doxygen 1.8.11</right></td>
      </tr>
    </table>
</small></address>
</body>
</html>
